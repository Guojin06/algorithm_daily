# 递归方法论体系 - 完整版

> **目标**：建立系统的递归思维模型，做到递归不出差错

---

## 📋 目录

1. [递归的本质理解](#1-递归的本质理解)
2. [递归函数设计五步法](#2-递归函数设计五步法)
3. [三大递归场景分类](#3-三大递归场景分类)
4. [递归检查清单](#4-递归检查清单)
5. [常见错误与避坑指南](#5-常见错误与避坑指南)
6. [递归复杂度分析](#6-递归复杂度分析)
7. [递归优化技巧](#7-递归优化技巧)

---

## 1. 递归的本质理解

### 1.1 什么是递归？

```
递归 = 函数调用自己 + 递归出口

核心思想：
1. 把大问题拆解成"相同类型"的小问题
2. 找到最小问题的答案（递归出口）
3. 利用小问题的答案构建大问题的答案
```

### 1.2 递归三要素

```cpp
ReturnType function(Parameters) {
    // 1. 递归出口（Base Case）
    if (到达边界条件) {
        return 直接结果;
    }
    
    // 2. 递归体（Recursive Case）
    // 调用自己处理更小的问题
    
    // 3. 返回值
    // 如何利用子问题的结果
}
```

### 1.3 递归思维的关键

**关键1：只考虑当前层做什么**
```
不要试图在脑海中展开整个递归过程！
只需要思考：
- 当前层要做什么？
- 子问题返回什么？
- 如何利用子问题的结果？
```

**关键2：相信递归会正确工作**
```
假设递归函数已经正确实现了功能
只需要思考如何利用它解决当前问题
```

**关键3：找准递归的语义**
```
递归函数必须有明确的功能定义
每次调用的语义必须一致
```

---

## 2. 递归函数设计五步法

### 第1步：明确函数语义

```
问自己：这个递归函数的作用是什么？

示例：
- fibonacci(n)：返回第n个斐波那契数
- treeDepth(root)：返回以root为根的树的深度
- dfs(node)：遍历以node为根的子树
```

**检查点**：
- ✅ 函数功能清晰明确
- ✅ 参数含义明确
- ✅ 返回值含义明确

---

### 第2步：找递归出口（Base Case）

```
问自己：什么时候不需要再递归？

常见递归出口：
1. 到达边界：root == nullptr, index >= n
2. 问题最小：n == 0, n == 1
3. 找到答案：count == k
4. 搜索结束：visited[x] == true
```

**原则**：
- ✅ 必须有递归出口（否则无限递归）
- ✅ 递归出口要覆盖所有边界情况
- ✅ 出口应该返回最简单、直接的结果

**示例**：
```cpp
// 二叉树递归出口
if (root == nullptr) return 0;

// 数组递归出口
if (index >= nums.size()) return;

// 数值递归出口
if (n <= 1) return n;
```

---

### 第3步：确定子问题

```
问自己：
1. 大问题如何拆解成小问题？
2. 小问题和大问题是否是"同类型"的？
3. 小问题的参数是什么？
```

**常见拆解方式**：

**方式1：一分为二**
```cpp
// 二叉树：分成左右子树
int leftDepth = treeDepth(root->left);
int rightDepth = treeDepth(root->right);
```

**方式2：减少规模**
```cpp
// 数值：n → n-1
int result = n + sum(n - 1);

// 数组：index → index+1
dfs(nums, index + 1);
```

**方式3：多路分支**
```cpp
// 回溯：尝试所有可能的选择
for (int i = 0; i < n; i++) {
    dfs(i);
}
```

---

### 第4步：设计递归体

```
问自己：如何利用子问题的结果？

根据问题类型选择：
1. 信息收集型：收集子问题的返回值
2. 结构修改型：修改树/图的结构
3. 路径搜索型：累积路径信息
```

**信息收集型示例**：
```cpp
// 收集左右子树信息
int leftDepth = maxDepth(root->left);
int rightDepth = maxDepth(root->right);
return max(leftDepth, rightDepth) + 1;
```

**结构修改型示例**：
```cpp
// 修改子树后返回新结构
root->left = pruneTree(root->left);
root->right = pruneTree(root->right);
return (满足删除条件) ? nullptr : root;
```

**路径搜索型示例**：
```cpp
// 累积路径信息
path.push_back(x);
dfs(next);
path.pop_back();  // 回溯
```

---

### 第5步：检查语义一致性

```
问自己：
1. 所有返回值的语义是否一致？
2. 参数传递是否正确？
3. 全局变量的修改是否正确？
```

**语义一致性检查**：
```cpp
// ❌ 错误：语义不一致
TreeNode* function(root) {
    if (root == nullptr) return nullptr;  // 返回空指针
    if (叶子节点) return root;             // 返回节点指针
    // ...
    return 0;  // ❌ 返回了整数！语义混乱
}

// ✅ 正确：语义一致
TreeNode* function(root) {
    if (root == nullptr) return nullptr;  // 都是指针
    if (叶子节点) return root;             // 都是指针
    // ...
    return root;  // 都是指针 ✅
}
```

---

## 3. 三大递归场景分类

### 3.1 二叉树递归（树形结构）

**特点**：
- 自然的递归结构（左子树 + 右子树）
- 通常需要收集子树信息

**核心模板**：
```cpp
ReturnType treeFunction(TreeNode* root) {
    // 1. 递归出口
    if (root == nullptr) return 初始值;
    
    // 2. 递归处理子树
    ReturnType left = treeFunction(root->left);
    ReturnType right = treeFunction(root->right);
    
    // 3. 利用子树结果
    return combine(left, right, root->val);
}
```

**三种遍历方式**：
```cpp
// 前序遍历（根→左→右）
void preorder(TreeNode* root) {
    if (root == nullptr) return;
    process(root);           // 处理当前节点
    preorder(root->left);    // 左子树
    preorder(root->right);   // 右子树
}

// 中序遍历（左→根→右）
void inorder(TreeNode* root) {
    if (root == nullptr) return;
    inorder(root->left);     // 左子树
    process(root);           // 处理当前节点
    inorder(root->right);    // 右子树
}

// 后序遍历（左→右→根）
void postorder(TreeNode* root) {
    if (root == nullptr) return;
    postorder(root->left);   // 左子树
    postorder(root->right);  // 右子树
    process(root);           // 处理当前节点
}
```

**遍历方式选择**：
```
前序遍历：
- 路径问题（需要先访问当前节点）
- 自顶向下传递信息
- 复制/克隆树

中序遍历：
- BST相关（天然有序）
- 需要按顺序访问节点

后序遍历：
- 树的结构修改（删除、剪枝）
- 需要先知道子树信息
- 自底向上传递信息
```

**常见问题类型**：
1. **求深度/高度** → 后序遍历，收集子树深度
2. **验证BST** → 中序遍历，检查是否递增
3. **路径和问题** → 前序遍历，累积路径
4. **树的修改** → 后序遍历，先处理子树

---

### 3.2 回溯递归（搜索空间）

**特点**：
- 需要遍历所有可能性
- 做选择 → 递归 → 撤销选择
- 关键是恢复现场

**核心模板**：
```cpp
void backtrack(状态参数) {
    // 1. 递归出口
    if (满足条件) {
        记录结果;
        return;  // ← 只记录，不恢复！
    }
    
    // 2. 回溯体
    for (遍历所有选择) {
        if (剪枝条件) continue;
        
        // 做选择
        修改状态;
        
        // 递归
        backtrack(下一层参数);
        
        // ✅ 撤销选择（恢复现场）← 必须在递归后！
        恢复状态;
    }
}
```

**⚠️ 重要提醒：用if不用while！**
```cpp
// ❌ 错误：用while循环
while(条件) {
    做选择;
    递归;
    恢复;
}
// while会一直循环，不符合回溯逻辑

// ✅ 正确：用if判断
if(条件) {
    做选择;
    递归;
    恢复;
}
// if是"尝试一次，递归，回溯"
```

**关键点：恢复现场的时机**
```cpp
// ✅ 正确：在递归后恢复
for (...) {
    path.push_back(x);  // 做选择
    dfs(...);           // 递归
    path.pop_back();    // 撤销选择 ← 在这里！
}

// ❌ 错误：在出口恢复
if (满足条件) {
    记录结果;
    path.pop_back();  // ❌ 你不知道该恢复哪个！
}
```

**回溯六大类型总结**（Day26-27实战总结）：

| 类型 | 集合来源 | check数组 | index参数 | for循环 | 递归参数 | 典型题目 |
|------|---------|-----------|-----------|---------|----------|----------|
| 全排列 | 同一个数组 | ✅ 需要 | ❌ 不需要 | 需要 (i=0) | 不变 | LeetCode 46/47 |
| 子集/组合 | 同一个数组 | ❌ 不需要 | ✅ 需要 | 需要 (i=index) | i+1 | LeetCode 78/77 |
| 多集合组合 | 不同集合 | ❌ 不需要 | ✅ 需要 | 需要 (i=0) | index+1 | LeetCode 17 |
| 剪枝生成 | 同类元素 | ❌ 不需要 | 特殊变量 | 不需要 | 状态参数 | LeetCode 22 |
| **符号选择** | 固定元素 | ❌ 不需要 | ✅ 需要(pos) | **不需要** | pos+1 | **LeetCode 494** |
| **多约束排列** | 二维空间 | **✅ 需要多个** | ✅ 需要(row) | 需要 (i=0) | row+1 | **LeetCode 51** ⭐ |

**判断技巧**：
- 从同一集合选，关心顺序 → 全排列型
- 从同一集合选，不关心顺序 → 子集型
- 每层从不同集合选 → 多集合组合型
- 需要保证合法性 → 剪枝生成型
- **每个元素都用，只选符号/属性 → 符号选择型** ⭐ Day27新增
- **二维空间+多约束条件 → 多约束排列型（N皇后）** ⭐⭐⭐ Day27新增

---

**常见模式**：

**模式1：全排列型（关心顺序）**
```cpp
bool check[n];  // 标记是否已用

void dfs(nums) {
    if (path.size() == n) {
        ret.push_back(path);
        return;
    }
    
    for (int i = 0; i < n; i++) {  // 从0开始
        if (check[i]) continue;
        
        path.push_back(nums[i]);
        check[i] = true;
        dfs(nums);
        path.pop_back();
        check[i] = false;
    }
}
```

**模式2：子集/组合型（不关心顺序）**
```cpp
void dfs(nums, index) {  // 用index避免重复
    ret.push_back(path);  // 每个节点都记录
    
    for (int i = index; i < n; i++) {  // 从index开始
        path.push_back(nums[i]);
        dfs(nums, i + 1);  // 传i+1（只往后选）
        path.pop_back();
    }
}
```

**模式3：符号选择型（Day27新增）** ⭐
```cpp
void dfs(nums, pos, sum, target) {
    // 1. 递归出口（处理完所有元素）
    if (pos >= nums.size()) {
        if (sum == target) ret++;
        return;
    }
    
    // 2. 不需要for循环！每个位置固定k个选择
    // 选择1：给nums[pos]加正号
    dfs(nums, pos + 1, sum + nums[pos], target);
    
    // 选择2：给nums[pos]加负号
    dfs(nums, pos + 1, sum - nums[pos], target);
}
```

**特点**：
- **每个元素都必须使用**
- **只是符号/属性不同**
- **不需要for循环**（固定k个选择）
- **不需要check数组**（不是选不选的问题）
- **复杂度：O(k^n)**，k=选择数，n=元素数

**三种模式对比**：
| 特性 | 全排列 | 子集/组合 | 符号选择 |
|------|--------|-----------|----------|
| 关心顺序 | ✅ | ❌ | ❌ |
| 元素必须全用 | ✅ | ❌ | ✅ |
| for循环 | 需要 (i=0) | 需要 (i=index) | 不需要 |
| 递归参数 | 不变 | `i+1` | `pos+1` |
| check数组 | 需要 | 不需要 | 不需要 |
| 记录时机 | 叶子 | 所有节点 | 叶子 |
| 复杂度 | O(n!) | O(2^n) | O(k^n) |

---

**模式6：多约束排列型（N皇后）** ⭐⭐⭐ Day27新增

```cpp
// 需要多个check数组
bool col[n];       // 列标记
bool diag1[2*n];   // 左上-右下对角线
bool diag2[2*n];   // 右上-左下对角线
vector<string> board;  // 棋盘状态

void dfs(int row, int n) {
    // 递归出口：所有行都放完了
    if (row == n) {
        ret.push_back(board);
        return;
    }
    
    // 尝试在第row行的每一列放皇后
    for (int c = 0; c < n; c++) {  // 从0开始遍历所有列
        // 检查三个约束条件
        if (!col[c] && !diag1[row - c + n] && !diag2[row + c]) {
            // 做选择
            board[row][c] = 'Q';
            col[c] = true;
            diag1[row - c + n] = true;
            diag2[row + c] = true;
            
            // 递归下一行
            dfs(row + 1, n);
            
            // 恢复现场
            board[row][c] = '.';
            col[c] = false;
            diag1[row - c + n] = false;
            diag2[row + c] = false;
        }
    }
}
```

**特点**：
- **逐行放置**：每行恰好1个元素（类似全排列）
- **多个约束**：列 + 两条对角线
- **需要多个check数组**（而非一个）
- **对角线判定技巧**：用数学公式 O(1) 判断

**对角线判定公式** ⭐⭐⭐：
```
左上-右下对角线：row - col 相同
  → diag1[row - c + n]  // +n防止负数

右上-左下对角线：row + col 相同
  → diag2[row + c]      // 本来就非负

示例（n=4）：
  左上-右下：
    (0,0),(1,1),(2,2),(3,3)：row-col都是0
    (0,1),(1,2),(2,3)：row-col都是-1
  
  右上-左下：
    (0,3),(1,2),(2,1),(3,0)：row+col都是3
    (0,2),(1,1),(2,0)：row+col都是2
```

**为什么巧妙？**
- 传统方法：遍历整条对角线 O(n)
- 优化方法：数学特性，O(1) 判断！
- **用数学抽象替代暴力遍历**

**与全排列的区别**：
| 特性 | 全排列 | N皇后 |
|------|--------|-------|
| check数组 | 1个 | 3个 |
| 约束条件 | 1个（是否已用） | 3个（列+2对角线） |
| for循环 | `i=0~n-1` | `c=0~n-1` |
| 递归参数 | 不变 | `row+1` |
| 复杂度 | O(n!) | O(n!)（但剪枝更多） |

---

### 3.3 分治递归（问题拆解）

**特点**：
- 问题可以分解成独立的子问题
- 子问题解决后合并结果
- 通常有明确的返回值

**核心模板**：
```cpp
ReturnType divideConquer(问题范围) {
    // 1. 递归出口
    if (问题最小) {
        return 直接结果;
    }
    
    // 2. 分解问题
    ReturnType left = divideConquer(左半部分);
    ReturnType right = divideConquer(右半部分);
    
    // 3. 合并结果
    return merge(left, right);
}
```

**经典应用**：
```cpp
// 归并排序
void mergeSort(arr, left, right) {
    if (left >= right) return;
    
    int mid = (left + right) / 2;
    mergeSort(arr, left, mid);      // 排序左半部分
    mergeSort(arr, mid + 1, right); // 排序右半部分
    merge(arr, left, mid, right);   // 合并
}

// 快速排序
void quickSort(arr, left, right) {
    if (left >= right) return;
    
    int pivot = partition(arr, left, right);  // 分区
    quickSort(arr, left, pivot - 1);          // 排序左半部分
    quickSort(arr, pivot + 1, right);         // 排序右半部分
}
```

---

## 4. 递归检查清单

### 开始写代码前（设计阶段）

- [ ] **函数语义是否清晰？**
  - 函数的作用是什么？
  - 参数的含义是什么？
  - 返回值的含义是什么？

- [ ] **递归出口是否正确？**
  - 是否覆盖所有边界情况？
  - 是否会无限递归？
  - 出口返回值是否正确？

- [ ] **子问题是否比原问题小？**
  - 递归参数是否在缩小？
  - 是否会陷入死循环？

- [ ] **子问题类型是否一致？**
  - 子问题和原问题是否是同一类问题？
  - 递归调用的参数是否合理？

---

### 写完代码后（检查阶段）

- [ ] **返回值语义一致性**
  - 所有return的类型是否一致？
  - 所有return的语义是否相同？

- [ ] **参数传递正确性**
  - 传值 vs 引用是否正确？
  - index/指针是否正确更新？

- [ ] **全局变量处理**
  - 是否需要恢复现场？
  - 恢复现场的位置是否正确？

- [ ] **空指针检查**
  - 访问指针前是否判空？
  - nullptr的处理是否正确？

- [ ] **边界条件测试**
  - 空输入的处理？
  - 单元素的处理？
  - 最大输入的处理？

---

### 回溯专项检查

- [ ] **恢复现场位置正确？**
  - 是否在递归调用后恢复？
  - 做选择和撤销选择是否配对？

- [ ] **是否需要check数组？**
  - 全排列型 → 需要
  - 子集/组合型 → 不需要（用index）

- [ ] **记录结果的时机？**
  - 全排列 → 叶子节点
  - 子集 → 所有节点

- [ ] **剪枝是否完善？**
  - 是否有不必要的递归？
  - 能否提前返回？

---

## 5. 常见错误与避坑指南

### 错误1：递归出口缺失或不完整

```cpp
// ❌ 错误：缺少nullptr检查
int treeDepth(TreeNode* root) {
    return max(treeDepth(root->left), treeDepth(root->right)) + 1;
    // 如果root为空，会崩溃！
}

// ✅ 正确：先检查边界
int treeDepth(TreeNode* root) {
    if (root == nullptr) return 0;  // 递归出口
    return max(treeDepth(root->left), treeDepth(root->right)) + 1;
}
```

---

### 错误2：返回值语义不一致

```cpp
// ❌ 错误：语义混乱
TreeNode* pruneTree(TreeNode* root) {
    if (root == nullptr) return nullptr;
    if (root->left == nullptr && root->right == nullptr) 
        return root;  // ← 没判断是否该删除，提前返回
    
    // ... 后续代码无法执行到值为0的叶子节点
}

// ✅ 正确：统一判断
TreeNode* pruneTree(TreeNode* root) {
    if (root == nullptr) return nullptr;
    
    root->left = pruneTree(root->left);
    root->right = pruneTree(root->right);
    
    // 统一判断删除条件
    if (root->left == nullptr && root->right == nullptr && root->val == 0)
        return nullptr;
    return root;
}
```

---

### 错误3：回溯恢复现场位置错误

```cpp
// ❌ 错误：在出口恢复
void dfs() {
    if (path.size() == n) {
        ret.push_back(path);
        path.pop_back();  // ❌ 你不知道该恢复哪个！
        return;
    }
    // ...
}

// ✅ 正确：在递归后恢复
void dfs() {
    if (path.size() == n) {
        ret.push_back(path);
        return;  // 只记录，不恢复
    }
    
    for (...) {
        path.push_back(x);
        dfs();
        path.pop_back();  // ✅ 在递归后恢复
    }
}
```

---

### 错误4：全局变量忘记恢复

```cpp
// ❌ 错误：忘记恢复check数组
void dfs() {
    for (int i = 0; i < n; i++) {
        if (check[i]) continue;
        
        path.push_back(nums[i]);
        check[i] = true;
        dfs();
        path.pop_back();
        // ❌ 忘记 check[i] = false;
    }
}

// ✅ 正确：严格配对
void dfs() {
    for (int i = 0; i < n; i++) {
        if (check[i]) continue;
        
        path.push_back(nums[i]);
        check[i] = true;
        dfs();
        path.pop_back();
        check[i] = false;  // ✅ 恢复
    }
}
```

---

### 错误5：混淆全排列和子集

```cpp
// 全排列：需要check，从0开始
for (int i = 0; i < n; i++) {
    if (!check[i]) { ... }
}

// 子集：不需要check，从index开始
for (int i = index; i < n; i++) {
    dfs(nums, i + 1);
}

// ❌ 常见错误：子集用了check，或者从0开始
// 会导致重复子集
```

---

### 错误6：空指针访问

```cpp
// ❌ 错误：直接访问可能为空的指针
if (root->left->val == 0) { ... }

// ✅ 正确：先判空
if (root->left != nullptr && root->left->val == 0) { ... }

// ✅ 更好：先判空，再访问
if (root->left == nullptr) return;
if (root->left->val == 0) { ... }
```

---

### 错误7：子集问题的致命错误（Day26发现）

```cpp
// ❌ 致命错误：递归参数写成pos而不是i+1
void dfs(nums, pos) {
    for(int i = pos; i < n; i++) {
        dfs(nums, pos);  // ❌ 会导致无限递归！
    }
}

// ✅ 正确：必须传i+1
void dfs(nums, pos) {
    for(int i = pos; i < n; i++) {
        dfs(nums, i + 1);  // ✅ 只往后选
    }
}
```

**记忆口诀**：
```
pos是起点，i是当前
递归传i+1，不能传pos
```

---

### 错误8：恢复现场不完整（Day26发现）

```cpp
// ❌ 错误：只恢复了部分状态
path.push_back(x);
countl--;
check++;
dfs();
path.pop_back();  // ✅ 恢复了path
// ❌ 忘记恢复countl和check

// ✅ 正确：完整恢复
path.push_back(x);
countl--;
check++;
dfs();
path.pop_back();  // 恢复path
countl++;         // 恢复countl
check--;          // 恢复check
```

**检查清单**：
- [ ] path是否恢复？
- [ ] 所有修改的变量是否恢复？
- [ ] 恢复的顺序是否与修改相反？

---

### 错误9：用while代替if（Day26发现）

```cpp
// ❌ 错误：用while循环
while(countl > 0) {
    做选择;
    dfs();
    恢复;
}
// while会一直循环，不符合回溯逻辑

// ✅ 正确：用if判断
if(countl > 0) {
    做选择;
    dfs();
    恢复;
}
// if是"尝试一次，递归，回溯"
```

---

### 错误10：去重条件不完整（Day26发现）

```cpp
// ❌ 错误：缺少check[i-1]判断
if(i > 0 && nums[i] == nums[i-1]) continue;

// ✅ 正确：完整的去重条件
if(i > 0 && nums[i] == nums[i-1] && !check[i-1]) continue;
```

**check[i-1]的含义**：
- `check[i-1] == false`：前一个元素已经"用完并回溯"
- 说明前一个元素的所有排列已经生成完毕
- 当前元素会产生重复，需要跳过

---

### 错误11：混淆pos参数和i变量（Day27发现）

```cpp
// ❌ 错误：push的是pos而不是i
void dfs(int pos) {
    for(int i = pos; i <= n; i++) {
        path.push_back(pos);  // ❌ 错！应该push i
        dfs(i+1);
        path.pop_back();
    }
}

// ✅ 正确：pos是导航，i是货物
void dfs(int pos) {
    for(int i = pos; i <= n; i++) {
        path.push_back(i);  // ✅ push当前遍历的i
        dfs(i+1);
        path.pop_back();
    }
}
```

**记忆口诀**：
```
pos是导航，指示起点
i是货物，真正的值
递归传i+1，不是pos
push时选i，不是pos
```

**for循环三要素**（组合/子集问题）：

| 要素 | 错误写法 | 正确写法 | 原因 |
|------|---------|---------|------|
| **起点** | `i = 1` 或 `i = 0` | `i = pos` | 保证只往后选 |
| **终点** | `i < n` | `i <= n` | n也要选到 |
| **push的值** | `push(pos)` | `push(i)` | pos是起点，i是当前值 |

---

### 错误12：出口条件不完整导致越界（Day27发现）

```cpp
// ❌ 错误：只处理满足条件的情况
void dfs(int pos, int sum, int target) {
    if(pos >= nums.size() && sum == target) {  // ❌ 只处理一种情况
        ret++;
        return;
    }
    // 如果 pos >= size 但 sum != target 呢？
    // 没有return，继续执行下面代码 → nums[pos]越界！
    
    dfs(pos+1, sum + nums[pos], target);  // 💥 越界访问
}

// ✅ 正确：先判断边界，再分情况
void dfs(int pos, int sum, int target) {
    if(pos >= nums.size()) {  // ✅ 只要到边界就返回
        if(sum == target) ret++;
        return;  // 无论如何都要返回！
    }
    
    // 这里pos < nums.size()，可以安全访问nums[pos]
    dfs(pos+1, sum + nums[pos], target);
}
```

**原则**：
```
出口条件必须完整覆盖所有边界情况！

模板：
if (到达边界) {
    处理结果;
    return;  // ✅ 必须返回
}
// 只有未到达边界，才能继续访问数组
```

**常见错误模式**：
```cpp
// ❌ 错误模式1：用 && 连接多个条件
if (边界条件 && 结果条件) {
    return;
}
// 会漏掉"边界但不满足结果"的情况

// ✅ 正确模式：先判边界，再判结果
if (边界条件) {
    if (结果条件) { ... }
    return;
}
```

---

## 6. 递归复杂度分析

> **目标**：掌握递归时间/空间复杂度的计算方法，判断是否会超时

### 6.1 递归的两大限制

#### **限制1：空间限制（栈深度）**

| 问题 | 限制 | 原因 |
|------|------|------|
| **最大递归深度** | ~1000-10000层 | 函数调用栈大小限制 |
| C++默认栈大小 | ~1-8MB | 操作系统限制 |
| 每次递归占用 | ~几百字节 | 函数调用开销 |

**栈溢出示例**：
```cpp
void dfs(int n) {
    if(n == 0) return;
    dfs(n - 1);  // 如果n=100000 → 栈溢出！
}
```

#### **限制2：时间限制（计算量）**

| OJ平台 | 时间限制 | 大致操作数 |
|--------|---------|----------|
| LeetCode | 1-3秒 | 10^8 次操作 |
| 比特OJ | 1-2秒 | 10^8 次操作 |
| Codeforces | 2-3秒 | 10^8 - 10^9 次操作 |

---

### 6.2 递归复杂度计算核心公式

```
时间复杂度 = 递归树的总节点数 × 每个节点的工作量
```

**步骤**：
1. 画出决策树（前几层即可）
2. 识别分支模式（固定/递减/全遍历）
3. 计算总节点数
4. 加上每个节点的工作量

---

### 6.3 不同递归结构的复杂度

#### **类型1：单路递归（链式）**

```cpp
void dfs(int n) {
    if(n == 0) return;
    dfs(n - 1);  // 只调用1次
}
```

| 特征 | 值 |
|------|-----|
| 时间复杂度 | O(n) |
| 空间复杂度 | O(n) |
| 可承受的n | **10^5 - 10^6** |

**例子**：链表遍历、阶乘计算

---

#### **类型2：二叉树递归（两路分叉）**

```cpp
void dfs(TreeNode* root) {
    if(!root) return;
    dfs(root->left);   // 调用1
    dfs(root->right);  // 调用2
}
```

| 特征 | 值 |
|------|-----|
| 时间复杂度 | O(n) n=节点数 |
| 空间复杂度 | O(h) h=树高 |
| 可承受的n | **10^4 - 10^5** |
| 最大深度 | 平衡树：O(log n)；链式树：O(n) |

**例子**：二叉树遍历、BST操作

---

#### **类型3：回溯（固定分支数）**

```cpp
void dfs(int pos) {
    if(pos >= n) return;
    dfs(pos + 1);  // 分支1
    dfs(pos + 1);  // 分支2
    // ... k个分支
}
```

| 特征 | 值 |
|------|-----|
| 时间复杂度 | **O(k^n)** k=每层分支数 |
| 空间复杂度 | O(n) |
| 可承受的n | **n ≤ 20-25**（当k=2时） |

**例子：LeetCode 494（目标和）**
```cpp
void dfs(int pos, int sum) {
    if(pos >= nums.size()) return;
    dfs(pos+1, sum+nums[pos]);  // 2个分支
    dfs(pos+1, sum-nums[pos]);
}

// 时间复杂度：O(2^n)
// n=20: 2^20 = 1,048,576 ✅ 可以
// n=25: 2^25 = 33,554,432 ✅ 极限
// n=30: 2^30 = 1,073,741,824 ❌ 超时！
```

**决策树分析**（n=3）：
```
           root
          /    \
       节点1   节点2      ← 第1层：2个节点
       / \     / \
      a  b   c  d       ← 第2层：4个节点
     /\ /\  /\ /\
    ... (共8个)         ← 第3层：8个节点

总节点数 = 1 + 2 + 4 + 8 = 2^4 - 1 ≈ O(2^3) = O(2^n)
```

---

#### **类型4：回溯 + for循环（变化分支数）**

```cpp
void dfs(int pos) {
    for(int i = pos; i < n; i++) {  // ← for循环！
        dfs(i + 1);
    }
}
```

| 特征 | 值 |
|------|-----|
| 时间复杂度 | **O(n×2^n)** 或更差 |
| 可承受的n | **n ≤ 15-20** |

**例子：LeetCode 77（组合）**
```cpp
void dfs(int pos) {
    ret.push_back(path);  // 记录，O(k)工作量
    for(int i = pos; i <= n; i++) {
        path.push_back(i);
        dfs(i + 1);
        path.pop_back();
    }
}

// 节点数：O(2^n)
// 每个节点工作量：O(n)（拷贝path）
// 总复杂度：O(n × 2^n)
// n=20: 20 × 2^20 ≈ 2000万 ✅ 可以
```

**决策树分析**（n=4）：
```
第1层 (pos=0): 4个分支 [0,1,2,3]
第2层 (pos=1): 3个分支 [1,2,3] (假设选了0)
第3层 (pos=2): 2个分支 [2,3]
第4层 (pos=3): 1个分支 [3]

总节点数 = C(n,0) + C(n,1) + ... + C(n,n) = 2^n
```

**例子：LeetCode 46（全排列）**
```cpp
void dfs() {
    if(path.size() == n) return;
    for(int i = 0; i < n; i++) {  // 每层都遍历所有
        if(check[i]) continue;
        check[i] = true;
        dfs();
        check[i] = false;
    }
}

// 时间复杂度：O(n!)
// n=10: 10! = 3,628,800 ✅ 可以
// n=12: 12! = 479,001,600 ⚠️ 接近极限
// n=15: 15! = 1.3×10^12 ❌ 超时！
```

**决策树分析**（n=4）：
```
第1层: 4个分支
第2层: 每个有3个分支 → 4×3 = 12个节点
第3层: 每个有2个分支 → 12×2 = 24个节点
第4层: 每个有1个分支 → 24×1 = 24个节点

总节点数 ≈ n! × e ≈ O(n!)
```

---

### 6.4 复杂度对比表

| 递归类型 | 时间复杂度 | n=10 | n=15 | n=20 | n=25 | 可承受的n |
|---------|-----------|------|------|------|------|-----------|
| **线性递归** | O(n) | 10 | 15 | 20 | 25 | 10^6 |
| **二叉树** | O(n) | 10 | 15 | 20 | 25 | 10^5 |
| **固定2分支** | O(2^n) | 1K | 33K | 1M | 33M | 25 |
| **组合/子集** | O(n×2^n) | 10K | 491K | 20M | 838M | 22 |
| **全排列** | O(n!) | 3.6M | 1.3×10^12 | 💥 | 💥 | 12 |

**图例**：
- ✅ < 10^7：安全
- ⚠️ 10^7 - 10^8：接近极限
- ❌ > 10^8：超时

---

### 6.5 快速判断方法

#### **方法1：看代码结构**

```cpp
// 模式1：无for循环，固定k次调用
void dfs(int pos) {
    if(pos >= n) return;
    dfs(pos+1);  // ×k次
}
// 复杂度：O(k^n)

// 模式2：for从pos开始
void dfs(int pos) {
    for(int i = pos; i < n; i++) {
        dfs(i+1);
    }
}
// 复杂度：O(2^n) 或 O(n×2^n)

// 模式3：for从0开始，check数组
void dfs() {
    for(int i = 0; i < n; i++) {
        if(check[i]) continue;
        dfs();
    }
}
// 复杂度：O(n!)
```

#### **方法2：看for循环起点**

| for起点 | 递归参数 | 复杂度 | 可承受的n | 典型题目 |
|--------|---------|--------|-----------|---------|
| 无for循环 | `dfs(pos+1)`×k次 | O(k^n) | **20-30** | 目标和、括号生成 |
| `i = pos` | `dfs(i+1)` | O(2^n) | **20-25** | 子集、组合 |
| `i = 0` | `dfs()` + check | O(n!) | **10-12** | 全排列 |

#### **方法3：看每层分支数变化**

```
固定k个分支 → O(k^n)
逐层减少1个分支 → O(2^n)
每层都是n个分支 → O(n!)
```

---

### 6.6 实际数据范围参考

| 题目类型 | n范围 | 复杂度 | 示例题目 |
|---------|------|--------|---------|
| **链表/数组递归** | n ≤ 10^5 | O(n) | 反转链表 |
| **二叉树** | n ≤ 10^4 | O(n) | 树的遍历 |
| **回溯-固定分支** | n ≤ 20 | O(2^n) | 目标和(494) |
| **回溯-组合** | n ≤ 20 | O(n×2^n) | 组合(77)、子集(78) |
| **回溯-排列** | n ≤ 10 | O(n!) | 全排列(46) |
| **N皇后** | n ≤ 12 | O(n!) | N皇后(51) |

---

### 6.7 复杂度计算步骤示例

#### **示例：目标和（LeetCode 494）**

**代码**：
```cpp
void dfs(int pos, int sum) {
    if(pos >= n) {
        if(sum == target) ret++;
        return;
    }
    dfs(pos+1, sum + nums[pos]);
    dfs(pos+1, sum - nums[pos]);
}
```

**计算步骤**：

**Step 1：画决策树**（n=3）
```
                 []
                / \
              +1  -1      ← 2个分支
             / \  / \
           +2 -2 +2 -2   ← 4个分支
          /\ /\ /\ /\
         ... (8个)       ← 8个分支
```

**Step 2：识别分支模式**
- 每层固定2个分支
- 共n层
- 总节点数 = 2^0 + 2^1 + ... + 2^n = 2^(n+1) - 1

**Step 3：计算复杂度**
```
节点数：O(2^n)
每个节点工作量：O(1)
总复杂度：O(2^n)
```

**Step 4：判断是否超时**
```
n=20: 2^20 = 1,048,576 ≈ 100万
✅ 不会超时
```

---

### 6.8 常见错误的复杂度分析

#### **错误：for循环 + 双分支**

```cpp
// ❌ 错误代码（Day27发现）
void dfs(int pos) {
    for(int i = pos; i < n; i++) {  // n-pos个选择
        dfs(i+1);  // 分支1
        dfs(i+1);  // 分支2（重复！）
    }
}

// 复杂度：O(2^n × n!)
// n=10: 2^10 × 10! ≈ 37亿 ❌ 超时！
```

**为什么这么高？**
```
第1层 (pos=0): 
  for i=0 to n-1: n个选择
    每个i调用2次 = 2n次调用

第2层 (pos=1):
  for i=1 to n-1: (n-1)个选择
    每个i调用2次 = 2(n-1)次调用

总调用次数 ≈ 2n × 2(n-1) × ... = 2^n × n!
```

---

### 6.9 复杂度速查表

**常用数值**：
```
2^10 = 1,024 ≈ 1千
2^20 = 1,048,576 ≈ 100万
2^30 = 1,073,741,824 ≈ 10亿

10! = 3,628,800 ≈ 360万
12! = 479,001,600 ≈ 4.8亿
15! = 1,307,674,368,000 ≈ 1.3万亿
```

**记忆法**：
- **没有for循环**：O(分支数^n)，n可以到20-25
- **for从pos开始**：O(n×2^n)，n可以到20
- **for从0开始**：O(n!)，n只能到10-12

---

### 6.10 核心总结

#### **判断公式**
```
时间复杂度 = 递归树节点数 × 每个节点工作量

递归树节点数 ≈ 分支数^层数
```

#### **安全阈值**
```
如果递归调用次数 > 10^8，很可能超时
```

#### **快速估算**
1. 数分支数k和层数n
2. 计算k^n
3. 如果k^n < 10^8，则安全

#### **三个关键问题**
1. **有没有for循环？**
   - 无：O(k^n)
   - 有：O(2^n) 或 O(n!)

2. **for从哪开始？**
   - pos：O(2^n)
   - 0：O(n!)

3. **每层几个分支？**
   - 固定k个：O(k^n)
   - 逐层减少：O(2^n)
   - 都是n个：O(n!)

---

## 7. 递归优化技巧

### 7.1 剪枝优化

**基础剪枝**：
```cpp
// 提前返回，避免不必要的递归
void dfs() {
    if (已找到答案) return;  // 剪枝
    if (当前路径不可能) return;  // 剪枝
    
    // 正常递归
}
```

**剪枝技巧（Day26总结）**：

#### **剪枝类型1：数量限制**
```cpp
// 示例：括号生成
if(countl > 0) {  // 还有剩余左括号
    放左括号;
}
```

#### **剪枝类型2：合法性检查**
```cpp
// 示例：括号生成
if(countr > 0 && check > 0) {  // check>0保证合法
    放右括号;
}
```

**check变量技巧**：
```cpp
int check = 0;  // 记录合法性

// 放左括号
path += '(';
check++;  // 左括号数+1

// 放右括号（需要check > 0）
if(check > 0) {
    path += ')';
    check--;  // 右括号数+1（check减少）
}
```

#### **剪枝类型3：去重（全排列II）**
```cpp
// 必须先排序
sort(nums.begin(), nums.end());

// 同层去重
if(i > 0 && nums[i] == nums[i-1] && !check[i-1]) {
    continue;  // 跳过重复元素
}
```

#### **剪枝类型4：避免重复（子集/组合）**
```cpp
// 用index保证只往后选
for(int i = index; i < n; i++) {
    dfs(nums, i + 1);  // 传i+1，不回头
}
```

### 6.2 记忆化搜索

```cpp
// 避免重复计算
unordered_map<int, int> memo;

int fib(int n) {
    if (n <= 1) return n;
    if (memo.count(n)) return memo[n];  // 已计算过
    
    memo[n] = fib(n-1) + fib(n-2);
    return memo[n];
}
```

### 6.3 尾递归优化

```cpp
// 普通递归
int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n - 1);  // 递归后还有操作
}

// 尾递归（最后一步是递归调用）
int sumTail(int n, int acc = 0) {
    if (n == 0) return acc;
    return sumTail(n - 1, acc + n);  // 最后一步就是递归
}
```

---

## 7. 实战应用流程

### 拿到新题后的思考流程

**第1步：识别问题类型**
```
- 树形结构？ → 二叉树递归
- 搜索所有可能？ → 回溯递归
- 可分解合并？ → 分治递归
```

**第2步：套用对应模板**
```
根据问题类型，选择对应的递归模板
```

**第3步：明确递归语义**
```
这个函数的作用是什么？
参数和返回值的含义？
```

**第4步：找递归出口**
```
什么时候停止递归？
边界条件是什么？
```

**第5步：设计递归体**
```
如何拆解子问题？
如何利用子问题结果？
```

**第6步：检查清单验证**
```
用检查清单逐项检查
画决策树验证逻辑
```

---

## 8. 总结

### 核心原则

1. **明确语义**：递归函数的功能必须清晰明确
2. **信任递归**：相信递归会正确工作，不要展开整个过程
3. **语义一致**：所有返回值的语义必须一致
4. **配对原则**：做选择和撤销选择必须配对
5. **只看当前**：只考虑当前层做什么，不要深入子层

### 记忆口诀

```
递归四问：
1. 这个函数干什么？（语义）
2. 什么时候停？（出口）
3. 如何变小？（子问题）
4. 如何利用？（递归体）

回溯三步：
1. 做选择
2. 递归
3. 撤销选择（必须在递归后！）
```

---

## 9. 练习建议

### 阶段1：基础递归（5-10题）
- 斐波那契数列
- 阶乘
- 二叉树深度
- 二叉树遍历
- 链表反转

### 阶段2：树形递归（10-15题）
- 二叉树的所有路径
- 验证二叉搜索树
- 对称二叉树
- 翻转二叉树
- 二叉树剪枝

### 阶段3：回溯递归（10-15题）
- 全排列
- 子集
- 组合
- 组合总和
- N皇后

### 阶段4：综合应用（开放）
- 复杂的树形DP
- 图的DFS
- 分治算法
- 动态规划（递归思维）

---

## 📊 更新日志

### v1.3 (2025-10-27) - Day27多约束排列型（N皇后）⭐⭐⭐

**新增内容**：
- ✅ **回溯第6种类型：多约束排列型（N皇后）** ⭐⭐⭐
  - 特点：逐行放置 + 多个约束条件
  - 需要3个check数组（列 + 2对角线）
  - **对角线判定公式**：`row - col + n` 和 `row + col`
  - 数学抽象：O(1)判断 vs O(n)遍历
- ✅ **对角线判定详解**：
  - 左上-右下：row - col 相同
  - 右上-左下：row + col 相同
  - 为什么 +n（防止负数下标）
- ✅ **与全排列的对比表**

**测试题目**：
- LeetCode 51 - N皇后 ⭐⭐⭐

**核心发现**：
1. **用数学抽象替代暴力遍历** - 对角线判定的精髓
2. **逐行放置思想** - 每行恰好1个，问题简化
3. **多约束管理** - 3个check数组协同工作
4. **空间换时间** - 标记数组O(1)判断

---

### v1.2 (2025-10-27) - Day27复杂度分析 & 符号选择型

**新增内容**：
- ✅ **递归复杂度分析完整章节**（第6章）
  - 递归的两大限制（空间/时间）
  - 5种递归结构的复杂度计算方法
  - 复杂度对比表和速查表
  - 详细计算步骤示例
  - 快速判断方法（看代码结构）
- ✅ **回溯第5种类型：符号选择型** ⭐
  - 特点：每个元素都用，只选符号/属性
  - 不需要for循环，固定k个选择
  - 复杂度：O(k^n)
- ✅ **2个新错误**（Day27发现）：
  - 错误11：混淆pos参数和i变量
  - 错误12：出口条件不完整导致越界
- ✅ **for循环三要素表格**（组合/子集问题）

**测试题目**：
- LeetCode 77 - 组合
- LeetCode 494 - 目标和

**核心发现**：
1. **pos是导航，i是货物** - 组合问题的关键理解
2. **符号选择 ≠ 组合选择** - 新的问题分类
3. **出口条件必须完整** - 先判边界，再判结果
4. **复杂度计算公式**：递归树节点数 × 每个节点工作量
5. **快速判断超时**：看for循环起点 + 分支数

---

### v1.1 (2025-10-26) - Day26实战完善
**新增内容**：
- ✅ 回溯四大类型总结表格
- ✅ 10个常见错误（新增5个Day26发现的错误）
- ✅ 剪枝技巧详解（4种类型）
- ✅ check变量的巧妙使用
- ✅ 去重条件完整解析

**测试题目**：
- LeetCode 1863 - 子集异或和
- LeetCode 47 - 全排列II  
- LeetCode 17 - 电话号码组合
- LeetCode 22 - 括号生成

**核心发现**：
1. `dfs(pos)` vs `dfs(i+1)` 的致命区别
2. `while` vs `if` 在回溯中的错误
3. 恢复现场必须完整
4. `check[i-1]` 的去重含义

---

### v1.0 (2025-10-25) - 初始版本
**基于题目**：Day24-25的8道题目总结
- 二叉树递归（4题）
- 回溯递归（4题）

---

**版本：v1.2**  
**最后更新：2025-10-27**  
**覆盖题目**：14道题（Day24-27）

> 💡 **提示**：这份方法论会随着做题不断完善和更新！

