# 递归方法论体系 - 完整版

> **目标**：建立系统的递归思维模型，做到递归不出差错

---

## 📋 目录

1. [递归的本质理解](#1-递归的本质理解)
2. [递归函数设计五步法](#2-递归函数设计五步法)
3. [三大递归场景分类](#3-三大递归场景分类)
4. [递归检查清单](#4-递归检查清单)
5. [常见错误与避坑指南](#5-常见错误与避坑指南)
6. [递归优化技巧](#6-递归优化技巧)

---

## 1. 递归的本质理解

### 1.1 什么是递归？

```
递归 = 函数调用自己 + 递归出口

核心思想：
1. 把大问题拆解成"相同类型"的小问题
2. 找到最小问题的答案（递归出口）
3. 利用小问题的答案构建大问题的答案
```

### 1.2 递归三要素

```cpp
ReturnType function(Parameters) {
    // 1. 递归出口（Base Case）
    if (到达边界条件) {
        return 直接结果;
    }
    
    // 2. 递归体（Recursive Case）
    // 调用自己处理更小的问题
    
    // 3. 返回值
    // 如何利用子问题的结果
}
```

### 1.3 递归思维的关键

**关键1：只考虑当前层做什么**
```
不要试图在脑海中展开整个递归过程！
只需要思考：
- 当前层要做什么？
- 子问题返回什么？
- 如何利用子问题的结果？
```

**关键2：相信递归会正确工作**
```
假设递归函数已经正确实现了功能
只需要思考如何利用它解决当前问题
```

**关键3：找准递归的语义**
```
递归函数必须有明确的功能定义
每次调用的语义必须一致
```

---

## 2. 递归函数设计五步法

### 第1步：明确函数语义

```
问自己：这个递归函数的作用是什么？

示例：
- fibonacci(n)：返回第n个斐波那契数
- treeDepth(root)：返回以root为根的树的深度
- dfs(node)：遍历以node为根的子树
```

**检查点**：
- ✅ 函数功能清晰明确
- ✅ 参数含义明确
- ✅ 返回值含义明确

---

### 第2步：找递归出口（Base Case）

```
问自己：什么时候不需要再递归？

常见递归出口：
1. 到达边界：root == nullptr, index >= n
2. 问题最小：n == 0, n == 1
3. 找到答案：count == k
4. 搜索结束：visited[x] == true
```

**原则**：
- ✅ 必须有递归出口（否则无限递归）
- ✅ 递归出口要覆盖所有边界情况
- ✅ 出口应该返回最简单、直接的结果

**示例**：
```cpp
// 二叉树递归出口
if (root == nullptr) return 0;

// 数组递归出口
if (index >= nums.size()) return;

// 数值递归出口
if (n <= 1) return n;
```

---

### 第3步：确定子问题

```
问自己：
1. 大问题如何拆解成小问题？
2. 小问题和大问题是否是"同类型"的？
3. 小问题的参数是什么？
```

**常见拆解方式**：

**方式1：一分为二**
```cpp
// 二叉树：分成左右子树
int leftDepth = treeDepth(root->left);
int rightDepth = treeDepth(root->right);
```

**方式2：减少规模**
```cpp
// 数值：n → n-1
int result = n + sum(n - 1);

// 数组：index → index+1
dfs(nums, index + 1);
```

**方式3：多路分支**
```cpp
// 回溯：尝试所有可能的选择
for (int i = 0; i < n; i++) {
    dfs(i);
}
```

---

### 第4步：设计递归体

```
问自己：如何利用子问题的结果？

根据问题类型选择：
1. 信息收集型：收集子问题的返回值
2. 结构修改型：修改树/图的结构
3. 路径搜索型：累积路径信息
```

**信息收集型示例**：
```cpp
// 收集左右子树信息
int leftDepth = maxDepth(root->left);
int rightDepth = maxDepth(root->right);
return max(leftDepth, rightDepth) + 1;
```

**结构修改型示例**：
```cpp
// 修改子树后返回新结构
root->left = pruneTree(root->left);
root->right = pruneTree(root->right);
return (满足删除条件) ? nullptr : root;
```

**路径搜索型示例**：
```cpp
// 累积路径信息
path.push_back(x);
dfs(next);
path.pop_back();  // 回溯
```

---

### 第5步：检查语义一致性

```
问自己：
1. 所有返回值的语义是否一致？
2. 参数传递是否正确？
3. 全局变量的修改是否正确？
```

**语义一致性检查**：
```cpp
// ❌ 错误：语义不一致
TreeNode* function(root) {
    if (root == nullptr) return nullptr;  // 返回空指针
    if (叶子节点) return root;             // 返回节点指针
    // ...
    return 0;  // ❌ 返回了整数！语义混乱
}

// ✅ 正确：语义一致
TreeNode* function(root) {
    if (root == nullptr) return nullptr;  // 都是指针
    if (叶子节点) return root;             // 都是指针
    // ...
    return root;  // 都是指针 ✅
}
```

---

## 3. 三大递归场景分类

### 3.1 二叉树递归（树形结构）

**特点**：
- 自然的递归结构（左子树 + 右子树）
- 通常需要收集子树信息

**核心模板**：
```cpp
ReturnType treeFunction(TreeNode* root) {
    // 1. 递归出口
    if (root == nullptr) return 初始值;
    
    // 2. 递归处理子树
    ReturnType left = treeFunction(root->left);
    ReturnType right = treeFunction(root->right);
    
    // 3. 利用子树结果
    return combine(left, right, root->val);
}
```

**三种遍历方式**：
```cpp
// 前序遍历（根→左→右）
void preorder(TreeNode* root) {
    if (root == nullptr) return;
    process(root);           // 处理当前节点
    preorder(root->left);    // 左子树
    preorder(root->right);   // 右子树
}

// 中序遍历（左→根→右）
void inorder(TreeNode* root) {
    if (root == nullptr) return;
    inorder(root->left);     // 左子树
    process(root);           // 处理当前节点
    inorder(root->right);    // 右子树
}

// 后序遍历（左→右→根）
void postorder(TreeNode* root) {
    if (root == nullptr) return;
    postorder(root->left);   // 左子树
    postorder(root->right);  // 右子树
    process(root);           // 处理当前节点
}
```

**遍历方式选择**：
```
前序遍历：
- 路径问题（需要先访问当前节点）
- 自顶向下传递信息
- 复制/克隆树

中序遍历：
- BST相关（天然有序）
- 需要按顺序访问节点

后序遍历：
- 树的结构修改（删除、剪枝）
- 需要先知道子树信息
- 自底向上传递信息
```

**常见问题类型**：
1. **求深度/高度** → 后序遍历，收集子树深度
2. **验证BST** → 中序遍历，检查是否递增
3. **路径和问题** → 前序遍历，累积路径
4. **树的修改** → 后序遍历，先处理子树

---

### 3.2 回溯递归（搜索空间）

**特点**：
- 需要遍历所有可能性
- 做选择 → 递归 → 撤销选择
- 关键是恢复现场

**核心模板**：
```cpp
void backtrack(状态参数) {
    // 1. 递归出口
    if (满足条件) {
        记录结果;
        return;  // ← 只记录，不恢复！
    }
    
    // 2. 回溯体
    for (遍历所有选择) {
        if (剪枝条件) continue;
        
        // 做选择
        修改状态;
        
        // 递归
        backtrack(下一层参数);
        
        // ✅ 撤销选择（恢复现场）← 必须在递归后！
        恢复状态;
    }
}
```

**关键点：恢复现场的时机**
```cpp
// ✅ 正确：在递归后恢复
for (...) {
    path.push_back(x);  // 做选择
    dfs(...);           // 递归
    path.pop_back();    // 撤销选择 ← 在这里！
}

// ❌ 错误：在出口恢复
if (满足条件) {
    记录结果;
    path.pop_back();  // ❌ 你不知道该恢复哪个！
}
```

**常见模式**：

**模式1：全排列型（关心顺序）**
```cpp
bool check[n];  // 标记是否已用

void dfs(nums) {
    if (path.size() == n) {
        ret.push_back(path);
        return;
    }
    
    for (int i = 0; i < n; i++) {  // 从0开始
        if (check[i]) continue;
        
        path.push_back(nums[i]);
        check[i] = true;
        dfs(nums);
        path.pop_back();
        check[i] = false;
    }
}
```

**模式2：子集/组合型（不关心顺序）**
```cpp
void dfs(nums, index) {  // 用index避免重复
    ret.push_back(path);  // 每个节点都记录
    
    for (int i = index; i < n; i++) {  // 从index开始
        path.push_back(nums[i]);
        dfs(nums, i + 1);  // 传i+1（只往后选）
        path.pop_back();
    }
}
```

**两种模式对比**：
| 特性 | 全排列 | 子集/组合 |
|------|--------|-----------|
| 关心顺序 | ✅ | ❌ |
| for起点 | `i=0` | `i=index` |
| 递归参数 | 不变 | `i+1` |
| check数组 | 需要 | 不需要 |
| 记录时机 | 叶子 | 所有节点 |

---

### 3.3 分治递归（问题拆解）

**特点**：
- 问题可以分解成独立的子问题
- 子问题解决后合并结果
- 通常有明确的返回值

**核心模板**：
```cpp
ReturnType divideConquer(问题范围) {
    // 1. 递归出口
    if (问题最小) {
        return 直接结果;
    }
    
    // 2. 分解问题
    ReturnType left = divideConquer(左半部分);
    ReturnType right = divideConquer(右半部分);
    
    // 3. 合并结果
    return merge(left, right);
}
```

**经典应用**：
```cpp
// 归并排序
void mergeSort(arr, left, right) {
    if (left >= right) return;
    
    int mid = (left + right) / 2;
    mergeSort(arr, left, mid);      // 排序左半部分
    mergeSort(arr, mid + 1, right); // 排序右半部分
    merge(arr, left, mid, right);   // 合并
}

// 快速排序
void quickSort(arr, left, right) {
    if (left >= right) return;
    
    int pivot = partition(arr, left, right);  // 分区
    quickSort(arr, left, pivot - 1);          // 排序左半部分
    quickSort(arr, pivot + 1, right);         // 排序右半部分
}
```

---

## 4. 递归检查清单

### 开始写代码前（设计阶段）

- [ ] **函数语义是否清晰？**
  - 函数的作用是什么？
  - 参数的含义是什么？
  - 返回值的含义是什么？

- [ ] **递归出口是否正确？**
  - 是否覆盖所有边界情况？
  - 是否会无限递归？
  - 出口返回值是否正确？

- [ ] **子问题是否比原问题小？**
  - 递归参数是否在缩小？
  - 是否会陷入死循环？

- [ ] **子问题类型是否一致？**
  - 子问题和原问题是否是同一类问题？
  - 递归调用的参数是否合理？

---

### 写完代码后（检查阶段）

- [ ] **返回值语义一致性**
  - 所有return的类型是否一致？
  - 所有return的语义是否相同？

- [ ] **参数传递正确性**
  - 传值 vs 引用是否正确？
  - index/指针是否正确更新？

- [ ] **全局变量处理**
  - 是否需要恢复现场？
  - 恢复现场的位置是否正确？

- [ ] **空指针检查**
  - 访问指针前是否判空？
  - nullptr的处理是否正确？

- [ ] **边界条件测试**
  - 空输入的处理？
  - 单元素的处理？
  - 最大输入的处理？

---

### 回溯专项检查

- [ ] **恢复现场位置正确？**
  - 是否在递归调用后恢复？
  - 做选择和撤销选择是否配对？

- [ ] **是否需要check数组？**
  - 全排列型 → 需要
  - 子集/组合型 → 不需要（用index）

- [ ] **记录结果的时机？**
  - 全排列 → 叶子节点
  - 子集 → 所有节点

- [ ] **剪枝是否完善？**
  - 是否有不必要的递归？
  - 能否提前返回？

---

## 5. 常见错误与避坑指南

### 错误1：递归出口缺失或不完整

```cpp
// ❌ 错误：缺少nullptr检查
int treeDepth(TreeNode* root) {
    return max(treeDepth(root->left), treeDepth(root->right)) + 1;
    // 如果root为空，会崩溃！
}

// ✅ 正确：先检查边界
int treeDepth(TreeNode* root) {
    if (root == nullptr) return 0;  // 递归出口
    return max(treeDepth(root->left), treeDepth(root->right)) + 1;
}
```

---

### 错误2：返回值语义不一致

```cpp
// ❌ 错误：语义混乱
TreeNode* pruneTree(TreeNode* root) {
    if (root == nullptr) return nullptr;
    if (root->left == nullptr && root->right == nullptr) 
        return root;  // ← 没判断是否该删除，提前返回
    
    // ... 后续代码无法执行到值为0的叶子节点
}

// ✅ 正确：统一判断
TreeNode* pruneTree(TreeNode* root) {
    if (root == nullptr) return nullptr;
    
    root->left = pruneTree(root->left);
    root->right = pruneTree(root->right);
    
    // 统一判断删除条件
    if (root->left == nullptr && root->right == nullptr && root->val == 0)
        return nullptr;
    return root;
}
```

---

### 错误3：回溯恢复现场位置错误

```cpp
// ❌ 错误：在出口恢复
void dfs() {
    if (path.size() == n) {
        ret.push_back(path);
        path.pop_back();  // ❌ 你不知道该恢复哪个！
        return;
    }
    // ...
}

// ✅ 正确：在递归后恢复
void dfs() {
    if (path.size() == n) {
        ret.push_back(path);
        return;  // 只记录，不恢复
    }
    
    for (...) {
        path.push_back(x);
        dfs();
        path.pop_back();  // ✅ 在递归后恢复
    }
}
```

---

### 错误4：全局变量忘记恢复

```cpp
// ❌ 错误：忘记恢复check数组
void dfs() {
    for (int i = 0; i < n; i++) {
        if (check[i]) continue;
        
        path.push_back(nums[i]);
        check[i] = true;
        dfs();
        path.pop_back();
        // ❌ 忘记 check[i] = false;
    }
}

// ✅ 正确：严格配对
void dfs() {
    for (int i = 0; i < n; i++) {
        if (check[i]) continue;
        
        path.push_back(nums[i]);
        check[i] = true;
        dfs();
        path.pop_back();
        check[i] = false;  // ✅ 恢复
    }
}
```

---

### 错误5：混淆全排列和子集

```cpp
// 全排列：需要check，从0开始
for (int i = 0; i < n; i++) {
    if (!check[i]) { ... }
}

// 子集：不需要check，从index开始
for (int i = index; i < n; i++) {
    dfs(nums, i + 1);
}

// ❌ 常见错误：子集用了check，或者从0开始
// 会导致重复子集
```

---

### 错误6：空指针访问

```cpp
// ❌ 错误：直接访问可能为空的指针
if (root->left->val == 0) { ... }

// ✅ 正确：先判空
if (root->left != nullptr && root->left->val == 0) { ... }

// ✅ 更好：先判空，再访问
if (root->left == nullptr) return;
if (root->left->val == 0) { ... }
```

---

## 6. 递归优化技巧

### 6.1 剪枝优化

```cpp
// 提前返回，避免不必要的递归
void dfs() {
    if (已找到答案) return;  // 剪枝
    if (当前路径不可能) return;  // 剪枝
    
    // 正常递归
}
```

### 6.2 记忆化搜索

```cpp
// 避免重复计算
unordered_map<int, int> memo;

int fib(int n) {
    if (n <= 1) return n;
    if (memo.count(n)) return memo[n];  // 已计算过
    
    memo[n] = fib(n-1) + fib(n-2);
    return memo[n];
}
```

### 6.3 尾递归优化

```cpp
// 普通递归
int sum(int n) {
    if (n == 0) return 0;
    return n + sum(n - 1);  // 递归后还有操作
}

// 尾递归（最后一步是递归调用）
int sumTail(int n, int acc = 0) {
    if (n == 0) return acc;
    return sumTail(n - 1, acc + n);  // 最后一步就是递归
}
```

---

## 7. 实战应用流程

### 拿到新题后的思考流程

**第1步：识别问题类型**
```
- 树形结构？ → 二叉树递归
- 搜索所有可能？ → 回溯递归
- 可分解合并？ → 分治递归
```

**第2步：套用对应模板**
```
根据问题类型，选择对应的递归模板
```

**第3步：明确递归语义**
```
这个函数的作用是什么？
参数和返回值的含义？
```

**第4步：找递归出口**
```
什么时候停止递归？
边界条件是什么？
```

**第5步：设计递归体**
```
如何拆解子问题？
如何利用子问题结果？
```

**第6步：检查清单验证**
```
用检查清单逐项检查
画决策树验证逻辑
```

---

## 8. 总结

### 核心原则

1. **明确语义**：递归函数的功能必须清晰明确
2. **信任递归**：相信递归会正确工作，不要展开整个过程
3. **语义一致**：所有返回值的语义必须一致
4. **配对原则**：做选择和撤销选择必须配对
5. **只看当前**：只考虑当前层做什么，不要深入子层

### 记忆口诀

```
递归四问：
1. 这个函数干什么？（语义）
2. 什么时候停？（出口）
3. 如何变小？（子问题）
4. 如何利用？（递归体）

回溯三步：
1. 做选择
2. 递归
3. 撤销选择（必须在递归后！）
```

---

## 9. 练习建议

### 阶段1：基础递归（5-10题）
- 斐波那契数列
- 阶乘
- 二叉树深度
- 二叉树遍历
- 链表反转

### 阶段2：树形递归（10-15题）
- 二叉树的所有路径
- 验证二叉搜索树
- 对称二叉树
- 翻转二叉树
- 二叉树剪枝

### 阶段3：回溯递归（10-15题）
- 全排列
- 子集
- 组合
- 组合总和
- N皇后

### 阶段4：综合应用（开放）
- 复杂的树形DP
- 图的DFS
- 分治算法
- 动态规划（递归思维）

---

**版本：v1.0**  
**最后更新：2025-10-25**  
**基于题目**：Day24-25的8道题目总结

> 💡 **提示**：这份方法论会随着做题不断完善和更新！

