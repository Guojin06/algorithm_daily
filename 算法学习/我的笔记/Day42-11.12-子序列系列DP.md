# Day42｜11.12｜子序列系列 DP

## 今日目标
- 切换到子序列类 DP，理解「允许跳过元素」带来的状态设计差异。
- 以 `LIS` 为起点，梳理 O(n²) 转移的边界、转移条件与答案获取方式。

## LeetCode 300. Longest Increasing Subsequence

### 题目小结
- 给定整数数组 `nums`，求严格递增子序列的最大长度。
- 子序列允许跳过元素，不要求连续。

### From 0 to 1 思考路径
1. **暴力直觉**：尝试所有子序列组合，指数级不可行。
2. **改写视角**：如果以某个位置 `i` 结尾，最长递增子序列是多少？只需关注 `i` 之前比 `nums[i]` 小的元素。
3. **状态设计**：`dp[i]` 表示「以 `nums[i]` 结尾的最长递增子序列长度」。
4. **转移推导**：对于每个 `j < i`，如果 `nums[j] < nums[i]`，可以把 `nums[i]` 接到 `j` 结尾的序列后，因此 `dp[i] = max(dp[i], dp[j] + 1)`。
5. **初始化与答案**：
   - 默认单个元素也构成长度为 1 的递增子序列：`dp[i] = 1`。
   - 全局答案是 `max(dp[i])`。
6. **复杂度评估**：双重循环，时间 O(n²)，空间 O(n)。

### 代码实现（O(n²) DP）

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1);
        int ret = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            ret = max(ret, dp[i]);
        }
        return ret;
    }
};
```

### 复盘 & 要点
- **状态含义**：必须强调「以 i 结尾」保证子序列的末尾固定，这样才能在 O(n²) 内完成转移。
- **子序列 vs. 子数组**：子序列允许跳过元素，因此外层 `i`、内层 `j` 的比较要遍历所有历史位置。
- **优化启发**：该题还有 O(n log n) 的贪心 + 二分做法，后续可作为子序列专题的进阶内容。

---

明日继续拓展子序列系列（比如带权、带条件、需要计数等模型），完成后再统一更新方法论文件。

---

## LeetCode 376. Wiggle Subsequence

### 题目小结
- 目标：找到最长的「摆动」子序列，元素差值符号交替（正、负、正…或负、正、负…）。
- 子序列依旧允许跳过元素，只要保证相邻元素的差值符号交替即可。

### From 0 to 1 思考路径
1. **定义摆动**：两项差值符号必须交替，因此需要同时追踪「当前结尾向上摆动」和「向下摆动」两种状态。
2. **状态设计**：
   - `f[i]`：以 `nums[i]` 结尾且最后一步是「上升」的最长摆动长度。
   - `g[i]`：以 `nums[i]` 结尾且最后一步是「下降」的最长摆动长度。
3. **状态转移**：
   - 遍历所有 `j < i`：
     - 如果 `nums[j] < nums[i]`，可以把 `nums[i]` 接在一个下降结尾的序列之后，`f[i] = max(f[i], g[j] + 1)`。
     - 如果 `nums[j] > nums[i]`，可以把 `nums[i]` 接在一个上升结尾的序列之后，`g[i] = max(g[i], f[j] + 1)`。
4. **初始化**：
   - 单个元素视为长度 1 的摆动序列，`f[i] = g[i] = 1`。
5. **答案**：遍历所有 `i` 的 `max(f[i], g[i])`。
6. **复杂度**：当前 DP 实现为 O(n²)，空间 O(n)。

### 代码实现（O(n²) DP）

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n, 1), g(n, 1);
        int ret = 1;
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    f[i] = max(f[i], g[j] + 1);
                } else if (nums[j] > nums[i]) {
                    g[i] = max(g[i], f[j] + 1);
                }
            }
            ret = max(ret, max(f[i], g[i]));
        }
        return ret;
    }
};
```

### 关于 O(n) 优化（`up` / `down` 两个变量）
- 关键 observation：转移时只依赖「上一个不相等的元素」，不需要枚举所有 `j`。
- 顺序扫描数组，比较相邻元素差值的符号：
  - 若 `nums[i] > nums[i - 1]`，`up = down + 1`，因为只有当上一段是下降时，当前位置才能形成上升摆动。
  - 若 `nums[i] < nums[i - 1]`，`down = up + 1`。
  - 若相等，不更新任何状态。
- 由于更新总是用到上一轮的 `up`、`down` 值（即 `i-1` 的结果），不会出现覆盖问题；这等价于在 O(1) 空间里维护 `f[i-1]` 和 `g[i-1]`。
- 当前题解记录的是 O(n²) DP 过程；理解后即可平滑过渡到线性解法。

---

## LeetCode 673. Number of Longest Increasing Subsequence

### 题目小结
- 在 `LIS` 的基础上，除了最长长度，还需要统计最长递增子序列的条数。
- 返回“最长长度对应的方案数”。

### From 0 to 1 思考路径
1. **沿用 LIS 的视角**：仍然枚举每个位置 `i`，关注 `i` 之前比它小的元素。
2. **状态扩展**：
   - `dp[i]`：以 `nums[i]` 结尾的最长递增子序列长度。
   - `cnt[i]`：以 `nums[i]` 结尾、长度等于 `dp[i]` 的 LIS 方案数。
3. **转移逻辑**：
   - 遍历 `j < i` 且 `nums[j] < nums[i]`。
   - 如果 `dp[j] + 1 > dp[i]`，说明找到更长的路径，刷新 `dp[i]`，并让 `cnt[i] = cnt[j]`。
   - 如果 `dp[j] + 1 == dp[i]`，说明又找到同长度的路径，把 `cnt[j]` 累加到 `cnt[i]`。
4. **初始化**：单个元素自身构成长度 1 的递增子序列，故 `dp[i] = cnt[i] = 1`。
5. **答案更新“贪心”**：
   - 扫描一遍 `dp`、`cnt`，同步维护当前最大长度 `best` 和对应方案总数 `ans`。
   - 如果某个 `dp[i] > best`，就用 `cnt[i]` 覆盖；若 `dp[i] == best`，把 `cnt[i]` 累加。
6. **复杂度**：时间 O(n²)，空间 O(n)。

### 代码实现

```cpp
class Solution {
public:
    int findNumberOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;

        vector<int> dp(n, 1);   // dp[i]：以 nums[i] 结尾的 LIS 长度（至少是自己，故为 1）
        vector<int> cnt(n, 1);  // cnt[i]：以 nums[i] 结尾，长度为 dp[i] 的方案数（至少有自己这一条）

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) { // 只有递增时才有转移
                    if (dp[j] + 1 > dp[i]) {
                        dp[i] = dp[j] + 1;   // 找到更长的 LIS，刷新长度
                        cnt[i] = cnt[j];     // 方案数直接继承 j 的所有路径
                    } else if (dp[j] + 1 == dp[i]) {
                        cnt[i] += cnt[j];    // 同长度的路径，再叠加方案数
                    }
                }
            }
        }

        int best = *max_element(dp.begin(), dp.end()); // 全局最长长度
        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (dp[i] == best) ans += cnt[i];          // 找到最长长度的结尾，累计方案数
        }
        return ans;
    }
};
```

### 复盘 & 要点
- `dp[i]` 定义长度，`cnt[i]` 紧跟长度维护方案数；刷新长度时记得同步覆盖方案数。
- 遇到更长路径要重置 `cnt[i] = cnt[j]`，遇到同长路径再累加。
- 最后先求出最长长度，再把所有 `dp[i] == best` 的 `cnt[i]` 累起来即可。


