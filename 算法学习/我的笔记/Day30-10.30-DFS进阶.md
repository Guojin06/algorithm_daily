# Day30 - 10.30 DFS进阶专题

**日期**：2025年10月30日  
**主题**：DFS进阶 - 剑指Offer经典题  
**学习目标**：巩固FloodFill，拓展DFS应用场景

---

## 📋 今日计划

### 核心题目
1. ⭐⭐ 剑指Offer 13 - 机器人的运动范围（Medium）
2. 其他DFS进阶题目（待补充）

---

## 1. 剑指Offer 13 - 机器人的运动范围

### 📌 题目信息
- **难度**：Medium
- **标签**：DFS、BFS、FloodFill、数位和
- **链接**：[剑指 Offer 13](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

---

### 📋 题目描述

地上有一个 `m` 行 `n` 列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]`。

一个机器人从坐标 `[0, 0]` 的格子开始移动，它每次可以向**左、右、上、下**移动一格（不能移动到方格外），也不能进入**行坐标和列坐标的数位之和大于k**的格子。

例如：当 `k` 为 `18` 时：
- 机器人能够进入方格 `[35, 37]`，因为 `3+5+3+7=18`
- 但不能进入方格 `[35, 38]`，因为 `3+5+3+8=19`

请问该机器人能够到达多少个格子？

---

**示例 1**：
```
输入：m = 2, n = 3, k = 1
输出：3
解释：从[0,0]开始，可以到达[0,0]、[0,1]、[1,0]
```

**示例 2**：
```
输入：m = 3, n = 1, k = 0
输出：1
```

**示例 3**：
```
输入：m = 16, n = 8, k = 4
输出：15
```

---

### 🤔 解题思路

#### **问题分析**

**关键信息**：
1. 从 `[0,0]` 开始移动（固定起点）
2. 每次可以向**4个方向**移动
3. 限制条件：**数位和 ≤ k**
4. 求：能到达的格子数量

**数位和计算**：
```
[35, 37]：
- 行坐标35的数位和：3 + 5 = 8
- 列坐标37的数位和：3 + 7 = 10
- 总和：8 + 10 = 18

[35, 38]：
- 行坐标35的数位和：3 + 5 = 8
- 列坐标38的数位和：3 + 8 = 11
- 总和：8 + 11 = 19 > 18 ❌
```

---

#### **核心思路**

**这道题 = FloodFill的变种！** ⭐

```
类比LeetCode 733（图像渲染）：
- 起点：[sr, sc] → [0, 0]
- 扩展条件：颜色相同 → 数位和≤k
- 目标：填充颜色 → 计数格子数
```

**算法步骤**：
```
1. 从[0,0]开始DFS
2. 标记已访问的格子
3. 向4个方向扩展（上下左右）
4. 扩展条件：
   - 不越界
   - 未访问
   - 数位和≤k
5. 累计可到达的格子数
```

---

#### **辅助函数：计算数位和**

**方法1：循环取余**
```cpp
int digitSum(int num) {
    int sum = 0;
    while(num > 0) {
        sum += num % 10;  // 取个位
        num /= 10;        // 去掉个位
    }
    return sum;
}

// 例：35 → 3+5 = 8
// 第1次：sum = 5, num = 3
// 第2次：sum = 8, num = 0
```

**方法2：递归（简洁）**
```cpp
int digitSum(int num) {
    if(num == 0) return 0;
    return num % 10 + digitSum(num / 10);
}
```

**方法3：直接计算（最快）**
```cpp
int digitSum(int num) {
    return num % 10 + num / 10 % 10 + num / 100;
}
// 适用于num < 1000的情况
```

---

### 💻 代码实现

```cpp
class Solution {
public:
    int ret = 0;
    bool vis[101][101];
    int dx[4] = {-1, 1, 0, 0};
    int dy[4] = {0, 0, -1, 1};
    
    int wardrobeFinishing(int m, int n, int cnt) {
        memset(vis, false, sizeof(vis));
        
        // ❌ 错误思路（已注释）：
        // for(int i = 0; i < m; i++) {
        //     for(int j = 0; j < n; j++) {
        //         if(vis[i][j] == false)
        //             dfs(i, j, cnt, m, n);
        //     }
        // }
        // 这样会统计所有满足条件的块，但题目只要求从[0,0]开始的连通区域！
        
        // ✅ 正确：只从[0,0]开始
        dfs(0, 0, cnt, m, n);
        return ret;
    }
    
    void dfs(int i, int j, int cnt, int m, int n) {
        // 出口1：越界
        if(i < 0 || i >= m || j < 0 || j >= n) return;
        // 出口2：已访问
        if(vis[i][j]) return;
        // 出口3：数位和大于k
        if((digitSum(i) + digitSum(j)) > cnt) return;

        // 标记，计数
        vis[i][j] = true;
        ret++;  // 格子数+1

        // 向四个方向扩展
        for(int k = 0; k < 4; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            if(x >= 0 && x < m && y >= 0 && y < n && 
               (digitSum(x) + digitSum(y)) <= cnt) {
                dfs(x, y, cnt, m, n);
            }
        }
    }
    
    // 计算数位和
    int digitSum(int num) {
        int sum = 0;
        while(num > 0) {
            sum += num % 10;
            num /= 10;
        }
        return sum;
    }
};
```

**时间复杂度**：O(m×n)  
**空间复杂度**：O(m×n) - vis数组 + 递归栈

---

### 提交结果
- 提交时间：一次AC ✅
- 执行用时：符合预期
- 内存消耗：O(m×n)

---

### 💡 核心考点总结

#### **1. 题意理解的关键** ⭐⭐⭐

**错误理解**（注释掉的代码）：
```cpp
// 遍历所有格子作为起点，统计所有满足条件的格子
for(int i = 0; i < m; i++) {
    for(int j = 0; j < n; j++) {
        if(vis[i][j] == false)
            dfs(i, j, cnt, m, n);
    }
}
```
❌ 这样会统计**所有**满足数位和条件的格子！

**正确理解**：
```cpp
// 只从[0,0]开始，统计能到达的格子
dfs(0, 0, cnt, m, n);
```
✅ 只统计从 `[0,0]` 出发能**连通到达**的格子！

**区别示例**：
```
假设 m=3, n=3, k=1
数位和≤1的格子：[0,0], [0,1], [1,0], [1,1]

错误做法：统计所有4个格子
正确做法：从[0,0]开始DFS，这4个格子都能到达，也是4个

但如果有障碍物，错误做法会多统计不连通的区域！
```

**核心**：
- 不是"统计所有满足条件的格子"
- 而是"从起点出发能到达的格子"
- 这就是**FloodFill的本质** ✨

---

#### **2. dx/dy数组的应用** ⭐

```cpp
int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};

for(int k = 0; k < 4; k++) {
    int x = i + dx[k];
    int y = j + dy[k];
    if(边界检查 && 条件检查) {
        dfs(x, y, cnt, m, n);
    }
}
```

**优点**：
- 代码简洁
- 不易出错
- Day29学到的技巧成功应用 ✨

---

#### **3. FloodFill标准模板**

```cpp
void dfs(int i, int j) {
    // 三个出口
    if(越界) return;
    if(已访问) return;
    if(不满足条件) return;  // ⭐ 本题：数位和>k
    
    // 标记
    vis[i][j] = true;
    ret++;  // 计数
    
    // 向4个方向扩展
    for(4个方向) {
        dfs(x, y);
    }
}
```

**与Day29对比**：

| 题目 | 扩展条件 | 起点 |
|------|---------|------|
| LeetCode 733 | 颜色相同 | 给定 |
| LeetCode 200 | 是陆地 | 遍历 |
| LeetCode 695 | 是陆地 | 遍历 |
| 剑指13 | 数位和≤k | **固定[0,0]** ⭐ |

---

### 易错点记录

#### **易错点1：题意理解错误** ⭐⭐⭐

```cpp
// ❌ 错误：遍历所有格子
for(int i = 0; i < m; i++) {
    for(int j = 0; j < n; j++) {
        dfs(i, j, cnt, m, n);
    }
}

// ✅ 正确：只从[0,0]开始
dfs(0, 0, cnt, m, n);
```

**教训**：
- 仔细读题！题目说"从 `[0,0]` 开始移动"
- FloodFill是求**连通区域**，不是所有满足条件的格子
- 这个错误如果不注意，可能得不到正确答案

---

#### **易错点2：for循环中的重复检查**

```cpp
// 当前代码：
for(int k = 0; k < 4; k++) {
    int x = i + dx[k];
    int y = j + dy[k];
    if(x >= 0 && x < m && y >= 0 && y < n &&  // 边界检查
       (digitSum(x) + digitSum(y)) <= cnt) {  // 条件检查
        dfs(x, y, cnt, m, n);
    }
}
```

**优化思路**：
- `dfs`函数里已经有越界检查了
- `dfs`函数里已经有数位和检查了
- 所以for循环里的检查是**重复的**

**可以简化为**：
```cpp
for(int k = 0; k < 4; k++) {
    int x = i + dx[k];
    int y = j + dy[k];
    dfs(x, y, cnt, m, n);  // 直接调用，让dfs自己判断
}
```

**但是**：
- 当前写法也没错！✅
- 提前检查可以**减少函数调用次数**（小优化）
- 两种写法都可以，看个人习惯

---

#### **易错点3：数位和计算**

```cpp
// ✅ 正确实现
int digitSum(int num) {
    int sum = 0;
    while(num > 0) {
        sum += num % 10;  // 取个位
        num /= 10;        // 去掉个位
    }
    return sum;
}
```

**注意**：
- 35 = 3 + 5 = 8
- 100 = 1 + 0 + 0 = 1
- 数位和是**各位数字相加**，不是各位数值

---

## 今日总结

### 完成情况
- [x] 剑指Offer 13 - 机器人的运动范围 ✅ 一次AC

### 核心知识点

#### **1. FloodFill的应用扩展**

```
FloodFill核心：从起点开始，满足条件就扩展

变种形式：
1. 图像渲染（733）：颜色相同
2. 岛屿问题（200/695）：是陆地
3. 被围绕区域（130）：是'O'
4. 机器人运动（剑指13）：数位和≤k ⭐
```

---

#### **2. 数位和计算**

**循环取余法**：
```cpp
int digitSum(int num) {
    int sum = 0;
    while(num > 0) {
        sum += num % 10;
        num /= 10;
    }
    return sum;
}
```

**应用场景**：
- 数字的各位相加
- 数字的各位操作
- 数学规律题

---

### 收获与反思

#### **今日核心收获** 🎯

**1. FloodFill题意理解的深化** ⭐⭐⭐
```
关键区别：
- "所有满足条件的格子" ❌
- "从起点能到达的格子" ✅

FloodFill = 连通区域问题
```

**2. 起点选择的三种形式**
```
形式1：固定起点（本题）
- 只从[0,0]开始
- 一次dfs调用

形式2：遍历起点（岛屿数量）
- 遍历所有格子作为起点
- 多次dfs调用，每次统计一个连通块

形式3：边界起点（被围绕区域）
- 从边界开始
- 反向思维
```

**3. dx/dy数组技巧的应用**
- Day29学到的技巧
- 成功应用到Day30
- 代码简洁，不易出错 ✨

---

#### **知识体系更新**

**FloodFill应用场景**：
```
Day29：
- 图像渲染、岛屿数量、岛屿面积
- 被围绕区域、太平洋大西洋
- 扫雷游戏（8方向）

Day30：
- 机器人运动范围（数位和限制）⭐
```

---

#### **成长亮点** ✨

1. ✅ **一次AC** - 代码逻辑清晰，思路正确
2. ✅ **自我纠错** - 注释掉的代码说明你意识到了起点选择的问题
3. ✅ **技巧迁移** - 成功应用Day29的dx/dy数组
4. ✅ **代码规范** - 变量命名清晰，注释到位

**特别值得表扬的**：
- 你注释掉的代码展示了你的**思考过程** ⭐⭐⭐
- 说明你理解了"从[0,0]开始"和"遍历所有格子"的区别
- 这种自我纠错能力非常重要！💪

---

#### **下一步计划**

**DFS进阶方向**：
- [ ] 更多剑指Offer的DFS题
- [ ] 矩阵中的路径
- [ ] 其他经典DFS题目

---

---

**Day30学习完成时间**：  
**今日总用时**：  
**累计学习天数**：30天 🎉

---

