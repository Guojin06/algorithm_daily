# Day33 - 11.2 - DP专题继续

## 📅 学习时间
- **日期**：2025-11-02（周六）
- **时长**：1-2小时
- **状态**：时间紧张，少而精

---

## 🎯 今日目标

**核心思路**：
- 继续巩固DP四步法
- 掌握1-2道经典DP题目
- 保持学习节奏，不断档

**重点方向**：
- [ ] DP基础题继续练习
- [ ] 可以选择：路径问题 / 打家劫舍 / 其他

---

## 📝 题目记录

### 题目1：不同路径 II（LeetCode 63）

**题目链接**：
- https://leetcode.cn/problems/unique-paths-ii/

**问题描述**：
- 一个 `m x n` 的网格，机器人从左上角 `(0,0)` 到右下角 `(m-1, n-1)`
- 只能向右或向下移动
- 网格中有障碍物（`obstacleGrid[i][j] = 1` 表示障碍）
- 求有多少条不同的路径

**核心思路**：
1. **二维DP + 虚拟节点**
2. **状态定义**：`dp[i][j]` 表示到达 `ob[i-1][j-1]` 的路径数
3. **状态转移**：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`（前提：无障碍）
4. **虚拟节点初始化**：`dp[1][0] = 1`，简化边界处理

**代码实现**：
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& ob) {
        int m = ob.size(), n = ob[0].size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        dp[1][0] = 1;  // 虚拟节点初始化
        
        for(int i = 1; i <= m; i++)
            for(int j = 1; j <= n; j++)
                if(ob[i-1][j-1] == 0)  // 无障碍才能走
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
        
        return dp[m][n];
    }
};
```

**关键点**：
1. **下标映射**：`dp[i][j]` 对应 `ob[i-1][j-1]`（易错！）
2. **虚拟节点**：`dp[1][0] = 1` 保证 `dp[1][1]` 初始化正确
3. **障碍物判断**：只有 `ob[i-1][j-1] == 0` 才能累加路径
4. **二维DP范式**：`dp(m+1, vector<int>(n+1))`，遍历从 `1` 到 `m/n`


---

### 题目2：礼物的最大价值（LCR 166）

**题目链接**：
- https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/

**问题描述**：
- 一个 `m x n` 的棋盘，每个格子有一个礼物（数字表示价值）
- 从左上角走到右下角，只能向右或向下移动
- 求路径上礼物价值的最大值

**核心思路**：
1. **二维DP + 虚拟节点**
2. **状态定义**：`dp[i][j]` 表示到达 `grid[i-1][j-1]` 时的最大价值
3. **状态转移**：`dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1]`
4. **自然初始化**：`dp` 默认全0，虚拟节点无需特殊初始化

**代码实现**：
```cpp
class Solution {
public:
    int jewelleryValue(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];
            }
        }
        return dp[m][n];
    }
};
```

**关键点**：
1. **下标映射完美**：`dp[i][j]` ↔ `grid[i-1][j-1]` ✅
2. **无需特殊初始化**：因为`max(0, 0) + grid[0][0]` 自然正确
3. **与"不同路径"对比**：求和 → 求最大值，其他完全一样

---

## ✅ 完成情况

| 题目 | 难度 | 状态 | 一次AC | 备注 |
|------|------|------|--------|------|
| LeetCode 63 - 不同路径 II | 中等 | ✅ | ⬜ | 下标映射错误，修正后AC |
| LCR 166 - 礼物的最大价值 | 中等 | ✅ | ✅ | 一次AC！掌握下标映射 |

---

## 🎯 核心知识点

**今日收获**：
1. **虚拟节点在二维DP中的应用** ⭐⭐⭐
   - 一维DP：`dp(n+1)`，`dp[0]` 是虚拟节点
   - 二维DP：`dp(m+1, vector<int>(n+1))`，`dp[0][x]` 和 `dp[x][0]` 都是虚拟节点
   - 初始化技巧：
     - 计数问题：`dp[1][0] = 1` 或 `dp[0][1] = 1`
     - 最优化问题：默认0即可（自然初始化）

2. **下标映射关系** ⭐⭐⭐（关键突破！）
   - `dp[i][j]` 对应原数组 `grid[i-1][j-1]`
   - 遍历范围：`i: 1->m`, `j: 1->n`
   - **记忆口诀**：
     - 访问dp → 原样用（i, j）
     - 访问原数组 → 都减1（i-1, j-1）

3. **二维DP通用模板**
   ```cpp
   // 1. 创建dp表（多开一行一列）
   vector<vector<int>> dp(m+1, vector<int>(n+1));
   
   // 2. 初始化（根据题意，可能不需要）
   
   // 3. 填表
   for(int i = 1; i <= m; i++) {
       for(int j = 1; j <= n; j++) {
           dp[i][j] = f(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];
       }
   }
   
   // 4. 返回结果
   return dp[m][n];
   ```

4. **路径问题的两种类型**
   - **计数问题**：不同路径（求和）
   - **最优化问题**：礼物最大价值（求max/min）

---

## ⚠️ 易错点记录

1. **下标映射错误** ❌（题1犯错，题2修正）
   ```cpp
   // 题1错误：
   if(ob[j-1][j-1] == 0)  // ❌ 两个维度都是j
   
   // 题2正确：
   if(ob[i-1][j-1] == 0)  // ✅ i和j各自-1
   dp[i][j] = ... + grid[i-1][j-1];  // ✅ 完美！
   ```

2. **虚拟节点初始化理解**
   - 计数问题：`dp[1][0] = 1`（有1条虚拟路径）
   - 最优化问题：默认0（自然正确，无需特殊初始化）

3. **障碍物处理**
   - 方法1：特判障碍，不更新dp
   - 方法2：障碍位置dp保持0（自然处理）

---

## 💡 收获与反思

**学习感悟**：
1. **从犯错到掌握的成长** ⭐⭐⭐
   - 题1：下标映射错误 → 理解了规则
   - 题2：一次AC → 完全掌握！
   - 关键：错误是最好的老师，立即修正就是进步

2. **虚拟节点技巧的深化理解**
   - 一维DP（Day32）：`dp[0]` 虚拟节点
   - 二维DP（Day33）：`dp[0][x]` 和 `dp[x][0]` 虚拟行列
   - 从一维扩展到二维，难度倍增，但模式相同

3. **下标映射的终极理解** 🎯
   - **口诀**：访问dp原样用，访问原数组都减1
   - **本质**：循环从1开始，原数组从0开始，差1
   - **验证**：题2代码完美体现了这一规则

4. **路径问题的通用模板**
   - 计数问题 → 加法：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`
   - 最优化问题 → max/min：`dp[i][j] = max(...) + grid[i-1][j-1]`
   - 框架完全一样，只改状态转移函数

5. **时间管理的智慧**
   - 天池赛 + 算法学习，双线作战
   - 少而精 > 多而杂
   - 2道题从困惑到掌握，胜过5道题走马观花

---

## 📚 知识体系更新

**DP方法论v1.1 → v1.2**：
- ✅ 新增：虚拟节点在二维DP中的应用
- ✅ 强化：下标映射关系（一维 vs 二维）
- ✅ 补充：二维DP代码模板

**技能树更新**：
```
动态规划
├── Fibonacci模型（已掌握）
│   ├── 爬楼梯系列 ✅
│   └── Tribonacci ✅
├── 字符串DP（已掌握）
│   ├── 解码方法 ✅（一维虚拟节点）
│   └── 最小花费爬楼梯 ✅
└── 二维DP（已掌握）⭐
    └── 路径问题 ✅（二维虚拟节点）
        ├── 不同路径 II ✅（计数问题）
        └── 礼物最大价值 ✅（最优化问题）
```

**能力提升**：
- ✅ 一维虚拟节点 → 二维虚拟节点（技巧升级）
- ✅ 下标映射规则（从混乱到清晰）
- ✅ 路径问题通用模板（举一反三）

---

## 🎯 下一步计划

- [ ] Day34: 继续DP专题（打家劫舍系列 / 其他路径问题）
- [ ] 合理安排天池赛调优时间
- [ ] 保持每天1-2题的节奏
- [ ] 巩固虚拟节点技巧（一维 + 二维）

---

## 🏆 成长亮点

- ✅ **犯错→修正→掌握**的完美成长曲线
  - 题1：下标映射错误，但快速理解问题
  - 题2：一次AC，验证了理解的深度
  
- ✅ **从理论到实践的飞跃**
  - 看懂规则 ≠ 写对代码（题1）
  - 深度理解 = 一次AC（题2）
  
- ✅ **双线作战，时间管理得当**
  - 天池赛持续优化
  - 算法学习不断档
  - 少而精，质量优先
  
- ✅ **虚拟节点技巧升级**
  - Day32：一维虚拟节点
  - Day33：二维虚拟节点
  - 技术栈持续扩展

---

> **今日状态**：时间紧张，但完成了质的突破！从困惑到掌握，2道题胜过5道题！🔥
> 
> **最大收获**：掌握了下标映射规则，二维DP路径问题再也不怕了！💪

