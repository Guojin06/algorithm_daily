# Day33 - 11.2 - DP专题继续

## 📅 学习时间
- **日期**：2025-11-02（周六）
- **时长**：1-2小时
- **状态**：时间紧张，少而精

---

## 🎯 今日目标

**核心思路**：
- 继续巩固DP四步法
- 掌握1-2道经典DP题目
- 保持学习节奏，不断档

**重点方向**：
- [ ] DP基础题继续练习
- [ ] 可以选择：路径问题 / 打家劫舍 / 其他

---

## 📝 题目记录

### 题目1：不同路径 II（LeetCode 63）

**题目链接**：
- https://leetcode.cn/problems/unique-paths-ii/

**问题描述**：
- 一个 `m x n` 的网格，机器人从左上角 `(0,0)` 到右下角 `(m-1, n-1)`
- 只能向右或向下移动
- 网格中有障碍物（`obstacleGrid[i][j] = 1` 表示障碍）
- 求有多少条不同的路径

**核心思路**：
1. **二维DP + 虚拟节点**
2. **状态定义**：`dp[i][j]` 表示到达 `ob[i-1][j-1]` 的路径数
3. **状态转移**：`dp[i][j] = dp[i-1][j] + dp[i][j-1]`（前提：无障碍）
4. **虚拟节点初始化**：`dp[1][0] = 1`，简化边界处理

**代码实现**：
```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& ob) {
        int m = ob.size(), n = ob[0].size();
        vector<vector<int>> dp(m+1, vector<int>(n+1));
        dp[1][0] = 1;  // 虚拟节点初始化
        
        for(int i = 1; i <= m; i++)
            for(int j = 1; j <= n; j++)
                if(ob[i-1][j-1] == 0)  // 无障碍才能走
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
        
        return dp[m][n];
    }
};
```

**关键点**：
1. **下标映射**：`dp[i][j]` 对应 `ob[i-1][j-1]`（易错！）
2. **虚拟节点**：`dp[1][0] = 1` 保证 `dp[1][1]` 初始化正确
3. **障碍物判断**：只有 `ob[i-1][j-1] == 0` 才能累加路径
4. **二维DP范式**：`dp(m+1, vector<int>(n+1))`，遍历从 `1` 到 `m/n`


---

### 题目2：[待补充]（如果有时间）

**题目链接**：
- 

**问题描述**：


**核心思路**：


**代码实现**：
```cpp
// 待补充
```

**关键点**：


---

## ✅ 完成情况

| 题目 | 难度 | 状态 | 一次AC | 备注 |
|------|------|------|--------|------|
| LeetCode 63 - 不同路径 II | 中等 | ✅ | ⬜ | 下标映射错误 |

---

## 🎯 核心知识点

**今日收获**：
1. **虚拟节点在二维DP中的应用** ⭐⭐⭐
   - 一维DP：`dp(n+1)`，`dp[0]` 是虚拟节点
   - 二维DP：`dp(m+1, vector<int>(n+1))`，`dp[0][x]` 和 `dp[x][0]` 都是虚拟节点
   - 初始化：`dp[1][0] = 1` 或 `dp[0][1] = 1`（根据题意）

2. **下标映射关系** ⭐⭐⭐
   - `dp[i][j]` 对应原数组 `arr[i-1][j-1]`
   - 遍历范围：`i: 1->m`, `j: 1->n`
   - 访问原数组：`arr[i-1][j-1]`（不是 `arr[j-1][j-1]`！）

3. **二维DP填表顺序**
   - 从左到右，从上到下
   - 当前状态依赖：左边 `dp[i][j-1]` 和上边 `dp[i-1][j]`

---

## ⚠️ 易错点记录

1. **下标映射错误** ❌
   ```cpp
   if(ob[j-1][j-1] == 0)  // ❌ 错误！两个维度都是j
   if(ob[i-1][j-1] == 0)  // ✅ 正确！
   ```

2. **虚拟节点初始化理解**
   - `dp[1][0] = 1` 的含义：从虚拟起点到 `dp[1][1]` 有1条路径
   - 不是初始化 `dp[1][1] = 1`！

3. **障碍物边界条件**
   - 如果起点或终点是障碍，直接返回 `0`
   - 可以在循环中自然处理（障碍位置 `dp` 值保持0）

---

## 💡 收获与反思

**学习感悟**：
1. **虚拟节点的强大** ⭐
   - 一维DP（解码方法）：`dp[0] = 1`
   - 二维DP（不同路径）：`dp[1][0] = 1`
   - 核心作用：避免边界特判，统一状态转移

2. **下标映射的陷阱**
   - 二维数组下标映射比一维更容易错
   - 关键：`dp[i][j]` ↔ `arr[i-1][j-1]`，牢记！

3. **时间管理**
   - 天池赛 + 算法学习需要平衡
   - 质量优先：少做几题，但要做透
   - 持续性：每天保持1-2题，不断档

---

## 📚 知识体系更新

**DP方法论v1.1 → v1.2**：
- ✅ 新增：虚拟节点在二维DP中的应用
- ✅ 强化：下标映射关系（一维 vs 二维）
- ✅ 补充：二维DP代码模板

**技能树更新**：
```
动态规划
├── Fibonacci模型（已掌握）
│   ├── 爬楼梯系列 ✅
│   └── Tribonacci ✅
├── 字符串DP（已掌握）
│   ├── 解码方法 ✅（一维虚拟节点）
│   └── 最小花费爬楼梯 ✅
└── 二维DP（新增）
    └── 路径问题 ✅（二维虚拟节点）
        └── 不同路径 II ✅
```

---

## 🎯 下一步计划

- [ ] Day34: 继续DP专题（打家劫舍系列 / 其他路径问题）
- [ ] 合理安排天池赛调优时间
- [ ] 保持每天1-2题的节奏
- [ ] 巩固虚拟节点技巧（一维 + 二维）

---

## 🏆 成长亮点

- ✅ 双线作战，合理分配时间
- ✅ 保持学习连续性
- ✅ 从错误中快速定位问题（下标映射）
- ✅ 虚拟节点技巧从一维扩展到二维

---

> **今日状态**：时间紧张，但保持进度！一题做透胜过三题做完！🔥

