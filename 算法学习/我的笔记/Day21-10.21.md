# Day21 - 10.21 栈专题

## 📚 今日学习内容

**专题**：栈（Stack）
**目标题数**：5道以上
**课程来源**：比特课程 - 算法精品课3

---

## 💡 栈的常用技巧

### 1. 栈的基本操作
- `push()`：入栈
- `pop()`：出栈
- `top()`：查看栈顶元素
- `empty()`：判断栈是否为空

### 2. 单调栈
- 维护栈内元素的单调性
- 常用于"下一个更大/更小元素"问题

### 3. 栈与括号匹配
- 左括号入栈，右括号匹配出栈
- 检查括号是否合法

### 4. 栈与表达式求值
- 中缀表达式转后缀表达式
- 后缀表达式求值

---

## 📝 今日题目

### 题目1：LeetCode 20 - 有效的括号 (easy) ⭐⭐⭐

**题目链接**：https://leetcode.cn/problems/valid-parentheses/

**题目描述**：


**解题思路**：


**我的代码**：
```cpp

```

**提交结果**：
- 执行用时：
- 内存消耗：
- 通过时间：

**错误记录**：


**总结与反思**：


---

### 题目2：LeetCode 1047 - 删除字符串中的所有相邻重复项 (easy)

**题目链接**：https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/

**题目描述**：
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
在 S 上反复执行重复项删除操作，直到无法继续删除。
在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

示例：
```
输入："abbaca"
输出："ca"
解释：在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。
之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

**解题思路**：
1. 本质是**栈**的应用，类似"消消乐"游戏
2. 用 `string` 模拟栈结构：
   - `ret.back()` 获取栈顶元素
   - `ret.pop_back()` 弹出栈顶
   - `ret += ch` 压入元素
3. 遍历字符串：
   - 如果栈非空 且 栈顶等于当前字符 → 出栈（消除）
   - 否则 → 入栈
4. **关键**：在使用 `back()` 和 `pop_back()` 前必须判断栈非空

**我的代码（第一版 - 错误）**：
```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        // 利用数组模拟栈，当元素相同时弹出
        string ret;
        ret[0] = s[0];  // ❌ 错误1：空字符串不能用下标赋值
        int n = s.size();
        for(int i = 1; i < n; i++)
        {
            if(s[i] != ret.pop()) ret+=s[i];  // ❌ 错误2：string没有pop()方法
            else ret.pop_back();
        }
        return ret;
    }
};
```

**第一版问题**：
1. `ret[0] = s[0]` - 空字符串不能用下标访问
2. `ret.pop()` - string没有这个方法，应该用 `ret.back()` 获取栈顶

---

**我的代码（第二版 - 仍有问题）**：
```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string ret;
        ret += s[0];  // ✓ 改正：用 += 添加元素
        int n = s.size();
        for(int i = 1; i < n; i++)
        {
            char result;
            if(!ret.empty()) result = ret.back();  // ✓ 改正：用 back() 获取栈顶
            if(result != s[i]) ret+= s[i]; 
            else ret.pop_back();  // 相等要出栈
        }
        return ret;
    }
};
```

**第二版问题**：
- **测试结果**：`2 / 106 个通过的测试用例`
- **错误信息**：
  ```
  runtime error: addition of unsigned offset to 0x7f003b300340 overflowed to 0x7f003b30033f
  UndefinedBehaviorSanitizer: undefined-behavior
  ```
- **根本原因**：`result` 变量未初始化！
  - 当 `ret` 为空时，`result` 没有被赋值，是垃圾值
  - 后续使用垃圾值进行判断 → 未定义行为
  - 可能对空字符串调用 `pop_back()` → 崩溃

---

**我的代码（最终版 - AC）**：
```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string ret;
        for(char ch : s) {
            if(ret.size() && ret.back() == ch) {  // ✓ 合并判断，利用短路特性
                ret.pop_back();  // 相同就消除
            } else {
                ret += ch;        // 不同就入栈
            }
        }
        return ret;
    }
};
```

**最终版改进**：
1. 用 `for(char ch : s)` 从头遍历，不需要特殊处理第一个元素
2. 用 `&&` 合并判断：`ret.size() && ret.back() == ch`
3. 利用短路特性：如果 `ret.size()` 为0，就不会执行 `ret.back()`，避免错误

**提交结果**：
- 执行用时：AC
- 内存消耗：
- 通过时间：

**错误记录**：

1. **初版错误：未初始化变量 + 对空字符串操作** ❌
   ```cpp
   char result;
   if(!ret.empty())  result = ret.back();
   if(result != s[i]) ret+= s[i]; 
   else ret.pop_back();
   ```
   
   **问题分析**：
   - 当 `ret` 为空时，`result` 未被赋值，是**垃圾值**
   - 使用未初始化的变量 → 未定义行为
   - 如果垃圾值恰好等于 `s[i]`，会对**空字符串**调用 `pop_back()` → 运行时错误
   
   **测试用例**：`"abbaca"`
   ```
   i=3, s[i]='a': 弹出后 ret=""
   i=4, s[i]='c': ret为空，result是垃圾值
                  如果垃圾值=='c' → 对空字符串pop_back() → 崩溃💥
   ```
   
   **错误信息**：
   ```
   runtime error: addition of unsigned offset overflowed
   ```

2. **根本原因**：逻辑拆分导致的问题
   - 分开判断 `if(!ret.empty())` 和 `if(result != s[i])`
   - 两个判断之间，`ret` 的状态没有关联
   - 正确做法：用 `&&` 将判断合并，利用短路特性

**总结与反思**：
- **核心教训**：**使用 `back()` 和 `pop_back()` 前必须判断非空**
- **短路特性**：`if(ret.size() && ret.back() == ch)` 中，如果 `ret.size()` 为0，就不会执行 `ret.back()`，避免了错误
- **栈的本质**：后进先出（LIFO），本题利用了栈的"相邻元素比较"特性
- **数组模拟栈**：`string` 可以完美模拟栈结构，比用 `stack<char>` 更方便（最后直接返回结果）
- **遍历方式**：可以用 `for(char ch : s)` 从头遍历，不需要特殊处理第一个元素
- **时间复杂度**：O(n)，每个字符最多入栈出栈各一次
- **空间复杂度**：O(n)，最坏情况栈存储所有字符（无重复）


---

### 题目3：LeetCode 844 - 比较含退格的字符串 (easy)

**题目链接**：https://leetcode.cn/problems/backspace-string-compare/

**题目描述**：
给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

示例 1：
```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

示例 2：
```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

示例 3：
```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

**解题思路**：
1. 用栈模拟文本编辑器的退格过程
2. 对两个字符串分别处理：
   - 遇到普通字符 → 压入栈
   - 遇到 `'#'` 且栈非空 → 弹出栈顶
   - 遇到 `'#'` 但栈为空 → 什么都不做
3. 最后比较两个栈是否相等

**我的代码（第一版 - 错误）**：
```cpp
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        string ret1;
        string ret2;

        for(auto ch : s)
        {
            if(ret1.size() && ch == '#')
            {
                ret1.pop_back();
            }
            else ret1 += ch;  // ❌ 问题：把 '#' 也加入了！
        }
        for(auto ch : t)
        {
            if(ret2.size() && ch == '#')
            {
                ret2.pop_back();
            }
            else ret2 += ch;
        }
        if(ret1 == ret2) return true;
        else return false;
    }
};
```

**第一版问题**：
- **测试结果**：`103 / 115 个通过的测试用例`
- **失败用例**：
  ```
  s = "y#fo##f"
  t = "y#f#o##f"
  输出：false
  预期结果：true
  ```

- **错误分析**：
  ```
  处理 t = "y#f#o##f"：
  'y': ret2 = "y"
  '#': ret2非空，pop → ret2 = ""
  'f': ret2 = "f"
  '#': ret2非空，pop → ret2 = ""
  'o': ret2 = "o"
  '#': ret2非空，pop → ret2 = ""
  '#': ret2为空！条件false → 执行else → ret2 = "#"  💥
  'f': ret2 = "#f"
  
  结果：ret1 = "f", ret2 = "#f"
  ```

- **根本原因**：
  - 当 `ch == '#'` 但 `ret` 为空时，条件 `ret.size() && ch == '#'` 为 `false`
  - 执行 `else ret += ch`，把 `'#'` 加入栈中
  - **退格符不应该被加入栈！**

---

**我的代码（第二版 - 语法错误）**：
```cpp
for(auto ch : s)
{
    if(ret1.size() && ch == '#')
    {
        ret1.pop_back();
    }
    else 
    {
        if(ch != '#)  // ❌ 语法错误：缺少右引号
            ret1 += ch;
    }
}
```

**第二版问题**：
- 编译错误：`if(ch != '#)` 缺少右引号
- 应该是：`if(ch != '#')`

---

**我的代码（最终版 - AC）**：
```cpp
class Solution {
public:
    bool backspaceCompare(string s, string t) {
        string ret1;
        string ret2;

        for(auto ch : s)
        {
            if(ch != '#') {
                ret1 += ch;  // 不是 # 就压入
            } else if(ret1.size()) {
                ret1.pop_back();  // 是 # 且栈非空就弹出
            }
            // 是 # 但栈为空时，什么都不做
        }
        
        for(auto ch : t)
        {
            if(ch != '#') {
                ret2 += ch;
            } else if(ret2.size()) {
                ret2.pop_back();
            }
        }
        
        return ret1 == ret2;  // 直接返回比较结果
    }
};
```

**最终版改进**：
1. 先判断 `ch != '#'`，逻辑更清晰
2. 用 `else if` 处理退格，确保只在栈非空时弹出
3. 当 `ch == '#'` 但栈为空时，自动什么都不做
4. 简化返回语句：`return ret1 == ret2`

**提交结果**：
- 执行用时：AC
- 内存消耗：
- 通过时间：

**错误记录**：

**关键错误：退格符被加入栈**
- 原因：逻辑顺序错误，先判断 `ret.size() && ch == '#'`
- 当栈为空且 `ch == '#'` 时，条件为 `false`，执行 `else` 把 `'#'` 加入栈
- 教训：**应该先判断字符类型，再决定操作**

**语法错误：字符常量缺少引号**
- `if(ch != '#)` → `if(ch != '#')`
- C++中字符用单引号 `'#'`，字符串用双引号 `"#"`

**总结与反思**：
- **核心教训**：逻辑顺序很重要！先判断字符类型，再判断栈状态
- **栈的应用**：模拟退格操作，退格符本身不应该进入栈
- **边界条件**：对空栈退格时什么都不做（不能 pop，也不能把 '#' 压入）
- **代码简化**：`return ret1 == ret2` 比 `if...else return true/false` 更简洁
- **调试技巧**：遇到部分用例失败，用失败的用例手动模拟执行过程，找出问题点
- **时间复杂度**：O(n+m)，n和m分别是两个字符串长度
- **空间复杂度**：O(n+m)，最坏情况两个栈都存储全部字符


---

### 题目4：LeetCode 227 - 基本计算器 II (medium) ⭐⭐

**题目链接**：https://leetcode.cn/problems/basic-calculator-ii/

**题目描述**：
给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

你可以假设给定的表达式总是有效的。所有中间结果将在 [-2^31, 2^31 - 1] 的范围内。

注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。

示例 1：
```
输入：s = "3+2*2"
输出：7
```

示例 2：
```
输入：s = " 3/2 "
输出：1
```

示例 3：
```
输入：s = " 3+5 / 2 "
输出：5
```

提示：
- 1 <= s.length <= 3 * 10^5
- s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开
- s 表示一个有效表达式
- 表达式中的所有整数都是非负整数，且在范围 [0, 2^31 - 1] 内

**解题思路**：
1. **核心思想**：先处理乘除，再处理加减（符合四则运算顺序）
2. **栈的使用**：
   - 遇到 `+` 号：数字直接入栈
   - 遇到 `-` 号：数字的相反数入栈
   - 遇到 `*` 号：数字与栈顶元素相乘，修改栈顶
   - 遇到 `/` 号：栈顶元素除以数字，修改栈顶
3. **处理流程**：
   - 用变量 `op` 记录**上一个运算符**（初始为 `'+'`）
   - 提取完整的多位数字
   - 根据 `op` 决定如何处理这个数字
   - 遇到新运算符时，更新 `op`
4. **最后**：栈中所有数字相加即为结果

**我的代码（初版框架 - 有问题）**：
```cpp
class Solution {
public:
    int calculate(string s) {
        string ret;  // ❌ 问题1：应该用 vector<int> 存数字
        for(auto ch : s)
        {
            string tmp;
            if(ch != '+' && ch != '-' && ch != '*' && ch != '/')
            {
                tmp += ch;  // ❌ 问题2：只提取了一个字符，多位数怎么办？
                ret.push_back(tmp);  // ❌ 问题3：立即入栈，逻辑不对
            }
            else if(ch == '+') ret.push_back(tmp);  // ❌ 问题4：tmp 没有赋值
            // ...
        }
    }
};
```

**初版问题分析**：
1. **类型错误**：用 `string` 做栈，应该用 `vector<int>` 存数字
2. **多位数提取**：只加了一个字符就入栈，无法处理 `"32+5"` 这种情况
3. **逻辑顺序**：应该先提取完整数字，再根据运算符处理
4. **运算符记录**：没有变量记录上一个运算符

---

**我的代码（最终版 - AC）**：
```cpp
class Solution {
public:
    int calculate(string s) {
        vector<int> st;  // 栈，存数字
        char op = '+';   // 记录上一个运算符
        int i = 0, n = s.size();
        
        while(i < n)
        {
            if(s[i] == ' ') {
                i++;  // 跳过空格
            }
            else if(s[i] >= '0' && s[i] <= '9')
            {
                // 提取完整数字
                int num = 0;
                while(i < n && s[i] >= '0' && s[i] <= '9')
                {
                    num = num * 10 + (s[i] - '0');  // 字符转数字
                    i++;
                }
                
                // 根据 op 决定如何处理 num
                if(op == '+') st.push_back(num);
                else if(op == '-') st.push_back(-num);
                else if(op == '*') st.back() *= num;
                else if(op == '/') st.back() /= num;
            }
            else 
            {
                // 遇到运算符，记录下来
                op = s[i];
                i++;
            }
        }
        
        // 最后把栈里所有数字加起来
        int ret = 0;
        for(auto x : st) ret += x;
        return ret;
    }
};
```

**提交结果**：
- 执行用时：AC
- 内存消耗：
- 通过时间：

**错误记录**：
无错误，一次AC ✅

**关键知识点**：

1. **多位数提取**：
   ```cpp
   int num = 0;
   while(i < n && s[i] >= '0' && s[i] <= '9') {
       num = num * 10 + (s[i] - '0');
       i++;
   }
   ```
   - 原理：`num * 10` 左移一位，加上新的个位数
   - 例如：`"32"` → `num=0` → `num=3` → `num=30+2=32`

2. **字符转数字**（复习昨天的知识）：
   - `s[i] - '0'`：字符转数字
   - 例如：`'5' - '0' = 53 - 48 = 5`

3. **运算符的处理时机**：
   - 提取数字时，用的是**上一个运算符** `op`
   - 遇到新运算符时，只是**记录**，不处理

4. **为什么加减法不立即计算？**
   - 因为乘除优先级更高
   - 遇到 `+` 时不知道后面是否有 `*` 或 `/`
   - 所以先把正数或负数放入栈，最后统一相加

5. **为什么乘除法立即计算？**
   - 乘除法优先级最高
   - 可以立即与栈顶元素计算
   - 修改栈顶：`st.back() *= num` 或 `st.back() /= num`

**总结与反思**：
- **栈的妙用**：通过栈的方式处理运算优先级
  - 加减法：数字入栈（正数或负数）
  - 乘除法：立即与栈顶计算
  - 最后：所有栈内元素相加
- **多位数提取**：用 `while` 循环 + `num * 10 + digit` 的方式
- **运算符记录**：用变量 `op` 记录上一个运算符，初始为 `'+'`
- **空格处理**：遇到空格直接跳过
- **时间复杂度**：O(n)，遍历一遍字符串
- **空间复杂度**：O(n)，栈最多存储 n/2 个数字
- **学习收获**：这道题是栈的经典应用，理解了"先处理高优先级，再处理低优先级"的思想


---

### 题目5：LeetCode 394 - 字符串解码 (medium) ⭐⭐

**题目链接**：https://leetcode.cn/problems/decode-string/

**题目描述**：
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 `3a` 或 `2[4]` 的输入。

示例 1：
```
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

示例 2：
```
输入：s = "3[a2[c]]"
输出："accaccacc"
```

示例 3：
```
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**解题思路**：
1. **核心思想**：用栈处理嵌套结构（类似括号匹配）
2. **需要两个栈**：
   - `stack<int> nums`：存储重复次数
   - `stack<string> strs`：存储之前的字符串（外层信息）
3. **遍历字符串，分类处理**：
   - 遇到**数字**：提取完整多位数（和计算器II一样）
   - 遇到 `[`：保存外层信息（num和ret入栈），重置准备处理内层
   - 遇到 `]`：解码当前层（出栈，重复拼接）
   - 遇到**字母**：直接加到当前字符串
4. **嵌套的处理**：栈天然支持嵌套，先解码内层，再解码外层

**我的代码（第一版 - 运行时错误）**：
```cpp
class Solution {
public:
    string decodeString(string s) {
        stack<int> nums;
        stack<string> strs;
        string ret = "";
        int num = 0;
        int i = 0, n = s.size();
        
        while(i < n) {
            if(s[i] >= '0' && s[i] <= '9') {
                num = num * 10 + (s[i] - '0');
                i++;
            }
            else if(s[i] == '[') {
                nums.push(num);
                strs.push(ret);
                num = 0;
                ret = "";
                i++;
            }
            else if(s[i] == ']') {
                int k = nums.top(); nums.pop();
                string prev = strs.top(); strs.pop();
                
                string tmp = ret;
                ret = prev;
                while(k--) {
                    ret += tmp;
                }
                // ❌ 缺少 i++！
            }
            else {
                ret += s[i];
                i++;
            }
        }
        return ret;
    }
};
```

**第一版问题**：
- **错误信息**：
  ```
  runtime error: reference binding to misaligned address
  UndefinedBehaviorSanitizer: undefined-behavior
  ```

- **错误分析**：
  - 在 `']'` 分支处理完后，**忘记 `i++`**
  - 导致下次循环还是处理同一个 `']'`
  - 又执行 `nums.pop()` 和 `strs.pop()`
  - 栈已经空了，还在pop → **访问非法内存** → 崩溃💥

- **调试过程**（手动模拟 `"2[a]"`）：
  ```
  i=0, '2': num=2, i=1
  i=1, '[': nums=[2], strs=[""], ret="", i=2
  i=2, 'a': ret="a", i=3
  i=3, ']': k=2, ret="aa", i还是3！❌
  i=3, ']': 又处理一次 → 栈空了 → 崩溃💥
  ```

- **根本原因**：索引未移动，死循环且重复pop空栈

---

**我的代码（最终版 - AC）**：
```cpp
class Solution {
public:
    string decodeString(string s) {
        stack<int> nums;      // 存储重复次数
        stack<string> strs;   // 存储之前的字符串
        string ret = "";
        int num = 0;
        int i = 0, n = s.size();
        
        while(i < n) {
            if(s[i] >= '0' && s[i] <= '9') {
                // 提取完整多位数
                num = num * 10 + (s[i] - '0');
                i++;
            }
            else if(s[i] == '[') {
                // 入栈，保存外层信息
                nums.push(num);
                strs.push(ret);
                num = 0;   // 重置
                ret = "";  // 重置
                i++;
            }
            else if(s[i] == ']') {
                // 出栈并解码
                int k = nums.top(); nums.pop();
                string prev = strs.top(); strs.pop();
                
                string tmp = ret;
                ret = prev;
                while(k--) {
                    ret += tmp;
                }
                i++;  // ✅ 关键！
            }
            else {
                // 普通字符
                ret += s[i];
                i++;
            }
        }
        
        return ret;
    }
};
```

**最终版改进**：
- ✅ 在 `']'` 分支末尾加上 `i++`
- ✅ 四个分支都正确移动索引

**提交结果**：
- 执行用时：AC
- 内存消耗：
- 通过时间：

**错误记录**：

**致命错误：忘记移动索引 `i++`**
- 位置：`']'` 分支处理完后
- 后果：死循环，重复处理同一个字符，对空栈pop导致崩溃
- 教训：**每个分支处理完都要移动索引！**

**调试方法**：
1. **手动模拟**：用简单用例 `"2[a]"` 逐步模拟
2. **状态记录**：记录每一步的 `i`, `nums`, `strs`, `ret`, `num`
3. **发现问题**：看到 `i` 值不变 → 立即知道是忘记 `i++`

**总结与反思**：

**与第4题对比**：

| 特征 | 第4题（计算器II） | 第5题（字符串解码） |
|------|------------------|-------------------|
| **栈的数量** | 1个（存数字） | 2个（存数字+字符串） |
| **结构** | 线性（无嵌套） | 嵌套（括号配对） |
| **数字作用** | 被运算的数 | 重复次数 |
| **符号处理** | 运算符（+-*/） | 括号（[]） |
| **核心思想** | 优先级处理 | 嵌套处理 |

**相同点**：
- 都需要提取完整多位数：`num = num * 10 + (s[i] - '0')`
- 都是逐字符分类处理
- 都使用栈作为辅助结构

**不同点**：
- 第4题：用栈存中间结果，最后相加
- 第5题：用栈保存外层信息，遇到 `]` 时恢复并解码

**核心教训**：
1. ⚠️ **索引移动是生命线**：每个分支都要有 `i++`，否则死循环或崩溃
2. 🔑 **手动模拟是王道**：遇到bug，用简单用例手动模拟，能快速定位问题
3. 💡 **栈处理嵌套**：栈天然支持嵌套结构（括号匹配、表达式求值、字符串解码）
4. 📚 **分类讨论要完整**：数字、左括号、右括号、字母，四种情况都要处理

**思考方法总结**：
- **遇到嵌套** → 想到栈
- **需要保存外层信息** → 入栈
- **处理完内层** → 出栈恢复
- **分类讨论** → 每个分支都检查索引移动

**时间复杂度**：O(n)，每个字符处理一次，重复拼接的总字符数也是O(n)级别  
**空间复杂度**：O(n)，栈的深度取决于嵌套层数，最坏O(n)


---

### 题目6：LeetCode 946 - 验证栈序列 (medium)

**题目链接**：https://leetcode.cn/problems/validate-stack-sequences/

**题目描述**：


**解题思路**：


**我的代码**：
```cpp

```

**提交结果**：
- 执行用时：
- 内存消耗：
- 通过时间：

**错误记录**：


**总结与反思**：


---

### 题目7：LeetCode 155 - 最小栈 (medium) ⭐⭐

**题目链接**：https://leetcode.cn/problems/min-stack/

**题目描述**：


**解题思路**：


**我的代码**：
```cpp

```

**提交结果**：
- 执行用时：
- 内存消耗：
- 通过时间：

**错误记录**：


**总结与反思**：


---

### 题目8：LeetCode 739 - 每日温度 (medium) ⭐⭐（单调栈）

**题目链接**：https://leetcode.cn/problems/daily-temperatures/

**题目描述**：


**解题思路**：


**我的代码**：
```cpp

```

**提交结果**：
- 执行用时：
- 内存消耗：
- 通过时间：

**错误记录**：


**总结与反思**：


---

## 📊 今日学习总结

### 完成情况
- [ ] 题目1：LeetCode 20 - 有效的括号 (easy)
- [x] 题目2：LeetCode 1047 - 删除字符串中的所有相邻重复项 (easy) - AC
- [x] 题目3：LeetCode 844 - 比较含退格的字符串 (easy) - AC
- [x] 题目4：LeetCode 227 - 基本计算器 II (medium) - AC ⭐
- [x] 题目5：LeetCode 394 - 字符串解码 (medium) - AC ⭐
- [ ] 题目6：LeetCode 946 - 验证栈序列 (medium)
- [ ] 题目7：LeetCode 155 - 最小栈 (medium)
- [ ] 题目8：LeetCode 739 - 每日温度 (medium)

### 栈专题核心知识点

#### 1. 栈的特性
- **LIFO**（后进先出）
- 只能在栈顶操作

#### 2. 单调栈模板
```cpp
stack<int> st;
for(int i = 0; i < n; i++) {
    while(!st.empty() && st.top() > nums[i]) {
        st.pop();
    }
    st.push(nums[i]);
}
```

#### 3. 括号匹配模板
```cpp
stack<char> st;
for(char ch : s) {
    if(ch == '(' || ch == '[' || ch == '{') {
        st.push(ch);
    } else {
        if(st.empty()) return false;
        // 检查是否匹配
        st.pop();
    }
}
return st.empty();
```

### 今日踩坑记录


### 今日收获与感悟


### 学习用时
- 总用时：
- 平均每题：

---

## 🔗 相关链接
- [算法精品课3 - 栈部分](../比特课程/算法精品课3.md#栈)

