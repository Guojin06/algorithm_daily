# Day24 - 递归专题二：二叉树深搜 (10.24)

## 学习目标
- 掌握二叉树深度优先搜索（DFS）
- 理解二叉搜索树（BST）的性质
- 熟练运用递归解决树的结构修改、验证、路径问题

---

## 1. LeetCode 814 - 二叉树剪枝

### 题目描述
给你二叉树的根结点 `root` ，此外树的每个结点的值要么是 `0` ，要么是 `1` 。

返回移除了所有不包含 `1` 的子树的原二叉树。

节点 `node` 的子树为 `node` 本身加上所有 `node` 的后代。

**示例 1：**
```
输入：root = [1,null,0,0,1]
输出：[1,null,0,null,1]
解释：
只有红色节点满足条件"所有不包含 1 的子树"。 右图为返回的答案。
```

**示例 2：**
```
输入：root = [1,0,1,0,0,0,1]
输出：[1,null,1,null,1]
```

**示例 3：**
```
输入：root = [1,1,0,1,1,0,1,0]
输出：[1,1,0,1,1,null,1]
```

**提示：**
- 树中节点的数目在范围 `[1, 200]` 内
- `Node.val` 为 `0` 或 `1`

### 解题思路

**核心思想**：
- 使用**后序遍历**（左→右→根）
- 先处理子树，再决定当前节点是否保留
- 删除条件：左右子树都为空 且 当前节点值为0

**递归设计**：
```cpp
TreeNode* pruneTree(TreeNode* root)
功能：对以root为根的树进行剪枝，删除所有不包含1的子树
返回值：剪枝后的树根（如果整棵树都被删除，返回nullptr）
```

**关键理解**：
1. **后序遍历的必要性**：必须先知道子树是否包含1，才能决定当前节点
2. **递归返回值语义**：返回的是剪枝后的树根（可能是原节点，可能是nullptr）
3. **删除判断**：左右子树都为空 + 自身为0 → 删除

**思考过程**：
```
对于每个节点，判断是否删除需要：
1. 左子树剪枝后的结果（可能为空）
2. 右子树剪枝后的结果（可能为空）
3. 如果左右都空且自身为0 → 删除当前节点
4. 否则 → 保留当前节点
```

**示例执行（树 = [1,null,0,0,1]）**：
```
原始树：
    1
     \
      0
     / \
    0   1

执行过程：
1. pruneTree(左0)：叶子节点，val=0 → 返回nullptr（删除）
2. pruneTree(右1)：叶子节点，val=1 → 返回节点1（保留）
3. pruneTree(中0)：left=null, right=节点1, val=0 → 保留（因为right不为空）
4. pruneTree(根1)：保留

结果：
    1
     \
      0
       \
        1
```

### 初始代码/错误代码

**错误版本1：提前返回叶子节点**
```cpp
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        // 递归出口
        if(root == nullptr) return nullptr;
        if(root->left == nullptr && root->right == nullptr) return root;  // ❌ 错误！
        
        // 后序遍历
        if(root->left) root->left = pruneTree(root->left);
        if(root->right) root->right = pruneTree(root->right);
        
        // 判断是否删除当前节点
        if (root->left == nullptr && root->right == nullptr && root->val == 0)  
            root = nullptr;
        
        return root;
    }
};
```

**失败测试用例**：
```
输入：root = [1,null,0,0,1]
输出：[1,null,0,0,1]（错误）
预期：[1,null,0,null,1]
```

### 错误分析

**问题1：提前返回叶子节点**
```cpp
if(root->left == nullptr && root->right == nullptr) return root;  // ❌
```

**错误原因**：
- 这个递归出口**无条件返回所有叶子节点**
- 即使叶子节点的值为0，也被返回了
- 导致值为0的叶子节点没有被删除

**正确理解**：
- 叶子节点也需要判断是否删除（val是否为0）
- 不应该提前返回，应该和其他节点一样统一判断

**问题2：递归返回值语义不一致**

```
错误版本的返回情况：
- 情况1：root == nullptr → 返回nullptr
- 情况2：叶子节点 → 返回root（不管val是0还是1）❌
- 情况3：需要删除 → 返回nullptr
- 情况4：保留 → 返回root

问题：情况2的语义不一致，没有判断是否真的应该保留
```

**问题3：指针访问错误（初始尝试）**

```cpp
if(root->left->val == 0)  // ❌ 如果left为nullptr，会崩溃！
```

**正确做法**：
```cpp
if(root->left == nullptr)  // ✅ 先检查指针是否为空
```

### 正确代码

**方法：后序遍历 + 统一判断**
```cpp
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        // 1. 递归出口：空节点直接返回
        if(root == nullptr) return nullptr;
        
        // 2. 后序遍历：先处理左右子树（获得剪枝后的结果）
        root->left = pruneTree(root->left);   // 剪枝左子树
        root->right = pruneTree(root->right); // 剪枝右子树
        
        // 3. 判断当前节点是否需要删除
        if (root->left == nullptr && root->right == nullptr && root->val == 0) {
            return nullptr;  // 删除条件：左右子树都空 且 当前值为0
        }
        
        // 4. 保留当前节点
        return root;
    }
};
```

**代码要点**：
1. ✅ 只有一个递归出口：`root == nullptr`
2. ✅ 先处理子树，再处理当前节点（后序遍历）
3. ✅ 统一判断删除条件，不提前返回
4. ✅ 递归返回值语义一致：要么返回剪枝后的树根，要么返回nullptr

### 核心知识点

**后序遍历的应用场景**：
```
后序遍历（左→右→根）适合：
- 需要根据子树信息决定当前节点的操作
- 树的结构修改问题（删除、剪枝）
- 自底向上的信息传递
```

**递归返回值的语义一致性**：
```
关键原则：
1. 明确函数语义：pruneTree返回的是"剪枝后的树根"
2. 每个返回点的语义必须相同
3. 不要提前返回未经完整判断的结果
```

**删除节点的条件**：
```cpp
// 删除条件：同时满足三个条件
1. root->left == nullptr   (左子树为空或已被删除)
2. root->right == nullptr  (右子树为空或已被删除)
3. root->val == 0          (当前节点值为0)
```

**空指针检查**：
```cpp
// ❌ 错误：直接访问可能为空的指针
if(root->left->val == 0) { ... }

// ✅ 正确：先检查指针是否为空
if(root->left != nullptr && root->left->val == 0) { ... }

// ✅ 更好：检查指针本身
if(root->left == nullptr) { ... }
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(h) 递归栈

---

## 2. LeetCode 98 - 验证二叉搜索树

### 题目描述
给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：
- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**
```
输入：root = [2,1,3]
输出：true
```

**示例 2：**
```
输入：root = [5,1,4,null,null,3,6]
输出：false
解释：根节点的值是 5 ，但是右子节点的值是 4 。
```

**提示：**
- 树中节点数目范围在`[1, 10^4]` 内
- `-2^31 <= Node.val <= 2^31 - 1`

### 解题思路

**BST性质利用**：
- BST的**中序遍历结果**是严格递增的
- 中序遍历顺序：左 → 根 → 右

**验证思路**：
1. 进行中序遍历
2. 用全局变量`prev`记录前一个访问的节点值
3. 每次访问当前节点时，检查 `当前值 > prev`
4. 如果不满足 → 不是BST

**关键点**：
- **严格大于**（不能等于！）
- 使用`LONG_MIN`初始化prev（处理节点值为`INT_MIN`的情况）
- 中序遍历 = 左 → 根 → 右

**递归函数**：
```cpp
bool isValidBST(TreeNode* root)
功能：判断以root为根的树是否是BST
返回值：true/false
```

### 初始代码/错误代码

**错误版本：使用了 `>=` 而不是 `>`**
```cpp
class Solution {
public:
    long prev = LONG_MIN;
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        
        bool left = isValidBST(root->left);
        
        bool cur = false;
        if(root->val >= prev)  // ❌ 错误：使用了 >=
        {
            cur = true;
        }
        prev = root->val;
        
        bool right = isValidBST(root->right);
        return left && cur && right;
    }
};
```

**失败测试用例**：
```
输入：root = [2,2,2]
       2
      / \
     2   2

输出：true（错误）
预期：false
```

### 错误分析

**问题根源**：BST定义理解错误

**BST的严格定义**：
- 左子树所有节点 **< 当前节点**（严格小于，**不能相等**）
- 右子树所有节点 **> 当前节点**（严格大于，**不能相等**）

**错误代码执行过程**（测试用例 `[2,2,2]`）：
```
中序遍历：左2 → 根2 → 右2

访问左2：prev = LONG_MIN，2 >= LONG_MIN ✅，更新 prev = 2
访问根2：prev = 2，       2 >= 2         ✅ (错误！)，更新 prev = 2
访问右2：prev = 2，       2 >= 2         ✅ (错误！)

返回 true，但正确答案应该是 false
```

**错误原因**：
- BST不允许有重复值
- `>=` 允许了相等的情况
- 应该用 `>` 确保严格递增

### 正确代码

**方法：中序遍历 + 剪枝优化**
```cpp
class Solution {
public:
    long prev = LONG_MIN;  // 全局变量记录前一个节点值
    bool isValidBST(TreeNode* root) {
        // 递归出口
        if(root == nullptr) return true;
        
        // 中序遍历：左 → 根 → 右
        bool left = isValidBST(root->left);
        if(left == false) return false;  // 剪枝：左子树不满足，直接返回
        
        // 检查当前节点
        bool cur = false;
        if(root->val > prev)  // ✅ 严格大于
        {
            cur = true;
        }
        else return false;  // 剪枝：当前节点不满足，直接返回
        
        prev = root->val;  // 更新prev
        
        // 检查右子树
        bool right = isValidBST(root->right);
        return left && cur && right;
    }
};
```

**代码优化点**：
1. ✅ 使用 `>` 而不是 `>=`（严格递增）
2. ✅ 左子树不满足时立即返回（剪枝）
3. ✅ 当前节点不满足时立即返回（剪枝）
4. ✅ 使用 `LONG_MIN` 处理 `INT_MIN` 的边界情况

### 核心知识点

**BST的中序遍历性质**：
```
BST的中序遍历结果 = 严格递增序列

     5
    / \
   3   7
  / \
 2   4

中序遍历：2, 3, 4, 5, 7（严格递增）
```

**全局变量 vs 参数传递**：
```cpp
// 方法1：全局变量（本题方法）
long prev = LONG_MIN;

// 方法2：参数传递（也可以）
bool dfs(TreeNode* root, long& prev) { ... }
```

**剪枝的重要性**：
```
如果左子树已经不是BST，没必要继续检查右子树
提前返回可以节省递归调用
```

### 提交结果
- 提交时间：AC ✅（73/86 → 全部通过）
- 执行用时：符合预期
- 内存消耗：O(h) 递归栈

---

## 3. LeetCode 230 - 二叉搜索树中第K小的元素

### 题目描述
给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

**示例 1：**
```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

**示例 2：**
```
输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
```

**提示：**
- 树中的节点数为 `n` 。
- `1 <= k <= n <= 10^4`
- `0 <= Node.val <= 10^4`

### 解题思路

**核心思想**：
- BST的中序遍历 = 严格递增序列
- 第K小的元素 = 中序遍历的第K个节点

**思考过程**：
1. 如果是普通数组，找第K小 → 排序后取第K个
2. BST的特殊性质 → 中序遍历天然有序！
3. 问题转化 → 在中序遍历过程中找到第K个访问的节点

**递归设计**：
```cpp
void dfs(TreeNode* root, int k)
功能：对以root为根的树进行中序遍历，并计数
```

**需要的全局变量**：
- `count`：已访问的节点数（计数器）
- `result`：第K小的值（答案）

**递归框架**：
```
1. 递归出口：root == nullptr 或 count >= k（剪枝）
2. 中序遍历：
   - 先访问左子树（找更小的）
   - 访问当前节点：count++，检查是否 count == k
   - 再访问右子树（找更大的）
```

**示例执行过程（BST = [3,1,4,null,2], k=3）**：
```
     3
    / \
   1   4
    \
     2

中序遍历访问顺序：
1. 访问节点1 → count=1
2. 访问节点2 → count=2
3. 访问节点3 → count=3 ✅ 找到答案！
```

### 初始代码/错误代码
```cpp
// 无错误，一次AC
```

### 错误分析
无错误

### 正确代码

**方法：中序遍历 + 全局计数 + 剪枝**
```cpp
class Solution {
public:
    int count = 0;     // 全局计数器
    int result = 0;    // 答案
    
    int kthSmallest(TreeNode* root, int k) {
        dfs(root, k);
        return result;
    }
    
    void dfs(TreeNode* root, int k) {
        // 递归出口
        if(root == nullptr) return;
        if(count >= k) return;  // 剪枝：已找到答案
        
        // 中序遍历：左 → 根 → 右
        dfs(root->left, k);     // 1. 左子树
        
        count++;                // 2. 访问当前节点
        if(count == k) {
            result = root->val;
            return;
        }
        
        dfs(root->right, k);    // 3. 右子树
    }
};
```

**代码要点**：
1. ✅ 中序遍历保证访问顺序从小到大
2. ✅ 全局变量 `count` 记录访问次数
3. ✅ `count == k` 时记录答案
4. ✅ `count >= k` 时剪枝，避免多余递归

### 核心知识点

**BST的关键性质**：
```
BST的中序遍历 = 严格递增序列

     5
    / \
   3   7
  / \
 2   4

中序遍历：2, 3, 4, 5, 7
         ↑  ↑  ↑  ↑  ↑
        1st 2nd 3rd 4th 5th
```

**中序遍历模板**：
```cpp
void inorder(TreeNode* root) {
    if(root == nullptr) return;
    inorder(root->left);   // 左
    // 访问当前节点
    inorder(root->right);  // 右
}
```

**全局变量在递归中的应用**：
- 需要在递归过程中累积信息时使用
- 避免参数传递的复杂性
- 本题中：`count`（计数）和 `result`（答案）

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(h) 递归栈

---

## 4. LeetCode 257 - 二叉树的所有路径

### 题目描述
给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**
```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

**示例 2：**
```
输入：root = [1]
输出：["1"]
```

**提示：**
- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`

### 解题思路

**核心思想**：
- 使用**前序遍历**（根→左→右）
- 从根节点开始，记录经过的路径
- 到达叶子节点时，将完整路径加入结果集
- 使用**值传递**实现自动回溯

**递归设计**：
```cpp
void dfs(TreeNode* root, string path)
功能：从root出发，沿着当前path，找到所有到叶子的路径
参数：
  - root: 当前节点
  - path: 从根到当前节点的路径（值传递，自动回溯）
```

**关键理解**：
1. **叶子节点判断**：`left == nullptr && right == nullptr`
2. **路径格式**：非叶子节点加 `->`，叶子节点不加
3. **值传递妙用**：每次递归复制path，天然实现回溯

**思考过程**：
```
1. 全局变量记录结果集
2. 递归过程中构建路径字符串
3. 到达叶子节点时记录路径
4. 值传递避免手动回溯的繁琐
```

**示例执行（树 = [1,2,3,null,5]）**：
```
       1
      / \
     2   3
      \
       5

递归过程：
dfs(1, "")
├─ 非叶子，path = "1->"
├─ dfs(2, "1->")
│  ├─ 非叶子，path = "1->2->"
│  ├─ dfs(null, ...)  ← 左子树为空
│  └─ dfs(5, "1->2->")
│     ├─ 叶子！path = "1->2->5"
│     └─ 记录 "1->2->5" ✅
│
└─ dfs(3, "1->")
   ├─ 叶子！path = "1->3"
   └─ 记录 "1->3" ✅

结果：["1->2->5", "1->3"]
```

### 初始代码/错误代码
```cpp
// 无错误，一次AC
```

### 错误分析
无错误

### 正确代码

**方法：前序遍历 + 值传递回溯**
```cpp
class Solution {
public:
    vector<string> ret;  // 全局变量存储结果

    vector<string> binaryTreePaths(TreeNode* root) {
        string path = "";
        dfs(root, path);
        return ret;
    }
    
    void dfs(TreeNode* root, string path) {  // 值传递！
        // 递归出口：叶子节点
        if(root->left == nullptr && root->right == nullptr && root != nullptr) {
            path += to_string(root->val);
            ret.push_back(path);  // 记录完整路径
            return;
        } 
        
        // 非叶子节点：添加当前值和箭头
        if(root != nullptr) {
            path += to_string(root->val);
            path += "->";
        }
        
        // 递归左右子树
        if(root->left) dfs(root->left, path);
        if(root->right) dfs(root->right, path);
    }
};
```

**代码要点**：
1. ✅ **值传递**：`string path` 而非 `string& path`
2. ✅ 分离叶子和非叶子的处理（避免末尾多余箭头）
3. ✅ 判空后递归（减少不必要的调用）
4. ✅ 前序遍历（先访问根，再访问子树）

### 核心知识点

**值传递 vs 引用传递（回溯问题）**：

**方法1：值传递（本题方法）**
```cpp
void dfs(TreeNode* root, string path) {  // 值传递
    path += to_string(root->val);
    dfs(root->left, path);   // 复制了一份path
    dfs(root->right, path);  // 又复制了一份path（不受左子树影响）
    // 不需要手动回溯！
}
```

**方法2：引用传递（需要手动回溯）**
```cpp
void dfs(TreeNode* root, string& path) {  // 引用传递
    int len = path.size();
    path += to_string(root->val);
    dfs(root->left, path);
    dfs(root->right, path);
    path.erase(len);  // 需要手动恢复现场！
}
```

**选择建议**：
- 路径较短、操作简单 → 值传递（代码简洁）
- 路径很长、复制开销大 → 引用传递（性能更好）

**前序遍历的应用**：
```
前序遍历（根→左→右）适合：
- 路径问题（需要先访问当前节点）
- 自顶向下的信息传递
- 复制/克隆树结构
```

**叶子节点判断**：
```cpp
// 叶子节点：左右子树都为空
if(root->left == nullptr && root->right == nullptr)

// 注意：访问 root->left 前确保 root != nullptr
```

**C++ 空指针表示**：
```cpp
nullptr  // ✅ C++11推荐写法，类型安全
NULL     // C风格宏定义（值为0）
0        // 直接用0（不推荐）
// 注意：C++中没有 null 关键字（那是Java/JS的写法）
```

**路径格式控制**：
```cpp
// 叶子节点：只加值
path += to_string(root->val);  // "1->2->5"

// 非叶子节点：加值和箭头
path += to_string(root->val);
path += "->";                  // "1->2->"

// 这样避免了末尾多余的箭头
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(n) 存储所有路径

---

## 今日总结

### 完成情况
✅ **4道题全部AC！**
1. LeetCode 814 - 二叉树剪枝（树的结构修改）
2. LeetCode 98 - 验证二叉搜索树（BST验证）
3. LeetCode 230 - 二叉搜索树中第K小的元素（BST性质应用）
4. LeetCode 257 - 二叉树的所有路径（路径问题）

### 核心知识点

#### **1. 二叉搜索树（BST）的核心性质**
```
BST的中序遍历 = 严格递增序列

应用场景：
- 验证BST：检查中序遍历是否严格递增
- 找第K小：中序遍历的第K个节点
- 排序：对BST进行中序遍历即可得到有序序列
```

#### **2. 三种遍历方式的应用场景**

**前序遍历（根→左→右）**：
- 路径问题（需要先访问当前节点）
- 自顶向下的信息传递
- 复制/克隆树结构

**中序遍历（左→根→右）**：
- BST相关问题（天然有序）
- 需要按顺序访问节点

**后序遍历（左→右→根）**：
- 树的结构修改（删除、剪枝）
- 需要根据子树信息决定当前节点
- 自底向上的信息传递

#### **3. 递归返回值的语义一致性**

**关键原则**：
```cpp
TreeNode* function(TreeNode* root)
功能：明确定义函数的作用
返回值：每个返回点的语义必须一致
```

**易错示例**：
```cpp
// ❌ 错误：提前返回，语义不一致
if(root->left == nullptr && root->right == nullptr) 
    return root;  // 没有判断是否真的应该保留

// ✅ 正确：统一判断后返回
if(满足保留条件) return root;
if(满足删除条件) return nullptr;
```

#### **4. 值传递 vs 引用传递（回溯问题）**

**值传递（自动回溯）**：
```cpp
void dfs(TreeNode* root, string path) {  // 值传递
    // 每次递归都复制path，天然实现回溯
    path += to_string(root->val);
    dfs(root->left, path);   // 左子树有独立的path副本
    dfs(root->right, path);  // 右子树有独立的path副本
}
```

**引用传递（手动回溯）**：
```cpp
void dfs(TreeNode* root, string& path) {  // 引用传递
    int len = path.size();
    path += to_string(root->val);
    dfs(root->left, path);
    path.erase(len);  // 需要手动恢复现场
}
```

**选择建议**：
- 路径较短 → 值传递（代码简洁）
- 路径很长 → 引用传递（性能优）

#### **5. 全局变量在递归中的应用**

**适用场景**：
- 需要在递归过程中累积信息（计数、收集结果）
- 避免复杂的参数传递

**本日使用的全局变量**：
```cpp
// 98题：记录前一个访问的节点值
long prev = LONG_MIN;

// 230题：记录访问次数和答案
int count = 0;
int result = 0;

// 257题：收集所有路径
vector<string> ret;
```

### 易错点

#### **1. BST定义理解错误**
```cpp
// ❌ 错误：使用 >= 允许了相等
if(root->val >= prev)

// ✅ 正确：BST要求严格递增
if(root->val > prev)
```
**教训**：BST不允许重复值，必须严格大于/小于

#### **2. 递归出口设置不当**
```cpp
// ❌ 错误：提前返回叶子节点，未判断是否应该删除
if(root->left == nullptr && root->right == nullptr) 
    return root;

// ✅ 正确：统一判断删除条件
if(root->left == nullptr && root->right == nullptr && root->val == 0)
    return nullptr;
return root;
```
**教训**：不要提前返回未经完整判断的结果

#### **3. 空指针访问**
```cpp
// ❌ 错误：直接访问可能为空的指针
if(root->left->val == 0) { ... }

// ✅ 正确：先检查指针是否为空
if(root->left != nullptr && root->left->val == 0) { ... }

// ✅ 更好：直接检查指针
if(root->left == nullptr) { ... }
```
**教训**：访问指针成员前，必须先确保指针非空

#### **4. C++ 空指针表示**
```cpp
nullptr  // ✅ C++11推荐，类型安全
NULL     // C风格宏定义（值为0）
null     // ❌ 不存在！这是Java/JavaScript的写法
```
**教训**：不同语言的语法细节要注意区分

### 收获与反思

#### **今日最大收获**

1. **深刻理解了递归返回值的语义一致性**
   - 函数语义必须明确定义
   - 每个返回点的含义要完全一致
   - 不能提前返回未经完整判断的结果

2. **掌握了BST的核心性质及应用**
   - 中序遍历 = 严格递增序列
   - 这个性质可以解决很多BST相关问题
   - 验证、查找、排序都可以用这个性质

3. **理解了值传递实现自动回溯的技巧**
   - 值传递每次复制，天然实现回溯
   - 代码更简洁，不需要手动恢复现场
   - 但要注意性能开销（长路径时用引用）

#### **调试技巧进步**

- 提前返回要慎重，确保语义一致性
- 画递归树帮助理解执行流程
- 用具体例子模拟代码执行过程

#### **下次改进方向**

1. 递归函数设计前，先明确函数语义
2. 写递归出口时，检查所有返回点是否语义一致
3. 访问指针成员前，养成先判空的习惯
4. 多画图、多模拟，加深对递归过程的理解

---

**Day24圆满完成！** 🎉
- 4道题目全部AC
- 深入理解了二叉树递归和BST性质
- 掌握了递归返回值语义一致性的重要性

