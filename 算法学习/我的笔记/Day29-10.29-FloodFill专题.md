# Day29 - 10.29 FloodFill专题

> **主题**：网格DFS/BFS - FloodFill算法
> **核心目标**：掌握FloodFill算法的模板和应用场景

---

## 📚 FloodFill算法简介

**什么是FloodFill？**
- 图像处理中的"油漆桶"工具
- 从起点出发，将所有连通的相同颜色区域填充为新颜色
- 核心：**DFS/BFS遍历连通区域**

**经典应用场景**：
1. 图像渲染（填充颜色）
2. 岛屿问题（连通区域计数/面积）
3. 区域标记（被围绕的区域）
4. 边界问题（飞地、水流问题）

**两种实现方式**：
- **DFS（深度优先）**：递归实现，代码简洁
- **BFS（广度优先）**：队列实现，层序遍历

---

## 🎯 今日题目列表

### 1️⃣ 基础题（必做）
- [x] **LeetCode 733 - 图像渲染** (easy) ⭐⭐⭐
- [x] **LeetCode 200 - 岛屿数量** (medium) ⭐⭐⭐
- [x] **LeetCode 695 - 岛屿的最大面积** (medium) ⭐⭐⭐

### 2️⃣ 进阶题（选做）
- [x] **LeetCode 130 - 被围绕的区域** (medium) ⭐⭐
- [ ] **LeetCode 1020 - 飞地的数量** (medium) ⭐⭐
- [x] **LeetCode 417 - 太平洋大西洋水流问题** (medium) ⭐⭐⭐

---

## 1. LeetCode 733 - 图像渲染

### 📌 题目信息
- **难度**：Easy
- **标签**：DFS、BFS、数组、矩阵
- **链接**：[LeetCode 733](https://leetcode.com/problems/flood-fill/)

---

### 📋 题目描述

有一幅以 `m x n` 的二维整数数组表示的图画 `image`，其中 `image[i][j]` 表示该图画的像素值大小。

你也被给予三个整数 `sr`, `sc` 和 `newColor`。你应该从像素 `image[sr][sc]` 开始对图像进行**上色填充**。

为了完成**上色工作**，从初始像素开始，记录初始坐标的**上下左右四个方向上**像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应**四个方向上**像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 `newColor`。

最后返回**经过上色渲染后的图像**。

**示例 1：**
```
输入：image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, newColor = 2
输出：[[2,2,2],[2,2,0],[2,0,1]]
解释：
在图像的正中间，(坐标(sr,sc)=(1,1))，在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。
```

**示例 2：**
```
输入：image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, newColor = 0
输出：[[0,0,0],[0,0,0]]
解释：初始像素已经是目标颜色，无需修改。
```

**提示：**
- `m == image.length`
- `n == image[i].length`
- `1 <= m, n <= 50`
- `0 <= image[i][j], newColor < 2^16`
- `0 <= sr < m`
- `0 <= sc < n`

---

### 🔑 解题思路

**核心思想**：
- FloodFill算法 = DFS填充连通区域
- 从起点出发，将所有颜色为`oldColor`的连通格子填充为`newColor`

**关键点**：
1. 只填充与初始颜色相同的格子
2. 直接修改原数组（修改即标记已访问）
3. **不需要恢复现场**（填充是永久的）
4. **特殊情况**：如果初始色就是目标色，直接返回（避免无限递归）

**递归设计**：
```cpp
void dfs(image, i, j, oldColor, newColor)
功能：从(i,j)出发，填充所有oldColor的连通格子为newColor
```

**递归出口**：
1. 越界：`i < 0 || i >= m || j < 0 || j >= n`
2. 颜色不同：`image[i][j] != oldColor`（包括已访问和其他颜色）

---

### 初始代码/错误代码

**版本1：判断条件错误**
```cpp
class Solution {
public:
    bool vis[51][51];
    int m, n;
    int init;
    
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        m = image.size();
        n = image[0].size();
        memset(vis, false, sizeof(vis));
        init = image[sr][sc];
        dfs(image, sr, sc, color);
        return image;
    }
    
    void dfs(vector<vector<int>>& image, int i, int j, int color) {
        if(i < 0 || i >= m || j < 0 || j >= n) return;
        
        // ❌ 错误：判断条件不对
        if(vis[i][j] || image[i][j] == color) return;
        
        vis[i][j] = true;
        if(image[i][j] == init)  // 多余的判断
            image[i][j] = color;
        
        dfs(image, i-1, j, color);
        dfs(image, i+1, j, color);
        dfs(image, i, j-1, color);
        dfs(image, i, j+1, color);
    }
};
```

---

### 错误分析

**错误1：判断条件 `image[i][j] == color` 不正确**

```cpp
if(vis[i][j] || image[i][j] == color) return;
```

**问题**：
- 这个条件只判断了"是否已填充为目标色"
- **没有判断"是否是要填充的颜色"**

**错误示例**（image = [[1,1,1],[1,1,0],[1,0,1]], init=1, color=2）：
```
遇到格子值为0时：
- vis[i][j] = false ✓
- image[i][j] == color? → 0 == 2? ✗
- 条件不满足，继续执行！
- 标记 vis[i][j] = true
- 判断 image[i][j] == init? → 0 == 1? ✗，不修改
- **继续递归四个方向** ← 错误！不应该对0进行递归
```

**后果**：
- 遇到其他颜色时，虽然不会修改，但会继续递归
- 浪费时间，且可能导致逻辑错误

**正确条件应该是**：
```cpp
if(vis[i][j] || image[i][j] != init) return;  // ✅ 判断是否是初始色
```

---

**错误2：使用了多余的vis数组**

FloodFill不需要vis数组，因为：
- 修改颜色本身就是"标记已访问"
- `image[i][j] != init` 可以同时过滤：
  - 已访问的格子（已改成newColor）
  - 其他颜色的格子（本来就不是init）

---

### 正确代码

**方法：DFS + 直接修改（无需vis数组）**

```cpp
class Solution {
public:
    int m, n;
    int init;
    
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        // ⭐ 特殊情况：如果初始色就是目标色，直接返回（避免无限递归）
        if(image[sr][sc] == color) return image;
        
        m = image.size();
        n = image[0].size();
        init = image[sr][sc];  // 记录初始颜色
        
        dfs(image, sr, sc, color);
        return image;
    }
    
    void dfs(vector<vector<int>>& image, int i, int j, int color) {
        // 递归出口1：越界
        if(i < 0 || i >= m || j < 0 || j >= n) return;
        
        // 递归出口2：颜色不是初始色（已访问或其他颜色）
        if(image[i][j] != init) return;
        
        // 填充当前格子（同时标记已访问）
        image[i][j] = color;
        
        // 向四个方向递归
        dfs(image, i-1, j, color);  // 上
        dfs(image, i+1, j, color);  // 下
        dfs(image, i, j-1, color);  // 左
        dfs(image, i, j+1, color);  // 右
        
        // ❌ 不需要恢复现场！（填充是永久操作）
    }
};
```

**代码要点**：
1. ✅ 主函数判断 `image[sr][sc] == color`（避免无限递归）
2. ✅ 递归出口判断 `image[i][j] != init`（精准过滤）
3. ✅ 直接修改原数组（无需vis数组）
4. ✅ 不需要恢复现场（FloodFill是填充操作，不是搜索）

---

### 核心知识点

#### **1. FloodFill vs 网格DFS的区别**

| 特性 | 单词搜索/黄金矿工 | FloodFill |
|------|------------------|-----------|
| 目标 | 找路径/求最优 | 填充区域 |
| 需要回溯 | ✅ | ❌ |
| vis数组 | ✅ 需要 | ❌ 不需要 |
| 修改原数组 | ❌ | ✅ |

**核心区别**：
- 网格DFS：需要尝试多条路径，所以要回溯
- FloodFill：只走一次，填充后不回头 ✨

---

#### **2. 为什么不需要vis数组？**

```cpp
// 方法1：使用vis数组
if(vis[i][j]) return;
vis[i][j] = true;
image[i][j] = color;

// 方法2：直接修改（更简洁）✅
if(image[i][j] != init) return;  // 已修改的自然不满足
image[i][j] = color;
```

**原因**：修改颜色 = 标记已访问

---

#### **3. 关键特判：oldColor == newColor**

```cpp
// ❌ 没有特判会导致无限递归
void dfs(image, i, j, color) {
    if(image[i][j] != init) return;  // init = color = 2
    image[i][j] = color;             // 修改后还是2
    dfs(...);                        // image[i][j] != init? → 2 != 2? ✗
                                     // 继续递归！无限循环！
}

// ✅ 主函数提前判断
if(image[sr][sc] == color) return image;
```

---

#### **4. FloodFill的判断条件**

**错误判断**：
```cpp
if(image[i][j] == color) return;  // ❌ 只判断"是否已填充"
```

**正确判断**：
```cpp
if(image[i][j] != init) return;   // ✅ 判断"是否是要填充的颜色"
```

**区别**：
- 第一种：遇到其他颜色时会继续递归（浪费）
- 第二种：遇到其他颜色直接返回（高效）

---

#### **5. 方向数组优化（可选）**

```cpp
// 原始写法
dfs(image, i-1, j, color);
dfs(image, i+1, j, color);
dfs(image, i, j-1, color);
dfs(image, i, j+1, color);

// 优化写法（使用方向数组）
int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};
for(int k = 0; k < 4; k++) {
    dfs(image, i + dx[k], j + dy[k], color);
}
```

---

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(m×n) 递归栈

---

## 2. LeetCode 200 - 岛屿数量

### 📌 题目信息
- **难度**：Medium
- **标签**：DFS、BFS、并查集
- **链接**：[LeetCode 200](https://leetcode.com/problems/number-of-islands/)

---

### 📋 题目描述

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**
```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**
```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**提示：**
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`

---

### 🔑 解题思路

**核心思想**：
- 岛屿数量 = FloodFill填充的次数
- 遍历整个网格，每次遇到未访问的陆地'1'时：
  1. 岛屿计数 +1
  2. 用FloodFill把整个岛屿"沉没"（标记为已访问）

**与图像渲染的区别**：
- 图像渲染：填充**一个**连通区域
- 岛屿数量：计数有**多少个**连通区域

**算法流程**：
```
1. 双重循环遍历整个网格
2. 遇到 '1' 且未访问时：
   a. ret++（发现一个新岛屿）
   b. dfs(i,j)（沉没整个岛屿）
3. 返回 ret
```

**递归函数设计**：
```cpp
void dfs(grid, i, j)
功能：从(i,j)出发，标记整个岛屿为已访问
```

---

### 初始代码/错误代码

**版本1：字符类型判断错误（栈溢出）**
```cpp
class Solution {
public:
    bool vis[301][301];
    int m, n;
    int ret = 0;
    
    int numIslands(vector<vector<char>>& grid) {
        m = grid.size();
        n = grid[0].size();
        memset(vis, false, sizeof(vis));
        
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                // ❌ 错误：缺少大括号，ret++在if外
                if(grid[i][j] != 0 && vis[i][j] != true)  // ❌ 应该是 '0'
                    dfs(grid, i, j);
                    ret++;  // ❌ 每次循环都执行！
            }
        }
        return ret;
    }
    
    void dfs(vector<vector<char>>& grid, int i, int j) {
        if(i < 0 || i >= m || j < 0 || j >= n) return;
        
        // ❌ 致命错误！导致栈溢出
        if(vis[i][j] || grid[i][j] == 0) return;  // 应该是 '0'
        
        if(grid[i][j] == 1)  // ❌ 应该是 '1'
            vis[i][j] = true;
        
        dfs(grid, i-1, j);
        dfs(grid, i+1, j);
        dfs(grid, i, j-1);
        dfs(grid, i, j+1);
    }
};
```

---

### 错误分析

**错误1：字符 vs 整数比较错误（导致栈溢出）** ⭐⭐⭐

```cpp
// ❌ 错误代码
if(grid[i][j] == 0) return;  // 整数0
```

**根本问题**：
- `grid` 类型是 `vector<vector<char>>&`
- 元素是**字符类型**：`'0'`（ASCII=48）和 `'1'`（ASCII=49）
- 不是**整数类型**：`0` 和 `1`

**栈溢出原因**：
```
判断：grid[i][j] == 0
- grid[i][j] = '0' → 48 == 0? ✗ 不相等！
- grid[i][j] = '1' → 49 == 0? ✗ 不相等！

结果：出口2永远不触发
→ 遇到'0'（水）时继续递归
→ 无限递归
→ 栈溢出！💥
```

**正确写法**：
```cpp
if(grid[i][j] == '0') return;  // ✅ 字符'0'（有单引号）
```

---

**错误2：缺少大括号导致逻辑错误**

```cpp
// ❌ 错误代码
if(grid[i][j] != 0 && vis[i][j]!=true)
    dfs(grid,i,j);  // 只有这行在if内
    ret++;          // ❌ 这行不在if内！
```

**问题**：
- 没有使用大括号 `{}`
- `ret++` 不在if语句块内
- 导致每次循环都执行 `ret++`
- 无论是否是岛屿，都会计数

**正确写法**：
```cpp
if(grid[i][j] == '1' && !vis[i][j]) {  // ✅ 加大括号
    dfs(grid, i, j);
    ret++;
}
```

---

**错误3：多余的判断**

```cpp
// ❌ 多余的判断
if(grid[i][j] == 1)  // 错误的字符判断
    vis[i][j] = true;
```

**问题**：
- 出口2已经判断了 `grid[i][j] == '0'`
- 能执行到这里的一定是'1'
- 这个判断是多余的

---

### 正确代码

**方法：DFS + FloodFill计数**

```cpp
class Solution {
public:
    bool vis[301][301];
    int m, n;
    
    int numIslands(vector<vector<char>>& grid) {
        m = grid.size();
        n = grid[0].size();
        memset(vis, false, sizeof(vis));
        
        int ret = 0;  // 岛屿计数
        
        // 遍历整个网格
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                // ⭐ 发现未访问的陆地
                if(grid[i][j] == '1' && !vis[i][j]) {  // ✅ 字符'1'
                    dfs(grid, i, j);  // 沉没整个岛屿
                    ret++;            // 岛屿计数+1
                }
            }
        }
        return ret;
    }
    
    void dfs(vector<vector<char>>& grid, int i, int j) {
        // 出口1：越界
        if(i < 0 || i >= m || j < 0 || j >= n) return;
        
        // 出口2：已访问 或 不是陆地（水）
        if(vis[i][j] || grid[i][j] == '0') return;  // ✅ 字符'0'
        
        // 标记当前位置（沉没这块陆地）
        vis[i][j] = true;
        
        // 向四个方向探索（沉没整个岛屿）
        dfs(grid, i-1, j);  // 上
        dfs(grid, i+1, j);  // 下
        dfs(grid, i, j-1);  // 左
        dfs(grid, i, j+1);  // 右
    }
};
```

**代码要点**：
1. ✅ 主函数双重循环遍历
2. ✅ 判断 `grid[i][j] == '1'`（字符类型）
3. ✅ 使用大括号包裹if语句块
4. ✅ dfs函数沉没整个岛屿
5. ✅ 每发现一个新岛屿，ret++

---

### 核心知识点

#### **1. 岛屿数量 = FloodFill计数**

```cpp
// 图像渲染（LeetCode 733）
FloodFill一次 → 填充一个连通区域

// 岛屿数量（LeetCode 200）
循环 + FloodFill → 计数连通区域的数量

for (遍历所有格子) {
    if (未访问的陆地) {
        FloodFill();  // 沉没整个岛屿
        count++;      // 计数+1
    }
}
```

---

#### **2. 字符类型 vs 整数类型** ⭐⭐⭐

| 写法 | 类型 | ASCII码 | 比较结果 |
|------|------|---------|----------|
| `'0'` | 字符 | 48 | `'0' == 0` → false |
| `'1'` | 字符 | 49 | `'1' == 1` → false |
| `0` | 整数 | 0 | `0 == 0` → true |
| `1` | 整数 | 1 | `1 == 1` → true |

**记忆技巧**：
- 看到 `vector<vector<char>>&` → 用字符 `'0'`, `'1'`（有引号）
- 看到 `vector<vector<int>>&` → 用整数 `0`, `1`（无引号）

---

#### **3. if语句必须加大括号** ⭐

```cpp
// ❌ 危险写法（易错）
if(condition)
    statement1;  // 在if内
    statement2;  // ❌ 不在if内！

// ✅ 安全写法（推荐）
if(condition) {
    statement1;
    statement2;
}  // 都在if内
```

**规范**：**即使只有一条语句，也要加大括号！**

---

#### **4. 岛屿问题的通用思路**

```
1. 遍历整个网格
2. 遇到未访问的陆地：
   a. 计数/记录
   b. DFS/BFS标记整个岛屿
3. 返回结果
```

**变体**：
- 岛屿数量（本题）：计数
- 岛屿面积（下一题）：累加面积
- 岛屿周长：计算边界

---

#### **5. vis数组 vs 修改原数组**

**方法1：使用vis数组（本题方法）**
```cpp
bool vis[m][n];
if(vis[i][j]) return;
vis[i][j] = true;
```

**方法2：直接修改原数组**
```cpp
if(grid[i][j] == '0') return;
grid[i][j] = '0';  // 将'1'改成'0'（沉没）
```

**对比**：
- 方法1：不修改原数组，空间O(m×n)
- 方法2：修改原数组，空间O(1)（不算递归栈）

---

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(m×n) vis数组 + 递归栈

---

## 3. LeetCode 695 - 岛屿的最大面积

### 📌 题目信息
- **难度**：Medium
- **标签**：DFS、BFS、数组、矩阵
- **链接**：[LeetCode 695](https://leetcode.com/problems/max-area-of-island/)

---

### 📋 题目描述

给你一个大小为 `m x n` 的二进制矩阵 `grid`。

**岛屿**是由一些相邻的 `1`（代表土地）构成的组合，这里的「相邻」要求两个 `1` 必须在**水平或者竖直的四个方向上**相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0`。

**示例 1：**
```
输入：grid = [
  [0,0,1,0,0,0,0,1,0,0,0,0,0],
              [0,0,0,0,0,0,0,1,1,1,0,0,0],
              [0,1,1,0,1,0,0,0,0,0,0,0,0],
              [0,1,0,0,1,1,0,0,1,0,1,0,0],
              [0,1,0,0,1,1,0,0,1,1,1,0,0],
              [0,0,0,0,0,0,0,0,0,0,1,0,0],
              [0,0,0,0,0,0,0,1,1,1,0,0,0],
  [0,0,0,0,0,0,0,1,1,0,0,0,0]
]
输出：6
解释：答案不应该是11，因为岛屿只能包含水平或垂直这四个方向上的1。
```

**示例 2：**
```
输入：grid = [[0,0,0,0,0,0,0,0]]
输出：0
```

**提示：**
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 50`
- `grid[i][j]` 为 `0` 或 `1`

---

### 🔑 解题思路

**核心思想**：
- 岛屿最大面积 = 遍历所有岛屿，求最大的面积
- 结合前两题：
  - 图像渲染（733）：填充一个区域
  - 岛屿数量（200）：计数多少个区域
  - **岛屿面积（695）**：求最大的区域面积

**与Day28黄金矿工的相似性** ⭐⭐⭐：
```
黄金矿工：遍历所有路径，求最大金子数
岛屿面积：遍历所有岛屿，求最大面积

都是：void + 全局变量 + 遍历所有可能
```

**算法流程**：
```
1. 遍历整个网格
2. 遇到未访问的陆地：
   a. tmp = 0（重置当前岛屿面积）
   b. dfs(i, j)（用dfs累加面积到tmp）
   c. maxret = max(maxret, tmp)（更新最大值）
3. 返回 maxret
```

**递归函数设计**：
```cpp
void dfs(grid, i, j)
功能：从(i,j)出发，累加整个岛屿的面积到全局变量tmp
```

**关键点**：
- 使用全局变量 `tmp` 累加当前岛屿面积
- 每次进入新岛屿前，重置 `tmp = 0`
- 使用全局变量 `maxret` 记录最大面积

---

### 初始代码/错误代码
```cpp
// 一次AC，无错误代码
```

---

### 错误分析

无错误，一次AC ✅

**用时**：7分23秒

---

### 正确代码

**方法：DFS + 全局变量累加（void返回值）**

```cpp
class Solution {
public:
    int maxret = 0;  // 全局最大面积
    int tmp = 0;     // 当前岛屿面积
    int m, n;
    bool vis[51][51];
    
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        m = grid.size();
        n = grid[0].size();
        memset(vis, false, sizeof(vis));
        
        // 遍历整个网格
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                // 发现未访问的陆地
                if(vis[i][j] == false && grid[i][j] == 1) {
                    dfs(grid, i, j);             // 累加面积到tmp
                    maxret = max(tmp, maxret);   // 更新最大值
                    tmp = 0;                     // ⭐ 重置tmp
                }
            }
        }
        return maxret;
    }
    
    void dfs(vector<vector<int>>& grid, int i, int j) {
        // 出口1：越界
        if(i < 0 || i >= m || j < 0 || j >= n) return;
        
        // 出口2：已访问 或 不是陆地
        if(vis[i][j] || grid[i][j] == 0) return;
        
        // 累加面积
        tmp += 1;
        
        // 标记已访问
        vis[i][j] = true;
        
        // 向四个方向探索
        dfs(grid, i-1, j);
        dfs(grid, i+1, j);
        dfs(grid, i, j-1);
        dfs(grid, i, j+1);
    }
};
```

**代码要点**：
1. ✅ 使用 `void` 返回值（不需要返回，用全局变量记录）
2. ✅ `tmp` 累加当前岛屿面积
3. ✅ **每次进入新岛屿前重置 `tmp = 0`** ⭐
4. ✅ `maxret` 记录全局最大值
5. ✅ 遍历所有岛屿，求最大值

---

### 核心知识点

#### **1. 岛屿问题的三种变体**

| 题目 | 目标 | 返回值 | 关键变量 |
|------|------|--------|----------|
| LeetCode 733 | 填充一个区域 | `void` | 无 |
| LeetCode 200 | 计数多少个区域 | `void` | `ret`（计数） |
| **LeetCode 695** | **求最大区域面积** | **`void`** | **`tmp` + `maxret`** |

---

#### **2. void vs int返回值（两种实现方式）**

**方法1：void + 全局变量（本题方法）** ⭐

```cpp
int tmp = 0;     // 当前面积
int maxret = 0;  // 最大面积

void dfs(grid, i, j) {
    tmp += 1;  // 累加到全局变量
    // 递归四个方向
}

// 主函数
for (...) {
    dfs(i, j);
    maxret = max(tmp, maxret);
    tmp = 0;  // ⭐ 重置
}
```

**方法2：int + 返回值（也可以）**

```cpp
int dfs(grid, i, j) {
    if (越界或不合法) return 0;
    
    int area = 1;  // 当前格子
    // 累加四个方向
    area += dfs(grid, i-1, j);
    area += dfs(grid, i+1, j);
    area += dfs(grid, i, j-1);
    area += dfs(grid, i, j+1);
    
    return area;
}

// 主函数
for (...) {
    int area = dfs(i, j);
    maxret = max(area, maxret);
}
```

**对比**：
| 特性 | void + 全局变量 | int + 返回值 |
|------|----------------|-------------|
| 代码风格 | 类似黄金矿工 | 类似递归求和 |
| 需要重置 | ✅ 需要 `tmp = 0` | ❌ 不需要 |
| 理解难度 | 稍难（全局状态） | 更直观 |
| 性能 | 相同 | 相同 |

---

#### **3. 与Day28黄金矿工的联系** ⭐⭐⭐

```cpp
// 黄金矿工（LeetCode 1219）
int maxret = 0;
int tmp = 0;

void dfs(grid, i, j) {
    tmp += grid[i][j];  // 累加金子
    // ... 递归 ...
}

for (...) {
    dfs(i, j);
    maxret = max(tmp, maxret);
    tmp = 0;  // 重置
}

// 岛屿最大面积（LeetCode 695）
int maxret = 0;
int tmp = 0;

void dfs(grid, i, j) {
    tmp += 1;  // 累加面积
    // ... 递归 ...
}

for (...) {
    dfs(i, j);
    maxret = max(tmp, maxret);
    tmp = 0;  // 重置
}
```

**核心相似点**：
1. ✅ 都用 `void` 返回值
2. ✅ 都用全局变量累加（`tmp`）
3. ✅ 都用全局变量记录最大值（`maxret`）
4. ✅ 都需要重置 `tmp`

**本质理解**：
- 遍历所有可能，求最优解 → void + 全局变量
- 有全局变量记录状态 → 不需要返回值传递

---

#### **4. 关键细节：重置tmp** ⭐

```cpp
for(int i = 0; i < m; i++) {
    for(int j = 0; j < n; j++) {
        if(未访问的陆地) {
            dfs(grid, i, j);             // 累加到tmp
            maxret = max(tmp, maxret);   // 更新最大值
            tmp = 0;  // ⭐ 必须重置！为下一个岛屿做准备
        }
    }
}
```

**为什么要重置？**
```
第1个岛屿：tmp = 5 → maxret = 5
不重置：tmp = 5
第2个岛屿：tmp = 5 + 3 = 8 → maxret = 8 ❌ 错误！

正确：
第1个岛屿：tmp = 5 → maxret = 5 → tmp = 0
第2个岛屿：tmp = 3 → maxret = 5 ✅
```

---

#### **5. 岛屿问题通用模板**

```cpp
// 通用框架
for(int i = 0; i < m; i++) {
    for(int j = 0; j < n; j++) {
        if(未访问的陆地) {
            // 根据题目要求：
            // - 计数：ret++
            // - 求面积：tmp=0; dfs(); maxret=max(tmp, maxret); tmp=0;
            dfs(i, j);
        }
    }
}

void dfs(i, j) {
    // 出口：越界、已访问、不是陆地
    if(...) return;
    
    // 标记
    vis[i][j] = true;
    
    // 根据题目要求累加
    // - 求面积：tmp++
    // - 求周长：统计边界
    
    // 四个方向
    dfs(i-1, j); dfs(i+1, j);
    dfs(i, j-1); dfs(i, j+1);
}
```

---

### 提交结果
- 提交时间：AC ✅（一次通过）
- 执行用时：7分23秒
- 内存消耗：O(m×n) vis数组 + 递归栈

---

## 4. LeetCode 130 - 被围绕的区域

### 📌 题目信息
- **难度**：Medium
- **标签**：DFS、BFS、并查集
- **链接**：[LeetCode 130](https://leetcode.com/problems/surrounded-regions/)

---

### 📋 题目描述

给你一个 `m x n` 的矩阵 `board`，由若干字符 `'X'` 和 `'O'` 组成，**捕获** 所有 **被围绕的区域**。

**被围绕的区域**：如果一个区域内所有 `'O'` 的**上下左右**都被 `'X'` 包围，那么这个区域是**被围绕的**。被围绕的区域需要被改为 `'X'`。

**不被围绕的区域**：与边界连通的 `'O'` 不算被围绕。

**示例 1：**
```
输入：board = [
  ["X","X","X","X"],
              ["X","O","O","X"],
              ["X","X","O","X"],
  ["X","O","X","X"]
]
输出：[
              ["X","X","X","X"],
              ["X","X","X","X"],
  ["X","X","X","X"],
  ["X","O","X","X"]
]
解释：
被围绕的区域不应该存在于边界上。
任何与边界上的 'O' 连通的 'O' 也不会被改成 'X'。
board[1][1], board[1][2] 被围绕了，改成 'X'。
board[3][1] 与边界连通，保留为 'O'。
```

**示例 2：**
```
输入：board = [["X"]]
输出：[["X"]]
```

**提示：**
- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 200`
- `board[i][j]` 为 `'X'` 或 `'O'`

---

### 🔑 解题思路

**核心难点**：如何判断一个O是否"被围绕"？

**错误思路（正向）**：
```
遍历内部的O，判断它是否被X完全包围
→ 很难判断！需要递归检查是否能到达边界
```

**正确思路（反向思维）** ⭐⭐⭐：
```
1. 找出"不被围绕的O"（与边界连通的O）
2. 标记这些"不被围绕的O"
3. 把所有未标记的O改成X
```

**关键理解**：
```
被围绕的O = 无法到达边界的O
↓（反过来）
不被围绕的O = 从边界出发能到达的O
```

---

**算法流程（三步法）**：

**Step 1：从四条边界出发，DFS标记所有"不被围绕的O"**
```cpp
// 遍历四条边
for(左右边界) {
    if(board[i][边界] == 'O') 
        dfs(标记为'#');  // 用#临时标记
}
for(上下边界) {
    if(board[边界][j] == 'O') 
        dfs(标记为'#');
}
```

**Step 2：DFS递归标记连通的O**
```cpp
void dfs(i, j) {
    board[i][j] = '#';  // 标记为"不被围绕"
    // 向四个方向继续标记
}
```

**Step 3：遍历整个board，统一处理**
```cpp
for(遍历所有格子) {
    if(board[i][j] == 'O') → 改成'X'（被围绕）
    if(board[i][j] == '#') → 改回'O'（不被围绕）
}
```

---

### 初始代码/错误代码

**版本1：正向思维（错误）**
```cpp
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        // ❌ 错误思路：遍历内部格子，判断是否被围绕
        for(int i = 1; i < m-1; i++) {
            for(int j = 1; j < n-1; j++) {
                if(board[i][j] == 'O') {
                    // 如何判断被围绕？很难！
                    dfs(board, i, j);
                }
            }
        }
    }
};
```

**问题**：
- 如何判断一个O是否"被围绕"？
- 需要检查这个O是否能到达边界 → 复杂！

---

### 错误分析

**为什么正向思维很难？**

```
判断"被围绕" = 判断"无法到达边界"
→ 需要对每个内部O进行一次完整的DFS
→ 时间复杂度高，逻辑复杂
```

**反向思维的优势**：
```
找"不被围绕的" = 从边界出发DFS
→ 只需要遍历四条边
→ 一次DFS标记所有边界连通的O
→ 简单高效！
```

---

### 正确代码

**方法：反向DFS + 临时标记**

```cpp
class Solution {
public:
    int m, n;
    
    void solve(vector<vector<char>>& board) {
        m = board.size();
        n = board[0].size();
        
        // Step 1：从四条边界出发，标记所有"不被围绕的O"
        
        // 遍历左右边界
        for(int i = 0; i < m; i++) {
            if(board[i][0] == 'O') dfs(board, i, 0);      // 左边界
            if(board[i][n-1] == 'O') dfs(board, i, n-1);  // 右边界
        }
        
        // 遍历上下边界
        for(int j = 0; j < n; j++) {
            if(board[0][j] == 'O') dfs(board, 0, j);      // 上边界
            if(board[m-1][j] == 'O') dfs(board, m-1, j);  // 下边界
        }
        
        // Step 2：遍历整个board，统一处理
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(board[i][j] == 'O') {
                    board[i][j] = 'X';  // 未标记的O → 被围绕 → 改成X
                } else if(board[i][j] == '#') {
                    board[i][j] = 'O';  // 标记的# → 不被围绕 → 恢复成O
                }
            }
        }
    }
    
    void dfs(vector<vector<char>>& board, int i, int j) {
        // 出口1：越界
        if(i < 0 || i >= m || j < 0 || j >= n) return;
        
        // 出口2：不是O（可能是X、#、或已访问）
        if(board[i][j] != 'O') return;
        
        // 标记为#（表示"不被围绕的O"）
        board[i][j] = '#';
        
        // 向四个方向继续标记
        dfs(board, i-1, j);
        dfs(board, i+1, j);
        dfs(board, i, j-1);
        dfs(board, i, j+1);
    }
};
```

**代码要点**：
1. ✅ **反向思维**：从边界出发找"不被围绕的"
2. ✅ **临时标记**：用'#'标记边界连通的O
3. ✅ **统一处理**：最后一次遍历统一改变
4. ✅ **不需要vis数组**：直接修改board作为标记

---

### 核心知识点

#### **1. 反向思维的应用** ⭐⭐⭐

```
正向思维（难）：
判断"被围绕" → 判断"无法到达边界" → 复杂

反向思维（巧）：
找"不被围绕" → 从边界出发DFS → 简单
```

**本质**：
- 被围绕 = 全集 - 不被围绕
- 先找容易找的，再用全集减去

---

#### **2. 临时标记技巧**

```cpp
// 第一阶段：标记
board[i][j] = '#';  // O → # (不被围绕)

// 第二阶段：统一处理
if(board[i][j] == 'O') → 'X'  // 被围绕
if(board[i][j] == '#') → 'O'  // 恢复
```

**为什么用临时标记？**
- 区分"边界连通的O"和"内部的O"
- 避免标记被覆盖

---

#### **3. 图解示例**

**原始board**：
```
X X X X
X O O X
X X O X
X O X X
```

**Step 1：从边界DFS标记**：
```
X X X X
X O O X
X X # X    ← board[2][2]能从board[3][1]到达
X # X X    ← board[3][1]是边界O，标记为#
```

**Step 2：统一处理**：
```
X X X X
X X X X    ← 内部的O改成X（被围绕）
X X O X    ← #恢复成O（不被围绕）
X O X X    ← #恢复成O（不被围绕）
```

---

#### **4. 与前面题目的对比**

| 题目 | 遍历起点 | 判断条件 | 目标 |
|------|---------|---------|------|
| 图像渲染 | 指定起点 | 颜色相同 | 填充区域 |
| 岛屿数量 | 遍历所有格子 | 未访问的1 | 计数 |
| 岛屿面积 | 遍历所有格子 | 未访问的1 | 求最大 |
| **被围绕区域** | **只遍历边界** | **边界的O** | **反向标记** |

**核心区别**：
- 前三题：遍历所有格子
- 被围绕区域：**只遍历边界** ⭐

---

#### **5. 边界遍历的技巧**

```cpp
// 左右边界（固定列，遍历行）
for(int i = 0; i < m; i++) {
    if(board[i][0] == 'O') dfs(board, i, 0);      // 左：j=0
    if(board[i][n-1] == 'O') dfs(board, i, n-1);  // 右：j=n-1
}

// 上下边界（固定行，遍历列）
for(int j = 0; j < n; j++) {
    if(board[0][j] == 'O') dfs(board, 0, j);      // 上：i=0
    if(board[m-1][j] == 'O') dfs(board, m-1, j);  // 下：i=m-1
}
```

**注意**：四个角会被遍历两次，但因为有标记，不会重复处理

---

#### **6. 不需要vis数组**

```cpp
// 方法1：使用vis数组
bool vis[m][n];
if(vis[i][j]) return;
vis[i][j] = true;

// 方法2：直接修改board（本题方法）✅
if(board[i][j] != 'O') return;  // 'X'或'#'都返回
board[i][j] = '#';  // 修改作为标记
```

**为什么不需要vis？**
- 用'#'标记，天然避免重复访问
- 最后统一恢复

---

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(m×n) 递归栈

---

## 5. LeetCode 417 - 太平洋大西洋水流问题

### 📌 题目信息
- **难度**：Medium
- **标签**：DFS、BFS、数组、矩阵、反向思维
- **链接**：[LeetCode 417](https://leetcode.com/problems/pacific-atlantic-water-flow/)

---

### 📋 题目描述

有一个 `m × n` 的矩形岛屿，与**太平洋**和**大西洋**相邻：
- **太平洋**：处于岛屿的**左边界**和**上边界**
- **大西洋**：处于岛屿的**右边界**和**下边界**

给定一个 `m x n` 的整数矩阵 `heights`，`heights[r][c]` 表示坐标 `(r, c)` 上单元格高于海平面的高度。

岛上雨水较多，如果相邻单元格的高度**小于或等于**当前单元格的高度，雨水可以直接向**北、南、东、西**流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

**返回**网格坐标 `result` 的 2D 列表，其中 `result[i] = [ri, ci]` 表示雨水从单元格 `(ri, ci)` 流动**既可流向太平洋也可流向大西洋**。

**示例**：
```
输入: heights = [[1,2,2,3,5],
                 [3,2,3,4,4],
                 [2,4,5,3,1],
                 [6,7,1,4,5],
                 [5,1,1,2,4]]

输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

---

### 🤔 解题思路

#### **问题分析**

**正向思维（难）** ❌：
```
从每个格子出发 → 判断能否到达太平洋
               → 判断能否到达大西洋
               → 都能到达则加入结果

问题：
- 需要遍历 m×n 次
- 每次都要DFS判断两个方向
- 重复计算太多！
```

**反向思维（巧）** ✅：
```
问题转化：
"哪些点能流向太平洋？" → 从太平洋边界反向逆流！
"哪些点能流向大西洋？" → 从大西洋边界反向逆流！

最后：同时被两个大洋标记的点 = 答案
```

---

#### **核心关键点**

**1. 反向流动的条件**

正常流动：水从高处流向低处
```cpp
// 正向：h[当前] >= h[下一个]
if(h[next] <= h[cur]) → 可以流
```

反向流动：从低处（海洋）逆流而上
```cpp
// 反向：h[下一个] >= h[当前]
if(h[next] >= h[cur]) → 可以逆流到达
```

**2. 两个大洋的边界**

```
太平洋边界：
- 左边界：i ∈ [0, m), j = 0
- 上边界：i = 0, j ∈ [0, n)

大西洋边界：
- 右边界：i ∈ [0, m), j = n-1
- 下边界：i = m-1, j ∈ [0, n)
```

**3. 需要两个vis数组**

```cpp
pac[i][j] = true  // 能流向太平洋
atl[i][j] = true  // 能流向大西洋

// 同时为true → 答案
if(pac[i][j] && atl[i][j]) → 加入结果
```

---

#### **算法步骤**

```
Step 1：从太平洋边界（左边+上边）出发，反向DFS
        → 标记所有能流向太平洋的点到pac数组

Step 2：从大西洋边界（右边+下边）出发，反向DFS
        → 标记所有能流向大西洋的点到atl数组

Step 3：遍历所有格子，找出pac[i][j] && atl[i][j] 的点
```

---

### 💻 代码实现

```cpp
class Solution {
public:
    int m, n;
    int dx[4] = {-1, 1, 0, 0};   // 上、下、左、右
    int dy[4] = {0, 0, -1, 1};
    
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        m = heights.size();
        n = heights[0].size();

        // 1. 创建两个vis数组
        vector<vector<bool>> pac(m, vector<bool>(n));
        vector<vector<bool>> atl(m, vector<bool>(n));

        // 2. 从太平洋边界出发（左边+上边）
        for(int i = 0; i < m; i++) dfs(heights, i, 0, pac);      // 左边界
        for(int j = 0; j < n; j++) dfs(heights, 0, j, pac);      // 上边界
        
        // 3. 从大西洋边界出发（右边+下边）
        for(int i = 0; i < m; i++) dfs(heights, i, n-1, atl);    // 右边界
        for(int j = 0; j < n; j++) dfs(heights, m-1, j, atl);    // 下边界

        // 4. 找出同时满足的点
        vector<vector<int>> ret;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(pac[i][j] && atl[i][j]) {  // 同时能流向两个大洋
                    ret.push_back({i, j});
                }
            }
        }
        return ret;
    }
    
    void dfs(vector<vector<int>>& h, int i, int j, vector<vector<bool>>& vis) {
        // 出口1：越界
        if(i < 0 || i >= m || j < 0 || j >= n) return;
        // 出口2：已访问
        if(vis[i][j]) return;
        
        // 标记当前位置
        vis[i][j] = true;
        
        // 四个方向搜索（用dx/dy数组优化）
        for(int k = 0; k < 4; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            // ⭐ 关键：h[x][y] >= h[i][j]（逆流而上！）
            if(x >= 0 && x < m && y >= 0 && y < n && h[x][y] >= h[i][j]) {
                dfs(h, x, y, vis);
            }
        }
    }
};
```

**时间复杂度**：O(m×n)  
**空间复杂度**：O(m×n)

---

### 核心知识点

#### **1. 反向思维 = LeetCode 130的升级版** ⭐⭐⭐

| 题目 | 正向问题 | 反向问题 | 边界 |
|------|---------|---------|------|
| **LeetCode 130** | 找"被围绕的O" | 找"不被围绕的O" | 四条边 |
| **LeetCode 417** | 找"同时到达两洋" | 分别找"能到太平洋"和"能到大西洋" | **两组边界** |

**共同点**：
- 都是从边界出发反向DFS
- 都是标记特定区域
- 都避免了正向遍历的复杂判断

**区别**：
- LeetCode 130：1个vis（临时标记'#'）
- LeetCode 417：**2个vis**（pac、atl）

---

#### **2. dx/dy 方向数组的使用** ⭐⭐⭐

**传统写法 vs dx/dy写法**：

```cpp
// ❌ 传统写法：4个if语句，容易出错
if(i-1 >= 0 && h[i-1][j] >= h[i][j]) dfs(h, i-1, j, vis);
if(i+1 < m && h[i+1][j] >= h[i][j]) dfs(h, i+1, j, vis);
if(j-1 >= 0 && h[i][j-1] >= h[i][j]) dfs(h, i, j-1, vis);
if(j+1 < n && h[i][j+1] >= h[i][j]) dfs(h, i, j+1, vis);

// ✅ dx/dy写法：1个for循环，简洁优雅
int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};
for(int k = 0; k < 4; k++) {
    int x = i + dx[k];
    int y = j + dy[k];
    if(x >= 0 && x < m && y >= 0 && y < n && h[x][y] >= h[i][j]) {
        dfs(h, x, y, vis);
    }
}
```

**dx/dy数组的优势**：
1. ✅ **代码简洁**：4行变1个循环
2. ✅ **不易出错**：统一处理边界
3. ✅ **易于扩展**：改8方向只需改数组
4. ✅ **比特课程标准写法**

**记忆口诀**：
```
dx[4] = {-1, 1, 0, 0}  → 上下左右的"行"变化
dy[4] = {0, 0, -1, 1}  → 上下左右的"列"变化

对应：
k=0: (-1, 0) → 上
k=1: (1, 0)  → 下
k=2: (0, -1) → 左
k=3: (0, 1)  → 右
```

---

#### **3. 反向流动条件** ⭐⭐⭐

**正向流动**（从高流向低）：
```cpp
// 当前高度 >= 下一个高度 → 可以流
if(h[i][j] >= h[next_i][next_j]) → 可以流向next
```

**反向流动**（从低往高逆流）：
```cpp
// 下一个高度 >= 当前高度 → 可以逆流到达
if(h[next_i][next_j] >= h[i][j]) → 可以从当前逆流到next
```

**易错点**：
```cpp
// ❌ 错误：忘记改条件，还用正向流动
if(h[x][y] <= h[i][j]) dfs(...);  // 错！

// ✅ 正确：反向流动
if(h[x][y] >= h[i][j]) dfs(...);  // 对！
```

---

#### **4. 边界遍历的技巧**

```cpp
// 太平洋：左边界 + 上边界
for(int i = 0; i < m; i++) dfs(h, i, 0, pac);      // 左：固定j=0，遍历i
for(int j = 0; j < n; j++) dfs(h, 0, j, pac);      // 上：固定i=0，遍历j

// 大西洋：右边界 + 下边界
for(int i = 0; i < m; i++) dfs(h, i, n-1, atl);    // 右：固定j=n-1，遍历i
for(int j = 0; j < n; j++) dfs(h, m-1, j, atl);    // 下：固定i=m-1，遍历j
```

**注意**：
- 四个角会被遍历两次（如 `[0][0]` 被左边界和上边界都遍历）
- 但因为有 `vis[i][j]` 检查，不会重复处理 ✅

---

#### **5. 图解示例**

**原始heights**：
```
    0  1  2  3  4
0  [1  2  2  3  5]  ← 太平洋上边界
1  [3  2  3  4  4]
2  [2  4  5  3  1]
3  [6  7  1  4  5]
4  [5  1  1  2  4]  ← 大西洋下边界
   ↑              ↑
 太平洋         大西洋
 左边界         右边界
```

**Step 1：从太平洋边界标记（pac数组）**：
```
从左边界和上边界出发，逆流而上
pac = 能流向太平洋的点（标记为1）
```

**Step 2：从大西洋边界标记（atl数组）**：
```
从右边界和下边界出发，逆流而上
atl = 能流向大西洋的点（标记为1）
```

**Step 3：取交集**：
```
pac && atl = 同时能流向两个大洋的点
```

---

#### **6. 与LeetCode 130对比**

| 特性 | LeetCode 130 | LeetCode 417 |
|------|-------------|-------------|
| **目标** | 找被围绕的O | 找能到两洋的点 |
| **反向思维** | 找"不被围绕" | 分别找"到太平洋"和"到大西洋" |
| **vis数组** | 1个（临时标记'#'） | **2个**（pac、atl） |
| **边界** | 四条边 | **两组边界** |
| **DFS次数** | 1次 | **2次**（分别处理两个大洋） |
| **最终处理** | 统一修改 | 取交集 |
| **流动条件** | `board[x][y] == 'O'` | **`h[x][y] >= h[i][j]`** |

---

### 易错点记录

#### **易错点1：直接访问数组越界** ⚠️

```cpp
// ❌ 错误：先访问数组，再递归
if(h[i-1][j] >= h[i][j]) dfs(h, i-1, j, vis);  // i-1可能<0！

// ✅ 正确：先检查边界，再访问
int x = i - 1;
if(x >= 0 && x < m && h[x][j] >= h[i][j]) dfs(h, x, j, vis);

// ✅ 更好：用dx/dy数组
for(int k = 0; k < 4; k++) {
    int x = i + dx[k];
    if(x >= 0 && x < m && ...) dfs(...);
}
```

---

#### **易错点2：忘记改反向流动条件** ⚠️

```cpp
// ❌ 错误：用正向流动条件
if(h[x][y] <= h[i][j]) dfs(...);  // 这是正向流动！

// ✅ 正确：反向流动
if(h[x][y] >= h[i][j]) dfs(...);  // 逆流而上
```

---

#### **易错点3：边界遍历写错** ⚠️

```cpp
// ❌ 错误：左边界遍历j而不是i
for(int j = 0; j < n; j++) dfs(h, 0, j, pac);  // 这是上边界！

// ✅ 正确：左边界固定j=0，遍历i
for(int i = 0; i < m; i++) dfs(h, i, 0, pac);
```

---

### 提交结果
- 提交时间：一次AC ✅
- 执行用时：符合预期
- 内存消耗：O(m×n) × 2（两个vis数组）

---

## 今日总结

### 完成情况
✅ **5/6题完成！**

| 题目 | 难度 | 状态 | 核心技巧 |
|------|------|------|----------|
| ✅ LeetCode 733 | Easy | AC | FloodFill基础模板 |
| ✅ LeetCode 200 | Medium | AC | 字符判断、计数 |
| ✅ LeetCode 695 | Medium | 一次AC | void+全局变量 |
| ✅ LeetCode 130 | Medium | AC | **反向思维** ⭐ |
| ✅ LeetCode 417 | Medium | 一次AC | **反向思维+两个vis** ⭐⭐⭐ |

### 核心知识点

#### **1. FloodFill算法的五种应用**

```
1. 图像渲染（733）：填充一个连通区域
   - 从起点出发，填充颜色

2. 岛屿数量（200）：计数连通区域
   - 遍历所有格子，每个岛屿计数+1

3. 岛屿面积（695）：求最大连通区域
   - void + 全局变量累加面积

4. 被围绕区域（130）：反向标记
   - 从边界出发，标记"不被围绕的"

5. 太平洋大西洋水流（417）：反向思维进阶 ⭐⭐⭐
   - 两组边界，两个vis数组
   - 取交集找同时满足的点
```

---

#### **2. 反向思维的应用（两道题总结）** ⭐⭐⭐

| 题目 | 正向思维（难） | 反向思维（巧） | vis数组 |
|------|---------------|---------------|---------|
| **LeetCode 130** | 判断"被围绕" | 找"不被围绕" | 1个（'#'标记） |
| **LeetCode 417** | 同时到两洋 | 分别从两洋逆流 | **2个**（pac+atl） |

**反向思维的本质**：
- 找"好的" vs 找"坏的"
- 找"满足的" vs 找"不满足的"
- 从目标出发 vs 从起点出发
- **全集减去不满足的 = 满足的**

---

#### **3. 三种标记方式对比**

| 方式 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| vis数组 | 不修改原数组 | 额外空间O(m×n) | 需要保留原数组 |
| 直接修改 | 空间O(1) | 修改原数组 | 允许修改 |
| **临时标记** | **可恢复** | **需要两次遍历** | **需要区分多种状态** |

---

#### **4. 遍历起点的选择**

```cpp
// 全局遍历（大多数题目）
for(int i = 0; i < m; i++) {
    for(int j = 0; j < n; j++) {
        if(未访问的目标) dfs(i, j);
    }
}

// 边界遍历（特殊题目）✨
// 左右边界
for(int i = 0; i < m; i++) {
    if(board[i][0]) dfs(i, 0);
    if(board[i][n-1]) dfs(i, n-1);
}
// 上下边界
for(int j = 0; j < n; j++) {
    if(board[0][j]) dfs(0, j);
    if(board[m-1][j]) dfs(m-1, j);
}
```

---

### FloodFill算法模板

#### DFS模板
```cpp
// 方向数组
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

void dfs(vector<vector<int>>& grid, int i, int j, 原始值, 新值) {
    // 1. 边界检查
    if(越界 || 不满足条件) return;
    
    // 2. 标记/修改当前格子
    grid[i][j] = 新值;
    
    // 3. 向四个方向递归
    for(int k = 0; k < 4; k++) {
        int x = i + dx[k];
        int y = j + dy[k];
        dfs(grid, x, y, 原始值, 新值);
    }
}
```

#### BFS模板
```cpp
void bfs(vector<vector<int>>& grid, int sr, int sc, 原始值, 新值) {
    queue<pair<int, int>> q;
    q.push({sr, sc});
    grid[sr][sc] = 新值;
    
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};
    
    while(!q.empty()) {
        auto [i, j] = q.front();
        q.pop();
        
        for(int k = 0; k < 4; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            
            if(合法 && 满足条件) {
                grid[x][y] = 新值;
                q.push({x, y});
            }
        }
    }
}
```

#### **5. dx/dy方向数组** ⭐⭐⭐

**定义**：
```cpp
int dx[4] = {-1, 1, 0, 0};   // 上、下、左、右的行变化
int dy[4] = {0, 0, -1, 1};   // 上、下、左、右的列变化
```

**使用**：
```cpp
// 传统写法（4个if）
dfs(h, i-1, j, vis);
dfs(h, i+1, j, vis);
dfs(h, i, j-1, vis);
dfs(h, i, j+1, vis);

// dx/dy写法（1个for）⭐
for(int k = 0; k < 4; k++) {
    int x = i + dx[k];
    int y = j + dy[k];
    if(边界检查 && 条件检查) dfs(h, x, y, vis);
}
```

**优点**：
1. 代码简洁
2. 不易出错
3. 易于扩展（8方向只需改数组）
4. **比特课程标准写法**

---

### 易错点总结

#### **今日遇到的易错点**

**1. LeetCode 733 - 图像渲染**
- ❌ 错误：`if(vis[i][j] || image[i][j] == color) return;`
- ✅ 正确：`if(image[i][j] != init) return;`
- 💡 教训：FloodFill要判断原始色，不是新色

**2. LeetCode 200 - 岛屿数量**
- ❌ 错误：`if(grid[i][j] == 0)` （int比较）
- ✅ 正确：`if(grid[i][j] == '0')` （char比较）
- 💡 教训：`vector<vector<char>>` 要用单引号
- ❌ 错误：缺少花括号导致ret++无条件执行
- ✅ 正确：用花括号包裹if语句块

**3. LeetCode 417 - 太平洋大西洋**
- ❌ 错误：`if(h[i-1][j] >= h[i][j])` 直接访问数组
- ✅ 正确：先检查边界，或用dx/dy数组
- 💡 教训：避免数组越界，用dx/dy更安全

### 收获与反思

#### **今日核心收获** 🎯

**1. FloodFill ≠ 普通网格DFS**
```
普通网格DFS（Day28）：
- 需要回溯（尝试多条路径）
- 需要恢复vis数组

FloodFill（Day29）：
- 不需要回溯（填充后不回头）✨
- 直接修改原数组
```

**2. 反向思维的两次应用** ⭐⭐⭐
```
LeetCode 130：
- 1个vis数组
- 从四条边出发
- 临时标记'#'

LeetCode 417（升级）：
- 2个vis数组
- 从两组边界出发
- 取交集找答案
```

**3. dx/dy数组的掌握**
- 比传统写法更简洁
- 比特课程标准写法
- 避免数组越界错误

---

#### **知识体系更新**

**网格DFS的三种形态**：
```
1. 单词搜索（Day28）：bool返回值，找一条路径
2. 黄金矿工（Day28）：void返回值，找所有路径最优解
3. FloodFill（Day29）：不需要回溯，连通区域处理
```

**反向思维的应用层级**：
```
基础：LeetCode 130 - 单边界问题
进阶：LeetCode 417 - 双边界问题 ⭐⭐⭐
```

---

#### **成长亮点** ✨

1. ✅ **一次AC率提升**：LeetCode 695、417 都是一次AC
2. ✅ **错误定位能力**：快速发现char vs int问题
3. ✅ **知识迁移能力**：Day28的void+全局变量成功应用到695
4. ✅ **反向思维内化**：从130到417，举一反三

---

#### **需要加强**

1. 🔧 **细节注意力**：
   - 花括号（代码风格）
   - 数组越界检查
   - char vs int类型判断

2. 🔧 **代码优化意识**：
   - 优先使用dx/dy数组
   - 减少重复代码

---

#### **下一步计划**

**剩余题目**：
- [ ] LeetCode 1020 - 飞地的数量（类似130，从边界标记）

**可选挑战**：
- [ ] 用BFS实现FloodFill
- [ ] 总结FloodFill通用模板

---

---

**Day29 FloodFill专题开始！** 🚀
