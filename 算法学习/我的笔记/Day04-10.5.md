题目1：反转字符串（LeetCode 344） ⭐
难度：简单
知识点：对撞指针
预计时间：10分钟
为什么选它：最基础的双指针，找回自信
题目2：有序数组的平方（LeetCode 977） ⭐⭐
难度：简单
知识点：双指针
预计时间：15-20分钟
为什么选它：有点小技巧，但不难，练手感


解答：
1.反转字符串
解答代码：
class Solution {
public:
    void reverseString(vector<char>& s) {
        int left = 0;
        int right = s.size() - 1;
        while(left < right)
        {
            swap(s[left],s[right]);
            left++;
            right--;
        }
    }
};
结果：AC，用时4m32s

题目2：有序数组的平方

### ❌ 第一次错误代码（原地操作）
```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        while(left < right)  // ⚠️ 问题1：left==right时退出，会漏掉中间元素
        {
            if(nums[left] < 0)
            {
                if(nums[left]*nums[left] > nums[right]*nums[right])
                {
                nums[left]*= nums[left];  // ⚠️ 问题2：直接修改原数组
                nums[right]*= nums[right]; // 会导致重复平方！-4→16→81
                swap(nums[left] , nums[right]);
                right--;
                }
                else right--;
            }
            else {
                nums[left]*= nums[left];
                nums[right]*= nums[right];
                left++;
                right--;
            }
        }
        return nums;
    }
};
```
**输入**：`[-4,-1,0,3,10]`  
**输出**：`[81,-1,0,16,10]`（错误）  
**预期**：`[0,1,9,16,100]`

**错在哪？**
1. **重复平方**：-4先变16，下次循环16又被当成新数平方成81
2. **破坏有序性**：修改原数组后，`nums[left] < 0`的判断就不准了
3. **漏掉元素**：-1和10根本没被处理
4. **循环条件错**：`while(left < right)`会漏掉中间那个元素

**教训**：不能边修改原数组边判断，会乱套！



---

### ❌ 第二次错误代码（push_back方向错了）
```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        vector<int> ret{};
        for(int i = right ; i >= 0; i--)
        {
            int leftval = nums[left]*nums[left];
            int rightval = nums[right]*nums[right];
            if(leftval < rightval)  // ⚠️ 关键错误：比较后push小的
            {
                ret.push_back(leftval);  // 小的放前面，但两端是最大值！
                right--;
            }
            else
            {
                ret.push_back(rightval);
                left++;
            }
        }
        return ret;
    }
};
```
**输入**：`[-4,-1,0,3,10]`  
**输出**：`[16,9,1,0,0]`（错误，顺序反了）  
**预期**：`[0,1,9,16,100]`

**为什么push_back错了？逐步追踪：**

| 循环次数 | left | right | leftval | rightval | 操作 | ret当前状态 |
|---------|------|-------|---------|----------|------|-------------|
| 1 | 0(-4) | 4(10) | 16 | 100 | 16<100 → push(16) | [16] |
| 2 | 0(-4) | 3(3) | 16 | 9 | 16>9 → push(9) | [16, 9] |
| 3 | 1(-1) | 3(3) | 1 | 9 | 1<9 → push(1) | [16, 9, 1] |
| 4 | 1(-1) | 2(0) | 1 | 0 | 1>0 → push(0) | [16, 9, 1, 0] |
| 5 | 2(0) | 2(0) | 0 | 0 | 0≥0 → push(0) | [16, 9, 1, 0, 0] |

**问题出在哪？**
- 🔴 **你的逻辑**：比较两端，把**小的**push进去
- 🔴 **实际结果**：因为两端是最大值，越往中间越小，所以push出来是**从大到小**！
- ✅ **正确思路**：应该把**大的**push进去，然后最后reverse；或者直接用`ret[i]`从后往前填充大的

**为什么不能push小的？**
因为题目要求**非递减**（从小到大），但是：
- 两端的平方值是最大的（最小负数² 或 最大正数²）
- 越往中间，平方值越小
- 如果你push小的 → 结果是从大到小 → 反了！

**我当时的想法**：我以为比较后push小的能保证顺序递增，但忽略了双指针从两端往中间走，两端本来就是大的！

---

### ✅ 正确代码（从后往前填充大的）
```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int n = nums.size();
        vector<int> ret(n);  // 预分配空间，用ret[i]填充
        int left = 0, right = n - 1;
        
        for(int i = n - 1; i >= 0; i--)  // 从后往前填充
        {
            int leftVal = nums[left] * nums[left];
            int rightVal = nums[right] * nums[right];
            
            if(leftVal > rightVal)  // 比较后，把大的放后面
            {
                ret[i] = leftVal;
                left++;
            }
            else
            {
                ret[i] = rightVal;
                right--;
            }
        }
        return ret;
    }
};
```

**为什么这样是对的？**
1. 用`ret[i]`从后往前填充，i从n-1到0
2. 每次比较两端，把**大的**放到`ret[i]`
3. 因为从后往前填，最大的自然在后面，最小的在前面
4. 不修改原数组，只读取比较

**关键点：**
- ⚠️ `vector<int> ret(n)` 预分配空间（不是`ret{}`）
- ⚠️ 从后往前填充：`i = n-1` → `i >= 0`
- ⚠️ 比较后选**大的**放`ret[i]`
- ⚠️ 时间复杂度O(n)，空间复杂度O(n)

**耗时**：20分钟（两次错误+调试）  
**结果**：✅ AC

---

## 💡 今日收获（Day04 - 10.5）

**心态调整**：
- 今天有点累，但坚持刷了2题
- 虽然第2题错了两次，但通过debug理解了双指针的本质
- 不求量，只求每天进步一点点

**技术收获**：
1. **原地操作的陷阱**：不能边修改边判断，会破坏数据结构
2. **双指针方向问题**：从两端往中间走，两端是极值（最大/最小）
3. **push_back vs ret[i]**：
   - push_back：只能从前往后追加
   - ret[i]：可以指定位置填充（更灵活）
4. **思维误区**：以为push小的能递增，但忽略了指针移动方向

**典型错误**：
- ❌ 直接修改原数组导致重复操作
- ❌ push_back方向搞反（应该push大的或最后reverse）
- ❌ 循环条件写成`left < right`会漏元素

**总耗时**：约25分钟  
**完成度**：2/2 ✅


