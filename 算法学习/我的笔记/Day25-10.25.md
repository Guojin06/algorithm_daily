# Day25 - 递归、搜索、回溯专题 (10.25)

## 学习目标
- 深入理解回溯算法的本质
- 掌握回溯的恢复现场时机
- 理解全排列问题的递归树
- 学会使用状态数组避免重复选择

---

## 1. LeetCode 46 - 全排列

### 题目描述
给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

**示例 1：**
```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**
```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**
```
输入：nums = [1]
输出：[[1]]
```

**提示：**
- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

### 解题思路

**核心思想**：
- 使用**回溯算法**（DFS + 撤销选择）
- 类似二叉树的路径记录，但需要避免重复使用数字
- 关键：恢复现场的时机必须在递归调用之后

**递归设计**：
```cpp
void dfs(vector<int>& nums)
功能：基于当前path，继续构建全排列
全局变量：
  - path: 当前排列路径
  - check: 标记数字是否已使用
  - ret: 存储所有结果
```

**回溯框架**：
```
1. 递归出口：path.size() == nums.size()（排列完成）
2. 递归体：
   - 遍历所有数字
   - 如果数字未使用：
     a. 做选择（加入path，标记为已用）
     b. 递归到下一层
     c. 撤销选择（移出path，标记为未用）← 关键！
```

**决策树（nums=[1,2,3]）**：
```
                    []
         /          |          \
      [1]          [2]          [3]
     /   \        /   \        /   \
  [1,2] [1,3]  [2,1] [2,3]  [3,1] [3,2]
   |      |      |      |      |      |
[1,2,3][1,3,2][2,1,3][2,3,1][3,1,2][3,2,1]
       ↑
    6个全排列结果
```

**关键理解：恢复现场的时机**

**错误理解**：在递归出口恢复
```cpp
if(path.size() == nums.size()) {
    ret.push_back(path);
    path.pop_back();     // ❌ 错误！你不知道该恢复哪个
    check[?] = false;    // ❌ 错误！无法确定索引
    return;
}
```

**正确理解**：在递归调用后恢复
```cpp
for(int i = 0; i < nums.size(); i++) {
    if(!check[i]) {
        path.push_back(nums[i]);  // 做选择
        check[i] = true;          // 标记
        dfs(nums);                // 递归
        path.pop_back();          // ← 在这里恢复！
        check[i] = false;         // ← 在这里恢复！
    }
}
```

**为什么必须在递归后恢复？**
1. **对称性**：做选择和撤销选择必须配对
2. **循环需要**：每次循环前，状态必须是干净的
3. **递归本质**：深度优先，每次return都要恢复上一层状态

**执行过程示例（nums=[1,2,3]，只看前几步）**：
```
dfs() path=[]
├─ i=0: 选择1
│  ├─ path=[1], check=[T,F,F]
│  ├─ dfs() path=[1]
│  │  ├─ i=1: 选择2
│  │  │  ├─ path=[1,2], check=[T,T,F]
│  │  │  ├─ dfs() path=[1,2]
│  │  │  │  ├─ i=2: 选择3
│  │  │  │  │  ├─ path=[1,2,3], check=[T,T,T]
│  │  │  │  │  ├─ dfs() → 记录[1,2,3] ✅
│  │  │  │  │  ├─ return ← 返回了
│  │  │  │  │  ├─ path.pop_back() → path=[1,2] ← 恢复！
│  │  │  │  │  └─ check[2]=false → [T,T,F]   ← 恢复！
│  │  │  ├─ return ← 返回了
│  │  │  ├─ path.pop_back() → path=[1] ← 恢复！
│  │  │  └─ check[1]=false → [T,F,F]   ← 恢复！
│  │  │
│  │  ├─ i=2: 选择3
│  │  │  ├─ path=[1,3], check=[T,F,T]
│  │  │  └─ ...继续递归...
│  ├─ return
│  ├─ path.pop_back() → path=[] ← 恢复！
│  └─ check[0]=false → [F,F,F]  ← 恢复！
│
├─ i=1: 选择2
│  └─ path=[2], check=[F,T,F]
│  └─ ...类似过程...
```

### 初始代码/错误代码
```cpp
// 无错误，一次AC
```

### 错误分析
无错误（但对恢复现场时机有疑惑）

### 正确代码

**方法：回溯 + 状态数组**
```cpp
class Solution {
public:
    // 全局变量
    vector<vector<int>> ret;  // 结果集
    vector<int> path;         // 当前排列路径
    bool check[7];            // 标记数字是否已使用
    
    vector<vector<int>> permute(vector<int>& nums) {
        // 初始化check数组（都未使用）
        for(int i = 0; i < nums.size(); i++) {
            check[i] = false;
        }
        dfs(nums);
        return ret;
    }
    
    void dfs(vector<int>& nums) {
        // 1. 递归出口：排列完成
        if(path.size() >= nums.size()) {
            ret.push_back(path);  // 记录结果
            return;  // ← 只记录，不恢复！
        }
        
        // 2. 递归体：遍历所有选择
        for(int i = 0; i < nums.size(); i++) {
            if(check[i] == false) {  // 剪枝：该数字未使用
                // 做选择
                path.push_back(nums[i]);
                check[i] = true;
                
                // 递归
                dfs(nums);
                
                // ✅ 撤销选择（恢复现场）← 必须在递归后！
                path.pop_back();
                check[i] = false;
            }
        }
    }
};
```

**代码要点**：
1. ✅ 使用`check`数组标记数字是否已用
2. ✅ 恢复现场在递归调用后，不在出口
3. ✅ 做选择和撤销选择严格配对
4. ✅ 每次for循环前，状态都是干净的

### 核心知识点

#### **回溯算法模板**
```cpp
void backtrack(参数) {
    // 1. 递归出口
    if (满足条件) {
        记录结果;
        return;  // ← 只记录，不恢复！
    }
    
    // 2. 递归体
    for (遍历所有选择) {
        if (剪枝条件) continue;
        
        // 做选择
        修改状态;
        
        // 递归
        backtrack(下一层参数);
        
        // ✅ 撤销选择（恢复现场）← 必须在这里！
        恢复状态;
    }
}
```

#### **恢复现场的时机**

**核心原则：做选择和撤销选择必须配对**

**正确示例**：
```cpp
for(int i = 0; i < n; i++) {
    path.push_back(i);   // 做选择
    dfs();               // 递归
    path.pop_back();     // 撤销选择 ← 为了下一次循环！
}
```

**错误示例**：
```cpp
if(满足条件) {
    记录结果;
    path.pop_back();  // ❌ 错误！破坏了配对关系
    return;
}
```

**为什么必须在递归后恢复？**
```
第1次循环：
  做选择：path=[1]
  递归：处理所有以1开头的排列
  撤销：path=[] ← 必须恢复！
  
第2次循环：← 需要干净的状态！
  做选择：path=[2] ← 如果不恢复，这里就是[1,2]了
  递归：处理所有以2开头的排列
  撤销：path=[]
```

#### **状态数组的使用**

**作用**：标记元素是否已使用，避免重复选择

```cpp
bool check[n];  // 标记数组

// 使用前检查
if(check[i] == false) {
    check[i] = true;   // 标记为已用
    // ...递归...
    check[i] = false;  // 恢复为未用
}
```

#### **回溯 vs 递归**

```
递归：函数调用自己，解决子问题
回溯：递归 + 撤销选择，遍历所有可能性

回溯 = DFS + 恢复现场
```

#### **全排列的时间复杂度**

```
时间复杂度：O(n! * n)
- n! 种排列
- 每种排列需要O(n)复制到结果

空间复杂度：O(n)
- 递归栈深度O(n)
- path数组O(n)
- check数组O(n)
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(n) 递归栈 + 辅助数组

---

## 2. LeetCode 78 - 子集

### 题目描述
给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**
```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**
```
输入：nums = [0]
输出：[[],[0]]
```

**示例 3：**
```
输入：nums = []
输出：[[]]
```

**提示：**
- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**

### 解题思路

**核心思想**：
- 使用**回溯算法**，但与全排列有关键区别
- 子集不关心顺序：[1,2] 和 [2,1] 是同一个子集
- 关键：用`index`参数保证"只往后选，不回头"

**与全排列的对比**：
```
全排列：
- [1,2,3] 和 [3,2,1] 是不同的（顺序不同）
- 固定长度（必须用完所有元素）
- 用check数组标记是否已用
- for循环从0开始，每次遍历所有元素

子集：
- [1,2] 和 [2,1] 是相同的（需要去重）
- 长度可变（0~n）
- 不需要check数组
- for循环从index开始，只往后选
```

**递归设计**：
```cpp
void dfs(vector<int>& nums, int index)
功能：从index位置开始，构建所有可能的子集
参数：
  - nums: 原数组
  - index: 起始位置（保证只往后选）
全局变量：
  - path: 当前子集
  - ret: 存储所有结果
```

**关键理解：两种思路对应两种决策树**

**思路1：选或不选（每个元素都考虑）**
```
决策树：
                    [] (考虑位置0)
                /              \
            选1 /                \ 不选1
              /                  \
           [1] (考虑位置1)      [] (考虑位置1)
          /    \                /    \
      选2/      \不选2       选2/      \不选2
        /        \            /        \
     [1,2]      [1]         [2]        []
     (考虑2)   (考虑2)     (考虑2)    (考虑2)
     /  \       / \         / \        / \
   选3/不选3 选3/不选3   选3/不选3  选3/不选3
  [1,2,3][1,2][1,3][1][2,3][2][3]  []

结果：8个子集（2^3）
```

**思路2：从index开始选（只考虑后面的元素）**
```
决策树：
                [] (index=0)
        /       |       \
     选0       选1      选2
      /         |         \
    [1]        [2]        [3]
  (index=1)  (index=2)  (index=3)
    /   \       |
  选1   选2    选2
  /      \      |
[1,2]  [1,3]  [2,3]
(index=2)(index=3)(index=3)
  |
 选2
  |
[1,2,3]
(index=3)

每层只能选index及之后的元素，天然避免重复
```

**回溯框架（思路2，推荐）**：
```
1. 递归开始：记录当前path（每个节点都记录）
2. 递归体：
   - 从index开始遍历
   - 选择当前元素，加入path
   - 递归到i+1（保证只往后选）
   - 撤销选择，移出path
3. 递归出口：index >= n（for循环自然结束）
```

**关键点：为什么不需要check数组？**
```
全排列：
for(i = 0; i < n; i++)  // 每次都从0开始
    if(!check[i])       // 需要判断是否已用

子集：
for(i = index; i < n; i++)  // 从index开始
    dfs(i + 1)              // 下次从i+1开始（天然不会回头）
```

**执行过程示例（nums=[1,2,3]）**：
```
dfs(index=0) path=[]
├─ 记录 [] ✅
├─ i=0: 选1
│  ├─ path=[1]
│  ├─ dfs(index=1) path=[1]
│  │  ├─ 记录 [1] ✅
│  │  ├─ i=1: 选2
│  │  │  ├─ path=[1,2]
│  │  │  ├─ dfs(index=2) path=[1,2]
│  │  │  │  ├─ 记录 [1,2] ✅
│  │  │  │  ├─ i=2: 选3
│  │  │  │  │  ├─ path=[1,2,3]
│  │  │  │  │  ├─ dfs(index=3) → 记录 [1,2,3] ✅
│  │  │  │  │  └─ path=[1,2]（恢复）
│  │  │  ├─ path=[1]（恢复）
│  │  │  ├─ i=2: 选3
│  │  │  │  ├─ path=[1,3]
│  │  │  │  ├─ dfs(index=3) → 记录 [1,3] ✅
│  │  │  │  └─ path=[1]（恢复）
│  │  ├─ path=[]（恢复）
│  │
│  ├─ i=1: 选2
│  │  ├─ path=[2]
│  │  ├─ dfs(index=2) path=[2]
│  │  │  ├─ 记录 [2] ✅
│  │  │  ├─ i=2: 选3
│  │  │  │  ├─ path=[2,3]
│  │  │  │  ├─ dfs(index=3) → 记录 [2,3] ✅
│  │  │  │  └─ path=[2]（恢复）
│  │  ├─ path=[]（恢复）
│  │
│  ├─ i=2: 选3
│  │  ├─ path=[3]
│  │  ├─ dfs(index=3) → 记录 [3] ✅
│  │  └─ path=[]（恢复）

结果：[[], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]]
```

### 初始代码/错误代码
```cpp
// 无错误，一次AC
```

### 错误分析
无错误

### 正确代码

**方法：回溯 + index参数（避免重复）**
```cpp
class Solution {
public:
    vector<vector<int>> ret;  // 结果集
    vector<int> path;         // 当前子集
    
    vector<vector<int>> subsets(vector<int>& nums) {
        dfs(nums, 0);  // 从位置0开始
        return ret;
    }
    
    void dfs(vector<int>& nums, int index) {
        // 1. 记录当前子集（每个节点都记录！）
        ret.push_back(path);
        
        // 2. 从index开始，尝试选择后续元素
        for(int i = index; i < nums.size(); i++) {
            // 做选择
            path.push_back(nums[i]);
            
            // 递归（从i+1开始，保证不回头）
            dfs(nums, i + 1);
            
            // 撤销选择（恢复现场）
            path.pop_back();
        }
    }
};
```

**代码要点**：
1. ✅ `index`参数：记录起始位置，保证只往后选
2. ✅ `for(i = index; ...)` 从index开始遍历
3. ✅ `dfs(nums, i+1)` 递归时传入i+1
4. ✅ 每个节点都记录结果（不只是叶子节点）
5. ✅ 不需要check数组（index天然避免重复）

### 核心知识点

#### **子集 vs 全排列的关键区别**

| 特性 | 全排列 | 子集 |
|------|--------|------|
| **关心顺序** | ✅ 是 | ❌ 否 |
| **固定长度** | ✅ 是（n） | ❌ 否（0~n） |
| **index参数** | ❌ 不需要 | ✅ 需要 |
| **for起点** | `i = 0` | `i = index` |
| **递归调用** | `dfs(nums)` | `dfs(nums, i+1)` |
| **check数组** | ✅ 需要 | ❌ 不需要 |
| **记录时机** | 叶子节点 | 每个节点 |

#### **index参数的作用**

**核心：保证"只往后选，不回头"**

```cpp
void dfs(vector<int>& nums, int index) {
    for(int i = index; i < nums.size(); i++) {
        // 选择nums[i]
        dfs(nums, i + 1);  // 下次只能从i+1开始选
    }
}
```

**示例**：
```
选了1（i=0）后，下次从index=1开始 → 只能选2、3
选了2（i=1）后，下次从index=2开始 → 只能选3
选了3（i=2）后，下次从index=3开始 → 没有可选了

保证了不会出现[2,1]这种"回头选"的情况
```

#### **为什么每个节点都记录？**

```
全排列：只要完整的排列
- [1,2,3] ✅
- [1,2]   ❌
- [1]     ❌

子集：要所有长度的子集
- [1,2,3] ✅
- [1,2]   ✅
- [1]     ✅
- []      ✅
```

#### **决策树的两种理解**

**理解1：选或不选某个位置**
```
每个位置做两次决策：选 / 不选
时间复杂度：O(2^n)
```

**理解2：从index开始选后面的元素**
```
每个节点考虑"从index开始选哪个"
时间复杂度：O(2^n)
```

**两种理解对应不同的代码实现，但结果相同**

#### **子集的时间复杂度**

```
时间复杂度：O(2^n * n)
- 2^n 个子集
- 每个子集需要O(n)复制到结果

空间复杂度：O(n)
- 递归栈深度O(n)
- path数组O(n)
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(n) 递归栈

---

## 今日总结

### 完成情况
✅ **2道题全部AC！**
1. LeetCode 46 - 全排列（经典回溯）
2. LeetCode 78 - 子集（回溯 + index参数）

### 核心知识点

#### **1. 回溯算法的本质**
```
回溯 = DFS + 恢复现场

核心框架：
for (遍历所有选择) {
    做选择;
    递归;
    撤销选择;  // ← 必须在递归后！
}
```

#### **2. 恢复现场的时机**
**关键原则：做选择和撤销选择必须配对**

✅ **正确**：在递归调用后恢复
```cpp
path.push_back(x);  // 做选择
dfs();              // 递归
path.pop_back();    // 撤销选择 ← 在这里！
```

❌ **错误**：在递归出口恢复
```cpp
if(满足条件) {
    记录结果;
    path.pop_back();  // ❌ 破坏了配对关系
}
```

#### **3. 全排列 vs 子集的核心区别**

| 特性 | 全排列 | 子集 |
|------|--------|------|
| **关心顺序** | ✅ | ❌ |
| **固定长度** | ✅（n） | ❌（0~n） |
| **for起点** | `i=0`（每次遍历全部） | `i=index`（只往后选） |
| **递归参数** | `dfs(nums)` | `dfs(nums, i+1)` |
| **check数组** | ✅ 需要 | ❌ 不需要 |
| **记录时机** | 叶子节点 | 每个节点 |

**核心理解**：
- 全排列：每次都要"看一遍所有元素"，用check判断
- 子集：只往后选不回头，用index控制范围

#### **4. index参数的作用**
**保证"只往后选，不回头"**
```cpp
void dfs(nums, index) {
    for(int i = index; i < n; i++) {  // 从index开始
        dfs(nums, i + 1);  // 下次从i+1开始（不回头）
    }
}
```

#### **5. 递归返回机制**
- **显式返回**：主动写`return`
- **隐式返回**：函数执行完自动返回
- **void函数**：最后的`return;`可省略
- **有返回值函数**：必须显式返回

### 易错点

#### **1. 恢复现场的位置错误**
```cpp
// ❌ 错误：在出口恢复
if(path.size() == n) {
    ret.push_back(path);
    path.pop_back();  // 你不知道该恢复哪个！
}

// ✅ 正确：在递归后恢复
for(...) {
    path.push_back(x);
    dfs();
    path.pop_back();  // 对应push_back
}
```

#### **2. 混淆全排列和子集的实现**
```cpp
// 全排列：需要check数组
for(int i = 0; i < n; i++) {
    if(!check[i]) { ... }
}

// 子集：不需要check，用index
for(int i = index; i < n; i++) {
    dfs(nums, i + 1);
}
```

#### **3. 忘记子集要记录所有节点**
```cpp
// 全排列：只在叶子记录
if(path.size() == n) ret.push_back(path);

// 子集：每个节点都记录
ret.push_back(path);  // 在函数开头
```

### 收获与反思

#### **今日最大收获**

1. **彻底理解了回溯的恢复现场机制**
   - 必须在递归调用后恢复
   - 做选择和撤销选择严格配对
   - 不能在递归出口恢复

2. **掌握了全排列和子集的区别**
   - 全排列：关心顺序，用check数组
   - 子集：不关心顺序，用index参数
   - 理解了index参数"只往后选"的作用

3. **理解了递归的返回机制**
   - 显式返回 vs 隐式返回
   - for循环结束后函数自然返回
   - void函数最后的return可省略

#### **思考模式进步**

- 画决策树帮助理解递归过程
- 对比不同题型找出核心区别
- 从具体例子推导通用规律

#### **下次学习方向**

1. 继续练习回溯题目（组合、组合总和等）
2. 总结递归的完整方法论体系
3. 建立递归问题的思考检查清单

---

**Day25完成！** 🎉
- 2道经典回溯题目全部AC
- 深入理解回溯的恢复现场机制
- 掌握全排列和子集的核心区别

