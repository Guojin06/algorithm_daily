# Day22 - 队列+宽搜（BFS）专题 (10.22)

## 学习目标
掌握BFS层序遍历的核心模板，理解队列在树的层序遍历中的应用。

---

## 题目1：LeetCode 429 - N叉树的层序遍历 (medium)

### 题目链接
[429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

### 题目描述
给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。

**示例 1：**
```
输入：root = [1,null,3,2,4,null,5,6]
输出：[[1],[3,2,4],[5,6]]
```

### 解题思路
**BFS层序遍历的核心模板**：
1. 创建队列，根节点入队
2. 循环：当队列不为空时
   - **关键步骤1**：`int sz = q.size()` - 记录当前层节点数
   - **关键步骤2**：循环sz次，处理当前层所有节点
     - 取出队头节点，收集值
     - 将该节点的所有孩子入队（为下一层做准备）
   - 将当前层结果保存

**分层的关键**：在进入每一层之前，先用`sz`记录队列当前大小，这样就能精确控制每层处理多少个节点，不会把下一层的节点混进来。

### 代码实现
```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;
    Node() {}
    Node(int _val) {
        val = _val;
    }
    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        vector<vector<int>> ret;

        if(root == nullptr) return ret; // 边界条件

        queue<Node*> q;
        q.push(root); // 根节点入队

        while(!q.empty())
        {
            int sz = q.size(); // 如何分层，关键：记录当前层结点数
            vector<int> level; // 关键：存储当前层的值

            for(int i = 0; i < sz; i++)
            {
                Node* node = q.front();
                q.pop();

                // 1.将当前节点的值加入level
                level.push_back(node->val);
                
                // 2.把当前节点的所有孩子加入队列
                for(Node* child : node->children)
                {
                    // child就是每一个孩子节点
                    q.push(child);
                }
            }
            
            // 3.把当前层的结果加入ret
            ret.push_back(level);
        }
        return ret;
    }
};
```

### 提交结果
✅ **一次AC**

### 错误记录
无

### 总结与反思
**核心知识点**：
1. **队列的FIFO特性**：先进先出，天然适合层序遍历
2. **分层的关键**：`int sz = q.size()` 在处理每层前固定当前层节点数
3. **N叉树遍历孩子**：`for(Node* child : node->children)` 范围for循环

**BFS模板结构**：
```cpp
queue<Node*> q;
q.push(root);
while(!q.empty()) {
    int sz = q.size();        // ⭐ 固定当前层大小
    for(int i = 0; i < sz; i++) {
        Node* node = q.front();
        q.pop();
        // 处理当前节点
        // 孩子入队
    }
}
```

这个模板是所有BFS题目的基础，后面的题都是在这个框架上做变形！

---

## 题目2：LeetCode 103 - 二叉树的锯齿形层序遍历 (medium)

### 题目链接
[103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

### 题目描述
给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

**示例 1：**
```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
解释：
第1层：3       （从左到右）
第2层：20, 9   （从右到左，逆序输出）
第3层：15, 7   （从左到右）
```

### 解题思路
**在BFS基础模板上做变形**：
1. 用变量`levelnum`记录当前层数（从1开始）
2. 正常进行BFS层序遍历
3. **关键点**：在每层结果加入`ret`之前，判断当前层数奇偶
   - 奇数层（1, 3, 5...）：正常顺序，不需要处理
   - 偶数层（2, 4, 6...）：需要逆序，使用`reverse()`
4. 每层处理完后，`levelnum++`进入下一层

**核心差异**：
- N叉树：`for(Node* child : node->children)` 遍历所有孩子
- 二叉树：`if(node->left)` 和 `if(node->right)` 分别处理左右孩子

### 代码实现
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
        vector<vector<int>> ret;
        if(root == nullptr) return ret;
        
        queue<TreeNode*> q;
        q.push(root);
        
        int levelnum = 1;  // 记录当前层数
        
        while(!q.empty())
        {
            int sz = q.size();
            vector<int> level;  // 存储当前层的值
            
            for(int i = 0; i < sz; i++)
            {
                TreeNode* node = q.front();
                q.pop();
                
                // 1. 把当前节点值加入level
                level.push_back(node->val);
                
                // 2. 把左右孩子加入队列（先判空）
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            
            // 3. 判断是否需要逆序（偶数层需要）
            if(levelnum % 2 == 0) {
                reverse(level.begin(), level.end());
            }
            
            ret.push_back(level);
            levelnum++;  // 进入下一层
        }
        return ret;
    }
};
```

### 提交结果
✅ **一次AC**

### 错误记录
无

### 总结与反思
**关键知识点**：
1. **二叉树的孩子处理**：左右孩子需要分别判空后入队
   ```cpp
   if(node->left) q.push(node->left);
   if(node->right) q.push(node->right);
   ```

2. **层数奇偶判断**：`levelnum % 2 == 0` 判断偶数层

3. **vector逆序**：`reverse(level.begin(), level.end())`
   - 需要包含头文件 `#include <algorithm>`
   - 时间复杂度 O(n)，空间复杂度 O(1)

4. **变形思路**：在BFS标准模板的基础上，只需在"保存当前层结果"这一步前加判断逻辑即可

**对比第一题**：
- 第一题：N叉树，遍历所有孩子
- 第二题：二叉树，只有左右孩子，增加了奇偶层的逆序处理


---

## 题目3：LeetCode 662 - 二叉树最大宽度 (medium)

### 题目链接
[662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

### 题目描述
给你一棵二叉树的根节点 root ，返回树的 最大宽度 。

**示例 1：**
```
输入：root = [1,3,2,5,3,null,9]

       1
      / \
     3   2
    / \   \
   5   3   9

输出：4
解释：第3层宽度最大，为4（5, 3, null, 9）
```

**注意：** 计算宽度时，**空节点(null)也要算在内**。

### 解题思路
**核心：利用完全二叉树的编号思想**

1. **二叉树编号规则（类似堆的存储）：**
   - 根节点编号为 1
   - 父节点编号为 `i`，则：
     - 左孩子编号 = `2 * i`
     - 右孩子编号 = `2 * i + 1`

2. **为什么用编号？**
   - 任何二叉树都可以映射到完全二叉树的编号系统
   - 编号的差值自动包含了中间所有null节点的位置
   - 不用真的把null入队（节省内存）

3. **宽度计算：**
   - 每层的宽度 = 最右节点编号 - 最左节点编号 + 1
   - 获取方式：
     - 最左编号：`q.front().second`（进入该层时队列第一个元素）
     - 最右编号：`q.back().second`（进入该层时队列最后一个元素）

4. **BFS流程：**
   - 队列存储 `pair<TreeNode*, unsigned int>` {节点, 编号}
   - 在每层开始处理前，先记录最左和最右编号
   - 然后正常BFS，左右孩子入队时计算新编号

### 代码实现
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if(root == nullptr) return 0;
        
        queue<pair<TreeNode*, unsigned int>> q;  // {节点, 编号}
        q.push({root, 1});  // 根节点编号为1
        
        unsigned int maxWidth = 0;
        
        while(!q.empty()) {
            int sz = q.size();
            
            // 1. 获取当前层第一个节点的编号（最左）
            unsigned int leftIndex = q.front().second;
            
            // 2. 获取当前层最后一个节点的编号（最右）
            unsigned int rightIndex = q.back().second;
            
            // 3. 更新最大宽度
            maxWidth = max(maxWidth, rightIndex - leftIndex + 1);
            
            for(int i = 0; i < sz; i++) {
                auto [node, index] = q.front();
                q.pop();
                
                // 4. 左右孩子入队，并计算它们的编号
                if(node->left) {
                    q.push({node->left, 2 * index});  // 左孩子编号
                }
                if(node->right) {
                    q.push({node->right, 2 * index + 1});  // 右孩子编号
                }
            }
        }
        
        return maxWidth;
    }
};
```

### 提交结果
✅ **一次AC**

### 错误记录
无

### 总结与反思
**核心知识点**：
1. **完全二叉树的编号系统**：父节点`i`，左孩子`2i`，右孩子`2i+1`
   - 这个规律对**任何二叉树**都适用（不仅限于完全二叉树）
   - 通过编号映射，可以计算包含null节点的宽度

2. **为什么不直接把null入队？**
   ```
   极端情况：单链树
       1
      /
     2
    /
   3
   
   第n层需要存储 2^n 个节点，其中只有1个真实节点，其他都是null
   → 会导致内存爆炸！
   ```

3. **编号的妙用**：
   - 只存储实际存在的节点
   - null节点的"位置"通过编号差值体现
   - 宽度 = 编号差值 + 1（自动包含中间所有null）

4. **数据类型选择**：
   - 使用 `unsigned int`（无符号整数）
   - 因为编号可能很大（深层树的编号是指数增长）
   - 虽然可能溢出，但题目保证宽度在int范围内，差值计算是正确的

5. **pair的使用**：
   ```cpp
   queue<pair<TreeNode*, unsigned int>> q;
   auto [node, index] = q.front();  // C++17结构化绑定
   ```

**思维提升**：
- 这题的难点不在代码，而在**思想**
- 将问题转化为数学模型（完全二叉树的编号）
- 空间换时间 vs 巧妙的数学映射

---

## 题目4：LeetCode 515 - 在每个树行中找最大值 (medium)

### 题目链接
[515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

### 题目描述
给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。

**示例 1：**
```
输入: root = [1,3,2,5,3,null,9]

       1
      / \
     3   2
    / \   \
   5   3   9

输出: [1, 3, 9]

解释：
第1层：1        → 最大值 1
第2层：3, 2     → 最大值 3
第3层：5, 3, 9  → 最大值 9
```

### 解题思路
**在BFS基础模板上增加统计逻辑**：

1. 正常进行BFS层序遍历
2. **关键点**：在处理每层的`for`循环中：
   - 定义变量 `levelmax` 记录当前层最大值
   - 初始值设为 `INT_MIN`（C++中int的最小值）
   - 每访问一个节点，就更新 `levelmax`
3. 每层处理完后，将 `levelmax` 加入结果数组

**这题是BFS的简单应用**：
- 没有编号（不像第3题）
- 没有逆序（不像第2题）
- 只是在遍历过程中统计信息

### 代码实现
```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> ret;
        if(root == nullptr) return ret;
        
        queue<TreeNode*> q;
        q.push(root); // 根节点入队
        
        while(!q.empty())
        {
            int sz = q.size();
            int levelmax = INT_MIN;  // 初始化为最小值
            
            for(int i = 0; i < sz; i++)
            {
                TreeNode* node = q.front();
                q.pop();
                
                // 当前节点值与levelmax相比，更新最大值
                if(node->val > levelmax) levelmax = node->val;
                // 也可以写成：levelmax = max(levelmax, node->val);
                
                // 当前节点左右孩子加入队列
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            
            // 当前层结果加入ret
            ret.push_back(levelmax);
        }
        return ret;
    }
};
```

### 提交结果
✅ **一次AC（7分钟）**

### 错误记录
无

### 总结与反思
**核心知识点**：
1. **INT_MIN 的使用**：
   ```cpp
   #include <climits>
   int minVal = INT_MIN;  // int类型的最小值（-2147483648）
   int maxVal = INT_MAX;  // int类型的最大值（2147483647）
   ```

2. **在BFS中统计信息**：
   - 可以在遍历每层时统计：最大值、最小值、平均值、和等
   - 模板不变，只是在`for`循环中增加统计逻辑

3. **代码优化**：
   ```cpp
   // 方法1：使用if判断
   if(node->val > levelmax) levelmax = node->val;
   
   // 方法2：使用max函数（更简洁）
   levelmax = max(levelmax, node->val);
   ```

**BFS应用总结（4题对比）**：
- **第1题**：基础模板，返回二维数组
- **第2题**：+奇偶层逆序
- **第3题**：+编号计算宽度
- **第4题**：+统计每层最大值

所有题目的**核心框架都是一样的**，只是在不同位置增加不同的处理逻辑！

---

## 今日学习总结

### 完成情况
✅ **全部4题AC**，其中3题一次AC！
- LeetCode 429 - N叉树的层序遍历（一次AC）
- LeetCode 103 - 二叉树的锯齿形层序遍历（一次AC）
- LeetCode 662 - 二叉树最大宽度（一次AC）
- LeetCode 515 - 在每个树行中找最大值（一次AC，7分钟）

### 核心知识点

#### 1. **BFS层序遍历标准模板**
```cpp
queue<Node*> q;
q.push(root);

while(!q.empty()) {
    int sz = q.size();        // ⭐ 关键：固定当前层节点数
    
    for(int i = 0; i < sz; i++) {
        Node* node = q.front();
        q.pop();
        
        // 处理当前节点
        // ...
        
        // 孩子节点入队（为下一层做准备）
        // ...
    }
}
```

**核心要点**：
- `int sz = q.size()` 在进入每层前记录当前层节点数
- 通过固定循环次数来**精确控制每层**的处理
- 在处理当前层的同时，为下一层做准备（孩子入队）

#### 2. **队列的使用**
```cpp
#include <queue>

queue<TreeNode*> q;
q.push(node);        // 入队
TreeNode* t = q.front();  // 获取队头
q.pop();             // 出队
q.empty();           // 判空
q.size();            // 获取大小
```

**FIFO特性**：先进先出，天然适合层序遍历

#### 3. **N叉树 vs 二叉树**
```cpp
// N叉树：遍历所有孩子
for(Node* child : node->children) {
    q.push(child);
}

// 二叉树：分别处理左右孩子（先判空）
if(node->left) q.push(node->left);
if(node->right) q.push(node->right);
```

#### 4. **完全二叉树的编号系统**
- 根节点编号：1
- 父节点编号 `i`：
  - 左孩子：`2 * i`
  - 右孩子：`2 * i + 1`
- **应用**：通过编号差值计算宽度，避免存储null节点

#### 5. **BFS的常见变形**
| 题目 | 变形点 | 关键技巧 |
|------|--------|----------|
| 第1题 | 基础模板 | `sz = q.size()` 控制层数 |
| 第2题 | 奇偶层逆序 | `level % 2 == 0` + `reverse()` |
| 第3题 | 计算宽度 | `pair<Node*, int>` 存储编号 |
| 第4题 | 统计最大值 | `INT_MIN` 初始化 + 循环更新 |

### 常见错误与注意事项

1. **忘记判空就入队**
   ```cpp
   ❌ q.push(node->left);  // 可能是nullptr
   ✅ if(node->left) q.push(node->left);
   ```

2. **混淆N叉树和二叉树的孩子访问方式**
   - N叉树：`for(Node* child : node->children)`
   - 二叉树：`node->left` 和 `node->right`

3. **层数控制的时机**
   ```cpp
   ✅ int sz = q.size();  // 在for循环前固定
   ❌ for(int i = 0; i < q.size(); i++)  // 会变化！
   ```

4. **初始值的选择**
   - 求最大值：`INT_MIN`
   - 求最小值：`INT_MAX`
   - 求和：`0`

5. **pair的正确使用**
   ```cpp
   queue<pair<TreeNode*, unsigned int>> q;
   auto [node, index] = q.front();  // C++17结构化绑定
   // 或者
   pair<TreeNode*, unsigned int> p = q.front();
   TreeNode* node = p.first;
   unsigned int index = p.second;
   ```

### 学习收获

1. **从零开始复习树的基础知识**
   - 树的节点结构（`val`, `children`, `left`, `right`）
   - 指针的访问（`node->val`, `node->left`）
   - 队列的基本操作

2. **掌握了BFS的核心思想**
   - 队列的FIFO特性适合层序遍历
   - `sz = q.size()` 是分层的关键
   - 所有BFS变形都基于同一个模板

3. **学会了问题的数学建模**
   - 第3题：将二叉树映射到编号系统
   - 用编号差值代替实际存储null
   - 空间换时间 vs 数学映射

4. **提升了解题速度**
   - 第4题只用了7分钟
   - 4题全部一次AC
   - 代码越写越流畅

5. **理解了算法学习的方法论**
   - 先掌握核心模板
   - 理解模板的每个细节为什么这样写
   - 在模板基础上做变形
   - 举一反三，触类旁通

**今日关键词**：BFS、层序遍历、队列、分层控制、数学建模

**明日预告**：继续BFS或者其他专题

