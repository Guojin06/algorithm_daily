# Day35 - 11.4 - 逆向DP专题

## 📅 学习时间
- **日期**：2025-11-04（周一）
- **时长**：预计2-3小时
- **状态**：深化逆向DP思想

---

## 🎯 今日目标

**核心思路**：
- 深化Day34学到的逆向DP思想
- 理解什么时候必须用逆向DP
- 掌握逆向DP的状态定义和转移

**重点方向**：
- [x] 地下城游戏（LeetCode 174）
- [ ] 其他逆向DP问题

---

## 📝 题目记录

### 题目1：地下城游戏（LeetCode 174）⭐⭐⭐

**题目链接**：
- https://leetcode.cn/problems/dungeon-game/

**问题描述**：
- 骑士要去右下角救公主
- 地牢是一个 `m x n` 的二维网格
- 每个格子有一个整数：
  - 正数：增加骑士的血量
  - 负数：减少骑士的血量
  - 0：不影响
- 骑士每次只能向右或向下移动
- 骑士的血量在任何时刻都必须 > 0
- 求骑士的**最小初始血量**

**示例**：
```
地牢：
-2(起点)  -3     3
  -5      -10    1
  10       30   -5(终点)

一条路径：右 → 右 → 下 → 下
血量变化：
- 初始血量：7
- (-2)后：5
- (-3)后：2
- (3)后：5
- (1)后：6
- (-5)后：1（到达终点）

答案：7（最小初始血量）
```

---

## 🤔 核心思考：为什么必须逆向DP？

### **错误思路：从左上往右下（正向DP）** ❌

**状态定义**：
```
dp[i][j] = 到达(i,j)时的最大剩余血量
```

**为什么不行？**

```
问题：到达某个格子时的"最大血量"不一定能保证后续路径合法！

反例：
格子1  格子2  格子3
 -1     -2     -3
  ↓      ↓      ↓
路径A: -1 → -2 (需要初始血量3，到格子2时剩余0)
路径B: -1 → -3 (需要初始血量4，到格子2时剩余0)

如果只看"到达格子2的最大血量"，两条路径都是0
但路径A只需要初始血量3，路径B需要初始血量4！

正向DP无法追踪"需要的初始血量"，因为：
1. 当前最大血量 ≠ 最小初始血量
2. 路径中任意时刻血量都必须>0，正向DP无法保证这一点
```

**本质问题**：
```
正向DP记录的是"到达当前位置的状态"
但题目要求的是"从起点到终点全程合法的最小初始血量"

这两者不等价！
```

---

### **正确思路：从右下往左上（逆向DP）** ✅

**状态定义**：
```
dp[i][j] = 从(i,j)到达终点(m-1,n-1)所需的最小血量
```

**为什么必须逆向？**

```
1. 终点是确定的：
   - 到达终点后的血量必须>0
   - 所以进入终点时至少需要的血量是确定的

2. 逆向推导是唯一的：
   - 知道"到达终点需要的血量"
   - 可以唯一确定"到达上一个格子需要的血量"
   
3. 可以保证全程合法：
   - 每一步都确保"到达下一格子有足够血量"
   - 自然满足"任意时刻血量>0"的约束
```

---

## 💡 逆向DP详解

### **状态定义**

```
dp[i][j] = 从(i,j)出发，到达终点(m-1,n-1)所需的最小初始血量
```

**关键理解**：
- `dp[i][j]`是指**进入**格子`(i,j)`时的血量
- 不是离开格子后的血量

---

### **状态转移方程推导** ⭐⭐⭐

**思考过程**：

```
1. 我在格子(i,j)，可以往哪走？
   - 向右：到达(i, j+1)
   - 向下：到达(i+1, j)

2. 假设我知道：
   - 从(i, j+1)到终点需要dp[i][j+1]的血量
   - 从(i+1, j)到终点需要dp[i+1][j]的血量

3. 我应该选择哪条路？
   - 选择需要血量更少的那条：min(dp[i][j+1], dp[i+1][j])

4. 进入(i,j)需要多少血量？
   - 离开(i,j)后需要：min(dp[i][j+1], dp[i+1][j])
   - 格子(i,j)的值是：d[i][j]
   - 进入(i,j)需要：dp[i][j] = min(dp[i][j+1], dp[i+1][j]) - d[i][j]
   
   解释：
   - 如果d[i][j]是正数（补血），进入时需要的血量可以少一些
   - 如果d[i][j]是负数（扣血），进入时需要的血量要多一些

5. 但是！血量必须>0！
   - 如果计算出的dp[i][j] <= 0，说明d[i][j]是个大补血
   - 即使只有1滴血进入，也够用
   - 所以：dp[i][j] = max(1, dp[i][j])
```

**状态转移方程**：
```cpp
dp[i][j] = min(dp[i][j+1], dp[i+1][j]) - d[i][j];
dp[i][j] = max(1, dp[i][j]);  // 保证血量至少为1
```

---

### **为什么要 max(1, dp[i][j])？** ⭐⭐⭐

**关键理解**：血量任何时刻都必须 > 0

**示例分析**：

```
格子(i,j)的值：+5（补血5点）
下一步需要的血量：3

计算：
dp[i][j] = 3 - 5 = -2  ❌ 血量不能为负！

实际：
- 进入格子(i,j)时只需要1滴血
- (+5)后变成6滴血
- 足够到达下一个格子（只需3滴）

所以：dp[i][j] = max(1, -2) = 1 ✅
```

**通用规则**：
```
if (dp[i][j] <= 0) {
    // 说明当前格子的补血足够覆盖后续需求
    // 只需要1滴血进入即可
    dp[i][j] = 1;
}
```

---

### **初始化：为什么 dp[m][n-1] = dp[m-1][n] = 1？** ⭐⭐⭐

**关键理解**：虚拟节点的初始化

```
1. 终点是(m-1, n-1)

2. 虚拟节点的位置：
   - dp[m][n-1]：终点下方的虚拟格子
   - dp[m-1][n]：终点右边的虚拟格子

3. 为什么初始化为1？

   计算dp[m-1][n-1]（终点）时：
   dp[m-1][n-1] = min(dp[m][n-1], dp[m-1][n]) - d[m-1][n-1]
   dp[m-1][n-1] = max(1, dp[m-1][n-1])
   
   分析：
   - 如果d[m-1][n-1]是负数（扣血）：
     dp[m-1][n-1] = 1 - d[m-1][n-1]
     例如：d=-5，则需要1-(-5)=6滴血
   
   - 如果d[m-1][n-1]是正数（补血）：
     dp[m-1][n-1] = 1 - d[m-1][n-1]（可能为负）
     然后max(1, ...)确保至少为1
     例如：d=+5，则1-5=-4，max(1,-4)=1
   
   结论：虚拟节点初始化为1，确保终点计算正确

4. 为什么其他虚拟节点是INT_MAX？
   
   因为那些方向是不存在的（越界）
   设为INT_MAX，在min运算中自然被排除
```

**可视化**：
```
地牢：
  [0][0]  [0][1]  [0][2]
  [1][0]  [1][1]  [1][2]
  [2][0]  [2][1]  [2][2](终点)
    ↓       ↓       ↓
 INT_MAX INT_MAX    1      ← dp[3][x]虚拟行

                    1      ← dp[x][3]虚拟列
```

---

### **完整代码实现**

```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& d) {
        int m = d.size(), n = d[0].size();
        
        // 1. 创建dp表：多开一行一列（虚拟节点）
        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
        
        // 2. 初始化：终点的相邻虚拟节点
        dp[m][n-1] = 1;  // 终点下方
        dp[m-1][n] = 1;  // 终点右边
        // （两个都设置，确保终点计算正确）
        
        // 3. 填表：从右下往左上
        for(int i = m-1; i >= 0; i--) {
            for(int j = n-1; j >= 0; j--) {
                // 选择需要血量更少的路径
                dp[i][j] = min(dp[i+1][j], dp[i][j+1]) - d[i][j];
                
                // 保证血量至少为1
                dp[i][j] = max(1, dp[i][j]);
            }
        }
        
        // 4. 返回答案：起点所需的最小血量
        return dp[0][0];
    }
};
```

**时间复杂度**：O(m*n)  
**空间复杂度**：O(m*n)

---

## 🎯 核心知识点总结

### **1. 什么时候必须用逆向DP？** ⭐⭐⭐

```
判断标准：
1. 正向DP无法追踪关键约束
2. 终点状态是确定的，起点状态不确定
3. 需要保证全程满足某种约束（如血量>0）

地下城问题特点：
- ❌ 正向：无法追踪"最小初始血量"
- ✅ 逆向：从终点倒推，唯一确定

对比三角形问题（Day34）：
- 三角形：正向和逆向都可以，选逆向是因为边界简单
- 地下城：只能逆向，因为正向根本不对
```

---

### **2. 逆向DP vs 正向DP对比**

| 特性 | 正向DP（左上→右下） | 逆向DP（右下→左上） |
|-----|-------------------|-------------------|
| **状态定义** | 从起点到当前的状态 | 从当前到终点的需求 |
| **适用场景** | 起点确定，累积计算 | 终点确定，倒推需求 |
| **地下城问题** | ❌ 无法正确计算 | ✅ 唯一正确方法 |
| **三角形问题** | ✅ 可以，但边界复杂 | ✅ 可以，边界简单 |

---

### **3. max(1, dp[i][j]) 的深刻理解** ⭐⭐⭐

```
这不是简单的"保证非负"，而是：

1. 血量的物理意义：
   - 任何时刻血量必须 >= 1（题目要求>0）
   - 不能为0或负数

2. 计算出负数的含义：
   - dp[i][j] <= 0 说明当前格子补血很多
   - 进入时只需要1滴血就够了
   
3. 为什么不是max(0, dp[i][j])？
   - 因为血量必须>0，最小值是1，不是0

4. 必须在每一步都检查：
   - 不能只在最后检查
   - 因为中间步骤也可能出现<=0的情况
```

---

### **4. 虚拟节点初始化的技巧** ⭐⭐⭐

```
地下城问题的初始化：
- 终点相邻的虚拟节点：1（表示"下一步不需要血量"的虚拟状态）
- 其他虚拟节点：INT_MAX（表示越界，不可达）

初始化原则：
- 根据状态转移方程，让终点能正确计算
- dp[m-1][n-1] = min(1, 1) - d[m-1][n-1]
- 然后max(1, ...)保证合法

对比其他问题：
- 路径计数：虚拟节点=0，某个设为1
- 最小路径和：虚拟节点=INT_MAX，起点相邻=0
- 地下城：虚拟节点=INT_MAX，终点相邻=1
```

---

### **5. 状态转移方程的两步法** ⭐⭐⭐

```cpp
// 第一步：根据下一步的需求和当前格子的影响计算
dp[i][j] = min(dp[i+1][j], dp[i][j+1]) - d[i][j];

// 第二步：根据题目约束修正（血量>=1）
dp[i][j] = max(1, dp[i][j]);

为什么要分两步？
1. 第一步：数学计算，可能为负
2. 第二步：物理约束，确保合法

不能合并为一步，否则逻辑不清晰！
```

---

## ⚠️ 易错点记录

### **1. 状态定义错误** ❌

```cpp
// ❌ 错误：定义为"到达(i,j)的最大血量"
dp[i][j] = 到达(i,j)时的最大剩余血量

// ✅ 正确：定义为"从(i,j)到终点需要的最小血量"
dp[i][j] = 从(i,j)到终点所需的最小初始血量
```

---

### **2. 忘记 max(1, dp[i][j])** ❌

```cpp
// ❌ 错误：忘记保证血量>=1
dp[i][j] = min(dp[i+1][j], dp[i][j+1]) - d[i][j];
// 如果d[i][j]是大补血，dp[i][j]可能<=0，不合法！

// ✅ 正确：每一步都要保证
dp[i][j] = min(dp[i+1][j], dp[i][j+1]) - d[i][j];
dp[i][j] = max(1, dp[i][j]);
```

---

### **3. 虚拟节点初始化错误** ❌

```cpp
// ❌ 错误：只初始化一个
dp[m-1][n] = 1;
// 导致终点计算错误

// ✅ 正确：两个都要初始化
dp[m][n-1] = 1;
dp[m-1][n] = 1;
```

---

### **4. 填表方向错误** ❌

```cpp
// ❌ 错误：从左上往右下填表
for(int i = 0; i < m; i++) {
    for(int j = 0; j < n; j++) {
        // 依赖dp[i+1][j]和dp[i][j+1]，但它们还没计算！
    }
}

// ✅ 正确：从右下往左上填表
for(int i = m-1; i >= 0; i--) {
    for(int j = n-1; j >= 0; j--) {
        // dp[i+1][j]和dp[i][j+1]已经计算过了
    }
}
```

---

## 💡 收获与反思

**学习感悟**：

1. **逆向DP不是可选的优化，有时是必需的** ⭐⭐⭐
   - Day34的三角形：逆向是为了简化边界
   - Day35的地下城：逆向是唯一正确方法
   - 理解了逆向DP的本质：从确定的终点倒推不确定的起点

2. **状态定义决定一切**
   - 正向定义："到达当前的状态"（可能不够）
   - 逆向定义："从当前到终点的需求"（更本质）
   - 地下城问题展示了状态定义的重要性

3. **约束条件的处理**
   - `max(1, dp[i][j])`不是简单的边界处理
   - 是题目约束（血量>0）的体现
   - 每一步都要检查，不能只在最后检查

4. **虚拟节点初始化的灵活性**
   - 不同问题，虚拟节点初始化不同
   - 关键是让边界格子能正确计算
   - 地下城：终点相邻=1，其他=INT_MAX

---

## 📚 知识体系更新

**DP方法论v1.3 → v1.4（预计）**：
- 待补充：逆向DP的必要性判断
- 待补充：地下城问题详解
- 待补充：约束条件的DP处理

**技能树更新**：
```
动态规划
└── 二维DP
    ├── 路径问题（规则网格）
    │   ├── 正向DP（可选）✅
    │   │   ├── 不同路径 II
    │   │   ├── 礼物最大价值
    │   │   └── 最小路径和
    │   ├── 逆向DP（优化边界）✅
    │   │   ├── 三角形最小路径和
    │   │   └── 下降路径最小和
    │   └── 逆向DP（必需）✅ NEW
    │       └── 地下城游戏 ⭐⭐⭐
    └── 其他二维DP模型（待学习）
```

---

## ✅ 完成情况

| 题目 | 难度 | 状态 | 一次AC | 备注 |
|------|------|------|--------|------|
| LeetCode 174 - 地下城游戏 | 困难 | ✅ | ✅ | 理解了逆向DP的必要性 |

---

## 🎯 下一步计划

- [ ] 继续逆向DP问题
- [ ] 或者开始打家劫舍系列
- [ ] 或者转向其他DP模型

---

## 🏆 成长亮点

- ✅ 理解了逆向DP的必要性（不只是优化）⭐⭐⭐
- ✅ 掌握了状态定义对问题的决定性影响
- ✅ 学会了约束条件在DP中的处理（max(1, dp[i][j])）
- ✅ 理解了为什么正向DP在某些问题上根本不行

---

## 📊 今日总结

**完成题目**：1道困难题（地下城游戏）  
**核心突破**：理解逆向DP的必要性  
**关键技能**：状态定义 + 约束处理

**今日最大收获**：
地下城问题完美展示了"为什么有些问题必须用逆向DP"：
- 正向DP：无法追踪"最小初始血量"，因为当前最大血量≠最小初始需求
- 逆向DP：从终点倒推，唯一确定每一步的需求
- 关键：终点状态确定，起点状态不确定 → 必须逆向

**对比Day34**：
- Day34三角形：逆向是为了简化（两种方向都对）
- Day35地下城：逆向是必需的（正向根本不对）

**DP理解深化**：
- 状态定义决定一切
- 约束条件要融入状态转移
- 虚拟节点初始化要根据问题灵活调整

---

> **今日状态**：逆向DP从理解到精通！困难题一次AC！🚀🔥

