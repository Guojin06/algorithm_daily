# Day37 - 多状态DP进阶 + 子数组系列

**日期**：2025年11月6日  
**学习重点**：多状态DP进阶（股票系列） + 子数组/子序列问题入门

---

## 📋 今日计划

### 多状态DP进阶
- [ ] 买卖股票的最佳时机系列（多状态DP深入）

### 新题型：子数组/子序列系列
- [ ] 最大子数组和（经典DP）
- [ ] 环形子数组的最大和
- [ ] 乘积最大子数组

---

## 🎯 学习目标

1. 深入理解多状态DP在股票问题中的应用
2. 掌握子数组问题的DP建模方法
3. 理解"连续子数组"与"子序列"的区别
4. 学习正负数、乘积等特殊情况的处理

---

## 📝 题目解答

---

## 一、买卖股票系列（多状态DP）

### 题目1：买卖股票的最佳时机含手续费 ⭐⭐⭐

**题目链接**：[LeetCode 714 - 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

**题目描述**：  
给定一个整数数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格；整数 `fee` 代表交易股票的手续费用。

你可以无限次地完成交易，但每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**示例**：
```
输入：prices = [1,3,2,8,4,9], fee = 2
输出：8
解释：最大利润 = ((8-1)-2) + ((9-4)-2) = 8
```

---

### 1.1 核心思路

**问题特点**：
- 可以无限次买卖（类似"买卖股票II"）
- 每次交易需要支付手续费
- 手续费只影响转移方程，不影响状态数量

**状态设计**：
```cpp
f[i] = 第i天持有股票的最大利润
g[i] = 第i天不持有股票的最大利润
```

**为什么只需要2个状态？**
- 没有冷冻期约束，任何时候都可以买入
- 手续费只是在交易时扣除，不需要额外状态
- 比"冷冻期版本"简单！

**状态转移推导**：

**对于 f[i]（持有股票）**：
- 来源1：昨天就持有，今天不操作 → `f[i-1]`
- 来源2：昨天不持有，今天买入 → `g[i-1] - prices[i]`
- **转移方程**：`f[i] = max(f[i-1], g[i-1] - prices[i])`

**对于 g[i]（不持有股票）**：
- 来源1：昨天就不持有，今天不操作 → `g[i-1]`
- 来源2：昨天持有，今天卖出 → `f[i-1] + prices[i] - fee` ⭐
  - **关键**：卖出时要扣除手续费！
- **转移方程**：`g[i] = max(g[i-1], f[i-1] + prices[i] - fee)`

**初始化**：
```cpp
f[0] = -prices[0];  // 第0天买入，花费prices[0]
g[0] = 0;            // 第0天不操作
```

**答案**：`g[n-1]`（最后一天不持有股票）

---

### 1.2 AC代码

**版本1：基础DP（O(n) 空间）**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if(n == 0) return 0;
        
        // 1. 创建dp表
        vector<int> f(n);  // 持有股票
        vector<int> g(n);  // 不持有股票
        
        // 2. 初始化
        f[0] = -prices[0];  // 第0天买入
        g[0] = 0;            // 第0天不操作
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            f[i] = max(f[i-1], g[i-1] - prices[i]);
            g[i] = max(g[i-1], f[i-1] + prices[i] - fee);  // 卖出扣手续费
        }
        
        // 4. 返回答案
        return g[n-1];  // 最后不持有股票
    }
};
```

**版本2：空间优化（O(1) 空间）** ⭐推荐

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if(n == 0) return 0;
        
        int f = -prices[0];  // 持有股票
        int g = 0;            // 不持有股票
        
        for(int i = 1; i < n; i++) {
            int new_f = max(f, g - prices[i]);
            int new_g = max(g, f + prices[i] - fee);
            
            f = new_f;
            g = new_g;
        }
        
        return g;
    }
};
```

---

### 1.3 复杂度分析

- **时间复杂度**：O(n)，遍历一次数组
- **空间复杂度**：O(1)（优化版本）/ O(n)（基础版本）

---

### 1.4 手动验证

**示例**：`prices = [1, 3, 2, 8, 4, 9], fee = 2`

| i | prices[i] | f[i] 计算 | f[i] | g[i] 计算 | g[i] | 说明 |
|---|-----------|-----------|------|-----------|------|------|
| 0 | 1 | 初始化 | -1 | 初始化 | 0 | 第0天买入 |
| 1 | 3 | max(-1, 0-3)=-1 | -1 | max(0, -1+3-2)=0 | 0 | 持有不动 |
| 2 | 2 | max(-1, 0-2)=-1 | -1 | max(0, -1+2-2)=0 | 0 | 持有不动 |
| 3 | 8 | max(-1, 0-8)=-1 | -1 | max(0, -1+8-2)=5 | 5 | 卖出得利 |
| 4 | 4 | max(-1, 5-4)=1 | 1 | max(5, -1+4-2)=5 | 5 | 再次买入 |
| 5 | 9 | max(1, 5-9)=1 | 1 | max(5, 1+9-2)=8 | 8 | 卖出得利 |

**答案**：`g[5] = 8` ✅

**交易过程**：
- 第0天买入（花费1）
- 第3天卖出（收入8，手续费2，净利润5）
- 第4天买入（花费4）
- 第5天卖出（收入9，手续费2，净利润3）
- **总利润**：5 + 3 = 8 ✅

---

### 1.5 关键点总结

**1. 手续费的处理**
```cpp
// 方式1：卖出时扣除（推荐）
g[i] = max(g[i-1], f[i-1] + prices[i] - fee);

// 方式2：买入时扣除（等价）
f[i] = max(f[i-1], g[i-1] - prices[i] - fee);

两种方式结果相同！选择一种即可。
```

**2. 与其他股票问题的对比**

| 题目 | 约束 | 状态数量 | 核心区别 |
|------|------|---------|---------|
| 买卖股票II | 无限次交易，无手续费 | 2个 | 最简单 |
| **买卖股票+手续费** | 无限次交易，有手续费 | 2个 | 转移时扣费用 |
| 买卖股票+冷冻期 | 无限次交易，有冷冻期 | 3个 | 需要冷冻期状态 |

**3. 状态转移的理解**
```
f[i]（持有）：
  - 继续持有：f[i-1]
  - 今天买入：g[i-1] - prices[i]
  
g[i]（不持有）：
  - 继续不持有：g[i-1]
  - 今天卖出：f[i-1] + prices[i] - fee  ← 关键：扣费用
```

**4. 空间优化的技巧**
- 观察到 `f[i]` 和 `g[i]` 只依赖 `f[i-1]` 和 `g[i-1]`
- 用滚动变量 `f, g` 替代数组
- 注意要用临时变量 `new_f, new_g` 避免覆盖

**5. 易错点** ⚠️
```cpp
// ❌ 错误：忘记扣手续费
g[i] = max(g[i-1], f[i-1] + prices[i]);

// ✅ 正确：卖出时扣手续费
g[i] = max(g[i-1], f[i-1] + prices[i] - fee);
```

---

### 题目2：买卖股票的最佳时机 III ⭐⭐⭐ (Hard)

**题目链接**：[LeetCode 123 - 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

**题目描述**：  
给定一个数组，它的第 `i` 个元素是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你**最多可以完成两笔交易**。

**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例**：
```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第4天（股票价格=0）买入，第6天（股票价格=3）卖出，利润=3-0=3。
     然后在第7天（股票价格=1）买入，第8天（股票价格=4）卖出，利润=4-1=3。
     总利润 = 3 + 3 = 6
```

---

### 2.1 核心思路

**问题特点**：
- **最多完成2次交易**（这是核心约束！）
- 1次交易 = 买入 + 卖出
- 必须按顺序：买1 → 卖1 → 买2 → 卖2

**难点分析**：
1. 如何区分"第1次交易"和"第2次交易"？
2. 如何确保交易顺序（先完成第1次，再进行第2次）？
3. 状态如何设计才能覆盖所有情况？

---

**状态设计（4个状态）** ⭐⭐⭐

这是本题的核心！需要用**4个状态**来完整描述：

```cpp
f1[i] = 第i天，第1次买入后的最大利润（持有第1次股票）
g1[i] = 第i天，第1次卖出后的最大利润（完成第1次交易）
f2[i] = 第i天，第2次买入后的最大利润（持有第2次股票）
g2[i] = 第i天，第2次卖出后的最大利润（完成第2次交易）
```

**状态流转顺序**：
```
初始状态(0) → f1(第1次买入) → g1(第1次卖出) → f2(第2次买入) → g2(第2次卖出)
```

**为什么需要4个状态？**
- 2次交易，每次交易有"持有"和"不持有"2种状态
- 必须区分第1次和第2次，否则无法保证交易顺序
- 4个状态形成一条"状态链"，确保逻辑正确

---

**状态转移推导** ⭐⭐⭐

**对于 f1[i]（第1次持有股票）**：
- 来源1：昨天就持有第1次股票 → `f1[i-1]`
- 来源2：今天第1次买入 → `0 - prices[i] = -prices[i]`
  - 注意：第1次买入是从初始状态0转移！
- **转移方程**：`f1[i] = max(f1[i-1], -prices[i])`

**对于 g1[i]（完成第1次交易）**：
- 来源1：昨天就完成第1次交易 → `g1[i-1]`
- 来源2：今天卖出第1次股票 → `f1[i-1] + prices[i]`
- **转移方程**：`g1[i] = max(g1[i-1], f1[i-1] + prices[i])`

**对于 f2[i]（第2次持有股票）**：
- 来源1：昨天就持有第2次股票 → `f2[i-1]`
- 来源2：今天第2次买入 → `g1[i-1] - prices[i]`
  - **关键**：必须从g1转移，确保已完成第1次交易！
- **转移方程**：`f2[i] = max(f2[i-1], g1[i-1] - prices[i])`

**对于 g2[i]（完成第2次交易）**：
- 来源1：昨天就完成第2次交易 → `g2[i-1]`
- 来源2：今天卖出第2次股票 → `f2[i-1] + prices[i]`
- **转移方程**：`g2[i] = max(g2[i-1], f2[i-1] + prices[i])`

---

**初始化分析** ⭐⭐⭐

```cpp
f1[0] = -prices[0];  // 第0天买入第1次，花费prices[0]
g1[0] = 0;            // 第0天未完成第1次交易
f2[0] = -prices[0];  // 第0天买入第2次（等价于同一天买入又卖出，再买入）
g2[0] = 0;            // 第0天未完成第2次交易
```

**为什么 f2[0] = -prices[0]？**
- 理论上第0天不可能完成第1次交易后再买入第2次
- 但设为 `-prices[0]` 是为了逻辑一致性
- 相当于：第0天买入→立即卖出（利润0）→再买入
- 结果仍然是花费 `prices[0]`

**答案**：`g2[n-1]`（最多完成2次交易的最大利润）

---

### 2.2 AC代码

**版本1：基础DP（O(n) 空间）**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 需要四个状态
        // f1[i] = 第i天，第一次买入后的最大利润（持有第一次股票）
        // g1[i] = 第i天，第一次卖出后的最大利润（完成第一次交易）
        // f2[i] = 第i天，第2次买入后的最大利润（持有第二次股票）
        // g2[i] = 第i天，第2次卖出后的最大利润（完成第二次股票交易）
        
        // 状态顺序：f1 -> g1 -> f2 -> g2
        // f1从初始状态（0）转移
        // g1从f1转移
        // f2从g1转移（必须完成第1次交易）
        // g2从f2转移
        
        int n = prices.size();
        if(n == 0) return 0;
        
        // 1. 创建dp表
        vector<int> f1(n), g1(n), f2(n), g2(n);
        
        // 2. 初始化
        f1[0] = -prices[0];  // 第一次买入
        g1[0] = 0;            // 第一次卖出（未卖出）
        f2[0] = -prices[0];  // 第2次买入
        g2[0] = 0;            // 第2次卖出（未卖出）
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            f1[i] = max(f1[i-1], -prices[i]);
            g1[i] = max(g1[i-1], f1[i-1] + prices[i]);
            f2[i] = max(f2[i-1], g1[i-1] - prices[i]);
            g2[i] = max(g2[i-1], f2[i-1] + prices[i]);
        }
        
        // 4. 返回答案
        return g2[n-1];  // 最多完成2次交易
    }
};
```

**版本2：空间优化（O(1) 空间）** ⭐推荐

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        
        int f1 = -prices[0], g1 = 0;
        int f2 = -prices[0], g2 = 0;
        
        for(int i = 1; i < n; i++) {
            int new_f1 = max(f1, -prices[i]);
            int new_g1 = max(g1, f1 + prices[i]);
            int new_f2 = max(f2, g1 - prices[i]);
            int new_g2 = max(g2, f2 + prices[i]);
            
            f1 = new_f1;
            g1 = new_g1;
            f2 = new_f2;
            g2 = new_g2;
        }
        
        return g2;
    }
};
```

---

### 2.3 复杂度分析

- **时间复杂度**：O(n)，遍历一次数组
- **空间复杂度**：O(1)（优化版本）/ O(n)（基础版本）

---

### 2.4 手动验证

**示例**：`prices = [3, 3, 5, 0, 0, 3, 1, 4]`

| i | prices[i] | f1[i] | g1[i] | f2[i] | g2[i] | 说明 |
|---|-----------|-------|-------|-------|-------|------|
| 0 | 3 | -3 | 0 | -3 | 0 | 初始化 |
| 1 | 3 | -3 | 0 | -3 | 0 | 价格不变，无操作 |
| 2 | 5 | -3 | 2 | -3 | 2 | g1=2（第1次卖出利润2），g2=2 |
| 3 | 0 | -3 | 2 | 2 | 2 | f2=2（g1=2，买入0，利润2） |
| 4 | 0 | -3 | 2 | 2 | 2 | 无变化 |
| 5 | 3 | -3 | 2 | 2 | 5 | g2=5（f2=2，卖出3，利润5） |
| 6 | 1 | -3 | 2 | 2 | 5 | 无更优操作 |
| 7 | 4 | -3 | 2 | 2 | 6 | g2=6（f2=2，卖出4，利润6） |

**答案**：`g2[7] = 6` ✅

**最优策略**：
- 第1次交易：第0天买入(3)，第2天卖出(5)，利润=2
- 第2次交易：第3天买入(0)，第7天卖出(4)，利润=4
- **总利润**：2 + 4 = 6 ✅

---

### 2.5 关键点总结

**1. 状态设计的核心思想** ⭐⭐⭐
```
问题：最多k次交易
策略：设计2k个状态

k=1: f1, g1 (2个状态)
k=2: f1, g1, f2, g2 (4个状态)
k=3: f1, g1, f2, g2, f3, g3 (6个状态)
...

规律：
- fi: 第i次买入后的最大利润
- gi: 第i次卖出后的最大利润
- 形成状态链：f1→g1→f2→g2→...→fk→gk
```

**2. 状态转移的依赖关系**
```
f1[i] 依赖 初始状态(0)
g1[i] 依赖 f1[i-1]
f2[i] 依赖 g1[i-1]  ← 关键：确保先完成第1次交易
g2[i] 依赖 f2[i-1]

依赖链：0 → f1 → g1 → f2 → g2
```

**3. 初始化的技巧**
```cpp
f1[0] = -prices[0];  // 直接买入
g1[0] = 0;            // 未交易
f2[0] = -prices[0];  // 等价于买入→卖出→再买入
g2[0] = 0;            // 未完成第2次交易
```

**4. 与其他股票问题的对比**

| 题目 | 交易次数 | 状态数量 | 核心难点 |
|------|---------|---------|---------|
| 买卖股票I | 1次 | 2个 | 找最低买入，最高卖出 |
| 买卖股票II | 无限次 | 2个 | 每次上涨都交易 |
| **买卖股票III** | **2次** | **4个** | **区分交易次数** ⭐ |
| 买卖股票IV | k次 | 2k个 | 推广到k次交易 |
| 买卖股票+手续费 | 无限次+手续费 | 2个 | 转移时扣费用 |
| 买卖股票+冷冻期 | 无限次+冷冻期 | 3个 | 冷冻期状态 |

**5. 状态转移的记忆口诀**
```
f1: 从0买，或继续持有
g1: 从f1卖，或继续不持有
f2: 从g1买，或继续持有  ← 关键：从g1转移
g2: 从f2卖，或继续不持有
```

**6. 易错点** ⚠️

```cpp
// ❌ 错误：f2从初始状态转移（允许跳过第1次交易）
f2[i] = max(f2[i-1], -prices[i]);

// ✅ 正确：f2从g1转移（确保先完成第1次交易）
f2[i] = max(f2[i-1], g1[i-1] - prices[i]);
```

```cpp
// ❌ 错误：返回max(g1[n-1], g2[n-1])
// 问题：题目要求"最多2次"，g2已经包含了0次、1次、2次的最优解

// ✅ 正确：只返回g2[n-1]
return g2[n-1];
```

**7. 为什么g2[n-1]就是答案？** ⭐⭐⭐

```
g2[i] = max(g2[i-1], f2[i-1] + prices[i])

这个max已经包含了：
- g2[i-1]：不进行第2次交易（可能只交易0次或1次）
- f2[i-1] + prices[i]：进行第2次交易

所以g2[n-1]自然包含了"最多2次"的所有情况！
不需要再 max(g1[n-1], g2[n-1])！
```

---

### 题目3：买卖股票的最佳时机 II ⭐⭐⭐

**题目链接**：[LeetCode 122 - 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

**题目描述**：  
给你一个整数数组 `prices`，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候**最多只能持有一股**股票。你也可以先购买，然后在**同一天**出售。

返回你能获得的**最大利润**。

**示例**：
```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第2天（股票价格=1）买入，第3天（股票价格=5）卖出，利润=5-1=4。
     然后在第4天（股票价格=3）买入，第5天（股票价格=6）卖出，利润=6-3=3。
     总利润 = 4 + 3 = 7
```

---

### 3.1 核心思路

**问题特点**：
- 可以**无限次**买卖股票
- 没有手续费、没有冷冻期、没有交易次数限制
- 这是**股票系列中最简单**的问题！

**关键洞察** ⭐⭐⭐：
```
问题：如何获得最大利润？
答案：把所有上涨的差价都赚到！

例如：[1, 2, 3, 4, 5]
- 贪心思路：(2-1) + (3-2) + (4-3) + (5-4) = 4
- 等价于：第1天买入，第5天卖出，利润 = 5-1 = 4

核心：每次价格上涨，就是一次赚钱机会！
```

---

### 3.2 方法1：贪心算法（推荐）⭐⭐⭐

**算法思想**：
- 遍历数组，只要今天价格比昨天高，就累加差价
- 相当于：每次上涨都进行一次"昨天买入，今天卖出"

**为什么贪心是正确的？**
```
多次小交易的总利润 = 一次大交易的利润

例如：[1, 2, 3, 4]
- 多次小交易：(2-1)+(3-2)+(4-3) = 1+1+1 = 3
- 一次大交易：4-1 = 3
- 结果相同！✅

所以：把每次上涨都"吃掉"，就能得到最大利润！
```

**AC代码（贪心）**：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        
        // 遍历所有相邻的天数
        for(int i = 1; i < prices.size(); i++) {
            // 只要今天比昨天高，就赚取差价
            if(prices[i] > prices[i-1]) {
                profit += prices[i] - prices[i-1];
            }
        }
        
        return profit;
    }
};
```

**复杂度分析**：
- **时间复杂度**：O(n)，遍历一次数组
- **空间复杂度**：O(1)，只用常数变量

---

### 3.3 方法2：动态规划（2个状态）⭐⭐⭐

**状态定义**：
```cpp
f[i] = 第i天持有股票的最大利润
g[i] = 第i天不持有股票的最大利润
```

**状态转移推导**：

**对于 f[i]（持有股票）**：
- 来源1：昨天就持有，今天不操作 → `f[i-1]`
- 来源2：昨天不持有，今天买入 → `g[i-1] - prices[i]`
  - **关键**：可以从g[i-1]转移，因为可以无限次交易！
- **转移方程**：`f[i] = max(f[i-1], g[i-1] - prices[i])`

**对于 g[i]（不持有股票）**：
- 来源1：昨天就不持有，今天不操作 → `g[i-1]`
- 来源2：昨天持有，今天卖出 → `f[i-1] + prices[i]`
- **转移方程**：`g[i] = max(g[i-1], f[i-1] + prices[i])`

**初始化**：
```cpp
f[0] = -prices[0];  // 第0天买入
g[0] = 0;            // 第0天不操作
```

**答案**：`g[n-1]`（最后一天不持有股票）

---

**AC代码（DP - 基础版）**：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        
        // 1. 创建dp表
        vector<int> f(n);  // 持有股票
        vector<int> g(n);  // 不持有股票
        
        // 2. 初始化
        f[0] = -prices[0];
        g[0] = 0;
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            f[i] = max(f[i-1], g[i-1] - prices[i]);
            g[i] = max(g[i-1], f[i-1] + prices[i]);
        }
        
        // 4. 返回答案
        return g[n-1];
    }
};
```

**AC代码（DP - 空间优化）** ⭐推荐：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        
        int f = -prices[0];  // 持有股票
        int g = 0;            // 不持有股票
        
        for(int i = 1; i < n; i++) {
            int new_f = max(f, g - prices[i]);
            int new_g = max(g, f + prices[i]);
            
            f = new_f;
            g = new_g;
        }
        
        return g;
    }
};
```

**复杂度分析**：
- **时间复杂度**：O(n)，遍历一次数组
- **空间复杂度**：O(1)（优化版本）/ O(n)（基础版本）

---

### 3.4 手动验证

**示例**：`prices = [7, 1, 5, 3, 6, 4]`

#### 贪心方法验证：
```
i=1: prices[1]=1 < prices[0]=7，不操作，profit=0
i=2: prices[2]=5 > prices[1]=1，profit += 5-1=4
i=3: prices[3]=3 < prices[2]=5，不操作，profit=4
i=4: prices[4]=6 > prices[3]=3，profit += 6-3=7
i=5: prices[5]=4 < prices[4]=6，不操作，profit=7

答案：7 ✅
```

#### DP方法验证：

| i | prices[i] | f[i] 计算 | f[i] | g[i] 计算 | g[i] | 说明 |
|---|-----------|-----------|------|-----------|------|------|
| 0 | 7 | 初始化 | -7 | 初始化 | 0 | 第0天买入 |
| 1 | 1 | max(-7, 0-1)=-1 | -1 | max(0, -7+1)=0 | 0 | 换成低价买入 |
| 2 | 5 | max(-1, 0-5)=-1 | -1 | max(0, -1+5)=4 | 4 | 卖出得利 |
| 3 | 3 | max(-1, 4-3)=1 | 1 | max(4, -1+3)=4 | 4 | 再次买入 |
| 4 | 6 | max(1, 4-6)=1 | 1 | max(4, 1+6)=7 | 7 | 卖出得利 |
| 5 | 4 | max(1, 7-4)=3 | 3 | max(7, 1+4)=7 | 7 | 无更优操作 |

**答案**：`g[5] = 7` ✅

**最优策略**：
- 第1天买入(1)，第2天卖出(5)，利润=4
- 第3天买入(3)，第4天卖出(6)，利润=3
- **总利润**：4 + 3 = 7 ✅

---

### 3.5 关键点总结

**1. 两种方法对比**

| 特性 | 贪心 | DP |
|------|------|-----|
| 代码长度 | 短 ✅ | 稍长 |
| 理解难度 | 简单 ✅ | 需要理解状态 |
| 时间复杂度 | O(n) ✅ | O(n) ✅ |
| 空间复杂度 | O(1) ✅ | O(1) ✅ |
| 扩展性 | 差（只适用无限次） | 好 ✅（可扩展到其他约束） |

**2. 贪心正确性的数学证明** ⭐⭐⭐

```
假设最优策略是：第i天买入，第j天卖出（i < j）

利润 = prices[j] - prices[i]
     = (prices[j] - prices[j-1]) + (prices[j-1] - prices[j-2]) + ... + (prices[i+1] - prices[i])
     = sum of all positive differences

所以：一次大交易 = 多次小交易的累加
贪心策略（累加所有上涨差价）= 最优策略 ✅
```

**3. 与其他股票问题的关系**

```
买卖股票系列难度递进：

买卖股票II（无限次，无约束）
    ↓ 最简单
买卖股票+手续费（无限次，有手续费）
    ↓ 加约束：转移时扣费用
买卖股票+冷冻期（无限次，有冷冻期）
    ↓ 加约束：增加冷冻期状态
买卖股票I（1次交易）
    ↓ 限制次数：简化为找最大差值
买卖股票III（2次交易）
    ↓ 限制次数：4个状态
买卖股票IV（k次交易）
    ↓ 推广：2k个状态 + 优化
```

**4. DP中的关键区别** ⭐⭐⭐

```
买卖股票I（只能1次）：
f[i] = max(f[i-1], -prices[i])     // 只能从0买入
g[i] = max(g[i-1], f[i-1] + prices[i])

买卖股票II（无限次）：
f[i] = max(f[i-1], g[i-1] - prices[i])  // 可以从g[i-1]买入 ⭐
g[i] = max(g[i-1], f[i-1] + prices[i])

区别：f[i]的转移
- 1次：从0转移（-prices[i]）
- 无限次：从g[i-1]转移（g[i-1] - prices[i]）
```

**5. 什么时候用贪心？什么时候用DP？**

```
用贪心：
✅ 无限次交易，无其他约束
✅ 追求代码简洁
✅ 面试快速实现

用DP：
✅ 有额外约束（手续费、冷冻期、交易次数）
✅ 需要统一思路理解股票系列
✅ 为了扩展到其他变种
```

**6. 易错点** ⚠️

```cpp
// ❌ 错误：贪心时忘记判断上涨
profit += prices[i] - prices[i-1];  // 可能加负数！

// ✅ 正确：只累加正差价
if(prices[i] > prices[i-1]) {
    profit += prices[i] - prices[i-1];
}
```

```cpp
// ❌ 错误：DP时从0转移（变成只能1次交易）
f[i] = max(f[i-1], -prices[i]);

// ✅ 正确：从g[i-1]转移（允许无限次）
f[i] = max(f[i-1], g[i-1] - prices[i]);
```

---

## 💡 今日收获

### 核心概念


### 方法论更新


### 易错点


---

## 🔗 相关链接

- [Day36笔记](./Day36-11.5-打家劫舍系列.md)
- [DP方法论v1.6](../DP专题/动态规划方法论体系.md)

---

**学习状态**：进行中 🔥

