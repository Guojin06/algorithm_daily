# Day37 - 多状态DP进阶 + 子数组系列

**日期**：2025年11月6日  
**学习重点**：多状态DP进阶（股票系列） + 子数组/子序列问题入门

---

## 📋 今日计划

### 多状态DP进阶
- [ ] 买卖股票的最佳时机系列（多状态DP深入）

### 新题型：子数组/子序列系列
- [ ] 最大子数组和（经典DP）
- [ ] 环形子数组的最大和
- [ ] 乘积最大子数组

---

## 🎯 学习目标

1. 深入理解多状态DP在股票问题中的应用
2. 掌握子数组问题的DP建模方法
3. 理解"连续子数组"与"子序列"的区别
4. 学习正负数、乘积等特殊情况的处理

---

## 📝 题目解答

---

## 一、买卖股票系列（多状态DP）

### 题目1：买卖股票的最佳时机含手续费 ⭐⭐⭐

**题目链接**：[LeetCode 714 - 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

**题目描述**：  
给定一个整数数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格；整数 `fee` 代表交易股票的手续费用。

你可以无限次地完成交易，但每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**示例**：
```
输入：prices = [1,3,2,8,4,9], fee = 2
输出：8
解释：最大利润 = ((8-1)-2) + ((9-4)-2) = 8
```

---

### 1.1 核心思路

**问题特点**：
- 可以无限次买卖（类似"买卖股票II"）
- 每次交易需要支付手续费
- 手续费只影响转移方程，不影响状态数量

**状态设计**：
```cpp
f[i] = 第i天持有股票的最大利润
g[i] = 第i天不持有股票的最大利润
```

**为什么只需要2个状态？**
- 没有冷冻期约束，任何时候都可以买入
- 手续费只是在交易时扣除，不需要额外状态
- 比"冷冻期版本"简单！

**状态转移推导**：

**对于 f[i]（持有股票）**：
- 来源1：昨天就持有，今天不操作 → `f[i-1]`
- 来源2：昨天不持有，今天买入 → `g[i-1] - prices[i]`
- **转移方程**：`f[i] = max(f[i-1], g[i-1] - prices[i])`

**对于 g[i]（不持有股票）**：
- 来源1：昨天就不持有，今天不操作 → `g[i-1]`
- 来源2：昨天持有，今天卖出 → `f[i-1] + prices[i] - fee` ⭐
  - **关键**：卖出时要扣除手续费！
- **转移方程**：`g[i] = max(g[i-1], f[i-1] + prices[i] - fee)`

**初始化**：
```cpp
f[0] = -prices[0];  // 第0天买入，花费prices[0]
g[0] = 0;            // 第0天不操作
```

**答案**：`g[n-1]`（最后一天不持有股票）

---

### 1.2 AC代码

**版本1：基础DP（O(n) 空间）**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if(n == 0) return 0;
        
        // 1. 创建dp表
        vector<int> f(n);  // 持有股票
        vector<int> g(n);  // 不持有股票
        
        // 2. 初始化
        f[0] = -prices[0];  // 第0天买入
        g[0] = 0;            // 第0天不操作
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            f[i] = max(f[i-1], g[i-1] - prices[i]);
            g[i] = max(g[i-1], f[i-1] + prices[i] - fee);  // 卖出扣手续费
        }
        
        // 4. 返回答案
        return g[n-1];  // 最后不持有股票
    }
};
```

**版本2：空间优化（O(1) 空间）** ⭐推荐

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if(n == 0) return 0;
        
        int f = -prices[0];  // 持有股票
        int g = 0;            // 不持有股票
        
        for(int i = 1; i < n; i++) {
            int new_f = max(f, g - prices[i]);
            int new_g = max(g, f + prices[i] - fee);
            
            f = new_f;
            g = new_g;
        }
        
        return g;
    }
};
```

---

### 1.3 复杂度分析

- **时间复杂度**：O(n)，遍历一次数组
- **空间复杂度**：O(1)（优化版本）/ O(n)（基础版本）

---

### 1.4 手动验证

**示例**：`prices = [1, 3, 2, 8, 4, 9], fee = 2`

| i | prices[i] | f[i] 计算 | f[i] | g[i] 计算 | g[i] | 说明 |
|---|-----------|-----------|------|-----------|------|------|
| 0 | 1 | 初始化 | -1 | 初始化 | 0 | 第0天买入 |
| 1 | 3 | max(-1, 0-3)=-1 | -1 | max(0, -1+3-2)=0 | 0 | 持有不动 |
| 2 | 2 | max(-1, 0-2)=-1 | -1 | max(0, -1+2-2)=0 | 0 | 持有不动 |
| 3 | 8 | max(-1, 0-8)=-1 | -1 | max(0, -1+8-2)=5 | 5 | 卖出得利 |
| 4 | 4 | max(-1, 5-4)=1 | 1 | max(5, -1+4-2)=5 | 5 | 再次买入 |
| 5 | 9 | max(1, 5-9)=1 | 1 | max(5, 1+9-2)=8 | 8 | 卖出得利 |

**答案**：`g[5] = 8` ✅

**交易过程**：
- 第0天买入（花费1）
- 第3天卖出（收入8，手续费2，净利润5）
- 第4天买入（花费4）
- 第5天卖出（收入9，手续费2，净利润3）
- **总利润**：5 + 3 = 8 ✅

---

### 1.5 关键点总结

**1. 手续费的处理**
```cpp
// 方式1：卖出时扣除（推荐）
g[i] = max(g[i-1], f[i-1] + prices[i] - fee);

// 方式2：买入时扣除（等价）
f[i] = max(f[i-1], g[i-1] - prices[i] - fee);

两种方式结果相同！选择一种即可。
```

**2. 与其他股票问题的对比**

| 题目 | 约束 | 状态数量 | 核心区别 |
|------|------|---------|---------|
| 买卖股票II | 无限次交易，无手续费 | 2个 | 最简单 |
| **买卖股票+手续费** | 无限次交易，有手续费 | 2个 | 转移时扣费用 |
| 买卖股票+冷冻期 | 无限次交易，有冷冻期 | 3个 | 需要冷冻期状态 |

**3. 状态转移的理解**
```
f[i]（持有）：
  - 继续持有：f[i-1]
  - 今天买入：g[i-1] - prices[i]
  
g[i]（不持有）：
  - 继续不持有：g[i-1]
  - 今天卖出：f[i-1] + prices[i] - fee  ← 关键：扣费用
```

**4. 空间优化的技巧**
- 观察到 `f[i]` 和 `g[i]` 只依赖 `f[i-1]` 和 `g[i-1]`
- 用滚动变量 `f, g` 替代数组
- 注意要用临时变量 `new_f, new_g` 避免覆盖

**5. 易错点** ⚠️
```cpp
// ❌ 错误：忘记扣手续费
g[i] = max(g[i-1], f[i-1] + prices[i]);

// ✅ 正确：卖出时扣手续费
g[i] = max(g[i-1], f[i-1] + prices[i] - fee);
```

---

### 题目2：买卖股票的最佳时机 III ⭐⭐⭐ (Hard)

**题目链接**：[LeetCode 123 - 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

**题目描述**：  
给定一个数组，它的第 `i` 个元素是一支给定股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你**最多可以完成两笔交易**。

**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例**：
```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第4天（股票价格=0）买入，第6天（股票价格=3）卖出，利润=3-0=3。
     然后在第7天（股票价格=1）买入，第8天（股票价格=4）卖出，利润=4-1=3。
     总利润 = 3 + 3 = 6
```

---

### 2.1 核心思路

**问题特点**：
- **最多完成2次交易**（这是核心约束！）
- 1次交易 = 买入 + 卖出
- 必须按顺序：买1 → 卖1 → 买2 → 卖2

**难点分析**：
1. 如何区分"第1次交易"和"第2次交易"？
2. 如何确保交易顺序（先完成第1次，再进行第2次）？
3. 状态如何设计才能覆盖所有情况？

---

**状态设计（4个状态）** ⭐⭐⭐

这是本题的核心！需要用**4个状态**来完整描述：

```cpp
f1[i] = 第i天，第1次买入后的最大利润（持有第1次股票）
g1[i] = 第i天，第1次卖出后的最大利润（完成第1次交易）
f2[i] = 第i天，第2次买入后的最大利润（持有第2次股票）
g2[i] = 第i天，第2次卖出后的最大利润（完成第2次交易）
```

**状态流转顺序**：
```
初始状态(0) → f1(第1次买入) → g1(第1次卖出) → f2(第2次买入) → g2(第2次卖出)
```

**为什么需要4个状态？**
- 2次交易，每次交易有"持有"和"不持有"2种状态
- 必须区分第1次和第2次，否则无法保证交易顺序
- 4个状态形成一条"状态链"，确保逻辑正确

---

**状态转移推导** ⭐⭐⭐

**对于 f1[i]（第1次持有股票）**：
- 来源1：昨天就持有第1次股票 → `f1[i-1]`
- 来源2：今天第1次买入 → `0 - prices[i] = -prices[i]`
  - 注意：第1次买入是从初始状态0转移！
- **转移方程**：`f1[i] = max(f1[i-1], -prices[i])`

**对于 g1[i]（完成第1次交易）**：
- 来源1：昨天就完成第1次交易 → `g1[i-1]`
- 来源2：今天卖出第1次股票 → `f1[i-1] + prices[i]`
- **转移方程**：`g1[i] = max(g1[i-1], f1[i-1] + prices[i])`

**对于 f2[i]（第2次持有股票）**：
- 来源1：昨天就持有第2次股票 → `f2[i-1]`
- 来源2：今天第2次买入 → `g1[i-1] - prices[i]`
  - **关键**：必须从g1转移，确保已完成第1次交易！
- **转移方程**：`f2[i] = max(f2[i-1], g1[i-1] - prices[i])`

**对于 g2[i]（完成第2次交易）**：
- 来源1：昨天就完成第2次交易 → `g2[i-1]`
- 来源2：今天卖出第2次股票 → `f2[i-1] + prices[i]`
- **转移方程**：`g2[i] = max(g2[i-1], f2[i-1] + prices[i])`

---

**初始化分析** ⭐⭐⭐

```cpp
f1[0] = -prices[0];  // 第0天买入第1次，花费prices[0]
g1[0] = 0;            // 第0天未完成第1次交易
f2[0] = -prices[0];  // 第0天买入第2次（等价于同一天买入又卖出，再买入）
g2[0] = 0;            // 第0天未完成第2次交易
```

**为什么 f2[0] = -prices[0]？**
- 理论上第0天不可能完成第1次交易后再买入第2次
- 但设为 `-prices[0]` 是为了逻辑一致性
- 相当于：第0天买入→立即卖出（利润0）→再买入
- 结果仍然是花费 `prices[0]`

**答案**：`g2[n-1]`（最多完成2次交易的最大利润）

---

### 2.2 AC代码

**版本1：基础DP（O(n) 空间）**

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 需要四个状态
        // f1[i] = 第i天，第一次买入后的最大利润（持有第一次股票）
        // g1[i] = 第i天，第一次卖出后的最大利润（完成第一次交易）
        // f2[i] = 第i天，第2次买入后的最大利润（持有第二次股票）
        // g2[i] = 第i天，第2次卖出后的最大利润（完成第二次股票交易）
        
        // 状态顺序：f1 -> g1 -> f2 -> g2
        // f1从初始状态（0）转移
        // g1从f1转移
        // f2从g1转移（必须完成第1次交易）
        // g2从f2转移
        
        int n = prices.size();
        if(n == 0) return 0;
        
        // 1. 创建dp表
        vector<int> f1(n), g1(n), f2(n), g2(n);
        
        // 2. 初始化
        f1[0] = -prices[0];  // 第一次买入
        g1[0] = 0;            // 第一次卖出（未卖出）
        f2[0] = -prices[0];  // 第2次买入
        g2[0] = 0;            // 第2次卖出（未卖出）
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            f1[i] = max(f1[i-1], -prices[i]);
            g1[i] = max(g1[i-1], f1[i-1] + prices[i]);
            f2[i] = max(f2[i-1], g1[i-1] - prices[i]);
            g2[i] = max(g2[i-1], f2[i-1] + prices[i]);
        }
        
        // 4. 返回答案
        return g2[n-1];  // 最多完成2次交易
    }
};
```

**版本2：空间优化（O(1) 空间）** ⭐推荐

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        
        int f1 = -prices[0], g1 = 0;
        int f2 = -prices[0], g2 = 0;
        
        for(int i = 1; i < n; i++) {
            int new_f1 = max(f1, -prices[i]);
            int new_g1 = max(g1, f1 + prices[i]);
            int new_f2 = max(f2, g1 - prices[i]);
            int new_g2 = max(g2, f2 + prices[i]);
            
            f1 = new_f1;
            g1 = new_g1;
            f2 = new_f2;
            g2 = new_g2;
        }
        
        return g2;
    }
};
```

---

### 2.3 复杂度分析

- **时间复杂度**：O(n)，遍历一次数组
- **空间复杂度**：O(1)（优化版本）/ O(n)（基础版本）

---

### 2.4 手动验证

**示例**：`prices = [3, 3, 5, 0, 0, 3, 1, 4]`

| i | prices[i] | f1[i] | g1[i] | f2[i] | g2[i] | 说明 |
|---|-----------|-------|-------|-------|-------|------|
| 0 | 3 | -3 | 0 | -3 | 0 | 初始化 |
| 1 | 3 | -3 | 0 | -3 | 0 | 价格不变，无操作 |
| 2 | 5 | -3 | 2 | -3 | 2 | g1=2（第1次卖出利润2），g2=2 |
| 3 | 0 | -3 | 2 | 2 | 2 | f2=2（g1=2，买入0，利润2） |
| 4 | 0 | -3 | 2 | 2 | 2 | 无变化 |
| 5 | 3 | -3 | 2 | 2 | 5 | g2=5（f2=2，卖出3，利润5） |
| 6 | 1 | -3 | 2 | 2 | 5 | 无更优操作 |
| 7 | 4 | -3 | 2 | 2 | 6 | g2=6（f2=2，卖出4，利润6） |

**答案**：`g2[7] = 6` ✅

**最优策略**：
- 第1次交易：第0天买入(3)，第2天卖出(5)，利润=2
- 第2次交易：第3天买入(0)，第7天卖出(4)，利润=4
- **总利润**：2 + 4 = 6 ✅

---

### 2.5 关键点总结

**1. 状态设计的核心思想** ⭐⭐⭐
```
问题：最多k次交易
策略：设计2k个状态

k=1: f1, g1 (2个状态)
k=2: f1, g1, f2, g2 (4个状态)
k=3: f1, g1, f2, g2, f3, g3 (6个状态)
...

规律：
- fi: 第i次买入后的最大利润
- gi: 第i次卖出后的最大利润
- 形成状态链：f1→g1→f2→g2→...→fk→gk
```

**2. 状态转移的依赖关系**
```
f1[i] 依赖 初始状态(0)
g1[i] 依赖 f1[i-1]
f2[i] 依赖 g1[i-1]  ← 关键：确保先完成第1次交易
g2[i] 依赖 f2[i-1]

依赖链：0 → f1 → g1 → f2 → g2
```

**3. 初始化的技巧**
```cpp
f1[0] = -prices[0];  // 直接买入
g1[0] = 0;            // 未交易
f2[0] = -prices[0];  // 等价于买入→卖出→再买入
g2[0] = 0;            // 未完成第2次交易
```

**4. 与其他股票问题的对比**

| 题目 | 交易次数 | 状态数量 | 核心难点 |
|------|---------|---------|---------|
| 买卖股票I | 1次 | 2个 | 找最低买入，最高卖出 |
| 买卖股票II | 无限次 | 2个 | 每次上涨都交易 |
| **买卖股票III** | **2次** | **4个** | **区分交易次数** ⭐ |
| 买卖股票IV | k次 | 2k个 | 推广到k次交易 |
| 买卖股票+手续费 | 无限次+手续费 | 2个 | 转移时扣费用 |
| 买卖股票+冷冻期 | 无限次+冷冻期 | 3个 | 冷冻期状态 |

**5. 状态转移的记忆口诀**
```
f1: 从0买，或继续持有
g1: 从f1卖，或继续不持有
f2: 从g1买，或继续持有  ← 关键：从g1转移
g2: 从f2卖，或继续不持有
```

**6. 易错点** ⚠️

```cpp
// ❌ 错误：f2从初始状态转移（允许跳过第1次交易）
f2[i] = max(f2[i-1], -prices[i]);

// ✅ 正确：f2从g1转移（确保先完成第1次交易）
f2[i] = max(f2[i-1], g1[i-1] - prices[i]);
```

```cpp
// ❌ 错误：返回max(g1[n-1], g2[n-1])
// 问题：题目要求"最多2次"，g2已经包含了0次、1次、2次的最优解

// ✅ 正确：只返回g2[n-1]
return g2[n-1];
```

**7. 为什么g2[n-1]就是答案？** ⭐⭐⭐

```
g2[i] = max(g2[i-1], f2[i-1] + prices[i])

这个max已经包含了：
- g2[i-1]：不进行第2次交易（可能只交易0次或1次）
- f2[i-1] + prices[i]：进行第2次交易

所以g2[n-1]自然包含了"最多2次"的所有情况！
不需要再 max(g1[n-1], g2[n-1])！
```

---

### 题目3：买卖股票的最佳时机 II ⭐⭐⭐

**题目链接**：[LeetCode 122 - 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

**题目描述**：  
给你一个整数数组 `prices`，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候**最多只能持有一股**股票。你也可以先购买，然后在**同一天**出售。

返回你能获得的**最大利润**。

**示例**：
```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第2天（股票价格=1）买入，第3天（股票价格=5）卖出，利润=5-1=4。
     然后在第4天（股票价格=3）买入，第5天（股票价格=6）卖出，利润=6-3=3。
     总利润 = 4 + 3 = 7
```

---

### 3.1 核心思路

**问题特点**：
- 可以**无限次**买卖股票
- 没有手续费、没有冷冻期、没有交易次数限制
- 这是**股票系列中最简单**的问题！

**关键洞察** ⭐⭐⭐：
```
问题：如何获得最大利润？
答案：把所有上涨的差价都赚到！

例如：[1, 2, 3, 4, 5]
- 贪心思路：(2-1) + (3-2) + (4-3) + (5-4) = 4
- 等价于：第1天买入，第5天卖出，利润 = 5-1 = 4

核心：每次价格上涨，就是一次赚钱机会！
```

---

### 3.2 方法1：贪心算法（推荐）⭐⭐⭐

**算法思想**：
- 遍历数组，只要今天价格比昨天高，就累加差价
- 相当于：每次上涨都进行一次"昨天买入，今天卖出"

**为什么贪心是正确的？**
```
多次小交易的总利润 = 一次大交易的利润

例如：[1, 2, 3, 4]
- 多次小交易：(2-1)+(3-2)+(4-3) = 1+1+1 = 3
- 一次大交易：4-1 = 3
- 结果相同！✅

所以：把每次上涨都"吃掉"，就能得到最大利润！
```

**AC代码（贪心）**：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0;
        
        // 遍历所有相邻的天数
        for(int i = 1; i < prices.size(); i++) {
            // 只要今天比昨天高，就赚取差价
            if(prices[i] > prices[i-1]) {
                profit += prices[i] - prices[i-1];
            }
        }
        
        return profit;
    }
};
```

**复杂度分析**：
- **时间复杂度**：O(n)，遍历一次数组
- **空间复杂度**：O(1)，只用常数变量

---

### 3.3 方法2：动态规划（2个状态）⭐⭐⭐

**状态定义**：
```cpp
f[i] = 第i天持有股票的最大利润
g[i] = 第i天不持有股票的最大利润
```

**状态转移推导**：

**对于 f[i]（持有股票）**：
- 来源1：昨天就持有，今天不操作 → `f[i-1]`
- 来源2：昨天不持有，今天买入 → `g[i-1] - prices[i]`
  - **关键**：可以从g[i-1]转移，因为可以无限次交易！
- **转移方程**：`f[i] = max(f[i-1], g[i-1] - prices[i])`

**对于 g[i]（不持有股票）**：
- 来源1：昨天就不持有，今天不操作 → `g[i-1]`
- 来源2：昨天持有，今天卖出 → `f[i-1] + prices[i]`
- **转移方程**：`g[i] = max(g[i-1], f[i-1] + prices[i])`

**初始化**：
```cpp
f[0] = -prices[0];  // 第0天买入
g[0] = 0;            // 第0天不操作
```

**答案**：`g[n-1]`（最后一天不持有股票）

---

**AC代码（DP - 基础版）**：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        
        // 1. 创建dp表
        vector<int> f(n);  // 持有股票
        vector<int> g(n);  // 不持有股票
        
        // 2. 初始化
        f[0] = -prices[0];
        g[0] = 0;
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            f[i] = max(f[i-1], g[i-1] - prices[i]);
            g[i] = max(g[i-1], f[i-1] + prices[i]);
        }
        
        // 4. 返回答案
        return g[n-1];
    }
};
```

**AC代码（DP - 空间优化）** ⭐推荐：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        
        int f = -prices[0];  // 持有股票
        int g = 0;            // 不持有股票
        
        for(int i = 1; i < n; i++) {
            int new_f = max(f, g - prices[i]);
            int new_g = max(g, f + prices[i]);
            
            f = new_f;
            g = new_g;
        }
        
        return g;
    }
};
```

**复杂度分析**：
- **时间复杂度**：O(n)，遍历一次数组
- **空间复杂度**：O(1)（优化版本）/ O(n)（基础版本）

---

### 3.4 手动验证

**示例**：`prices = [7, 1, 5, 3, 6, 4]`

#### 贪心方法验证：
```
i=1: prices[1]=1 < prices[0]=7，不操作，profit=0
i=2: prices[2]=5 > prices[1]=1，profit += 5-1=4
i=3: prices[3]=3 < prices[2]=5，不操作，profit=4
i=4: prices[4]=6 > prices[3]=3，profit += 6-3=7
i=5: prices[5]=4 < prices[4]=6，不操作，profit=7

答案：7 ✅
```

#### DP方法验证：

| i | prices[i] | f[i] 计算 | f[i] | g[i] 计算 | g[i] | 说明 |
|---|-----------|-----------|------|-----------|------|------|
| 0 | 7 | 初始化 | -7 | 初始化 | 0 | 第0天买入 |
| 1 | 1 | max(-7, 0-1)=-1 | -1 | max(0, -7+1)=0 | 0 | 换成低价买入 |
| 2 | 5 | max(-1, 0-5)=-1 | -1 | max(0, -1+5)=4 | 4 | 卖出得利 |
| 3 | 3 | max(-1, 4-3)=1 | 1 | max(4, -1+3)=4 | 4 | 再次买入 |
| 4 | 6 | max(1, 4-6)=1 | 1 | max(4, 1+6)=7 | 7 | 卖出得利 |
| 5 | 4 | max(1, 7-4)=3 | 3 | max(7, 1+4)=7 | 7 | 无更优操作 |

**答案**：`g[5] = 7` ✅

**最优策略**：
- 第1天买入(1)，第2天卖出(5)，利润=4
- 第3天买入(3)，第4天卖出(6)，利润=3
- **总利润**：4 + 3 = 7 ✅

---

### 3.5 关键点总结

**1. 两种方法对比**

| 特性 | 贪心 | DP |
|------|------|-----|
| 代码长度 | 短 ✅ | 稍长 |
| 理解难度 | 简单 ✅ | 需要理解状态 |
| 时间复杂度 | O(n) ✅ | O(n) ✅ |
| 空间复杂度 | O(1) ✅ | O(1) ✅ |
| 扩展性 | 差（只适用无限次） | 好 ✅（可扩展到其他约束） |

**2. 贪心正确性的数学证明** ⭐⭐⭐

```
假设最优策略是：第i天买入，第j天卖出（i < j）

利润 = prices[j] - prices[i]
     = (prices[j] - prices[j-1]) + (prices[j-1] - prices[j-2]) + ... + (prices[i+1] - prices[i])
     = sum of all positive differences

所以：一次大交易 = 多次小交易的累加
贪心策略（累加所有上涨差价）= 最优策略 ✅
```

**3. 与其他股票问题的关系**

```
买卖股票系列难度递进：

买卖股票II（无限次，无约束）
    ↓ 最简单
买卖股票+手续费（无限次，有手续费）
    ↓ 加约束：转移时扣费用
买卖股票+冷冻期（无限次，有冷冻期）
    ↓ 加约束：增加冷冻期状态
买卖股票I（1次交易）
    ↓ 限制次数：简化为找最大差值
买卖股票III（2次交易）
    ↓ 限制次数：4个状态
买卖股票IV（k次交易）
    ↓ 推广：2k个状态 + 优化
```

**4. DP中的关键区别** ⭐⭐⭐

```
买卖股票I（只能1次）：
f[i] = max(f[i-1], -prices[i])     // 只能从0买入
g[i] = max(g[i-1], f[i-1] + prices[i])

买卖股票II（无限次）：
f[i] = max(f[i-1], g[i-1] - prices[i])  // 可以从g[i-1]买入 ⭐
g[i] = max(g[i-1], f[i-1] + prices[i])

区别：f[i]的转移
- 1次：从0转移（-prices[i]）
- 无限次：从g[i-1]转移（g[i-1] - prices[i]）
```

**5. 什么时候用贪心？什么时候用DP？**

```
用贪心：
✅ 无限次交易，无其他约束
✅ 追求代码简洁
✅ 面试快速实现

用DP：
✅ 有额外约束（手续费、冷冻期、交易次数）
✅ 需要统一思路理解股票系列
✅ 为了扩展到其他变种
```

**6. 易错点** ⚠️

```cpp
// ❌ 错误：贪心时忘记判断上涨
profit += prices[i] - prices[i-1];  // 可能加负数！

// ✅ 正确：只累加正差价
if(prices[i] > prices[i-1]) {
    profit += prices[i] - prices[i-1];
}
```

```cpp
// ❌ 错误：DP时从0转移（变成只能1次交易）
f[i] = max(f[i-1], -prices[i]);

// ✅ 正确：从g[i-1]转移（允许无限次）
f[i] = max(f[i-1], g[i-1] - prices[i]);
```

---

### 题目4：买卖股票的最佳时机 IV ⭐⭐⭐

**题目链接**：[LeetCode 188 - 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

**题目描述**：  
给你一个整数数组 `prices` 和一个整数 `k`，其中 `prices[i]` 是某支股票第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意**：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例**：
```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
     总利润 = 4 + 3 = 7
```

---

### 4.1 完整解题思路

这道题是**股票系列的终极形态**，是股票III（k=2）的推广！

#### 🎯 第一步：联系已知问题

**回顾股票III（k=2）**：
- 用了4个状态：f1, g1, f2, g2
- 状态链条：`初始 → 买1(f1) → 卖1(g1) → 买2(f2) → 卖2(g2)`

**推广到k次交易**：
- 需要2k个状态：f[1..k], g[1..k]
- 状态链条：`初始(g[0]) → 买1(f[1]) → 卖1(g[1]) → ... → 买k(f[k]) → 卖k(g[k])`

---

#### 🧠 第二步：状态设计

**状态定义**：
```cpp
f[j] = 第i天第j次买入后的最大利润（1 ≤ j ≤ k）
g[j] = 第i天完成j次交易后的最大利润（1 ≤ j ≤ k）
g[0] = 0  // 特殊：没有进行任何交易
```

**关键理解**：
- `f[j]` 表示"持有股票"的状态（第j次买入后）
- `g[j]` 表示"不持有股票"的状态（完成j次交易）
- 状态之间的依赖：`f[j]` 依赖 `g[j-1]`，`g[j]` 依赖 `f[j]`

---

#### 📐 第三步：状态转移推导（核心）⭐⭐⭐

**对于 f[j]（第j次买入后的利润）**：

**问：今天处于"第j次买入"状态，从哪来？**

```
可能1：昨天就是"第j次买入"状态，今天不操作（继续持有）
       → 利润 = f[j]（昨天的f[j]）

可能2：昨天是"完成j-1次交易"状态，今天进行第j次买入
       → 昨天的利润 = g[j-1]（完成j-1次）
       → 今天买入花费 prices[i]
       → 利润 = g[j-1] - prices[i]

取最优：f[j] = max(f[j], g[j-1] - prices[i])
```

**关键点**：
- 必须从 `g[j-1]` 转移（不是 `g[j]`）
- 因为要进行第j次买入，必须先完成j-1次交易！

---

**对于 g[j]（完成j次交易的利润）**：

**问：今天"完成j次交易"，从哪来？**

```
可能1：昨天就"完成j次交易"了，今天不操作
       → 利润 = g[j]（昨天的g[j]）

可能2：昨天是"第j次买入"状态，今天卖出完成第j次
       → 昨天的利润 = f[j]（第j次买入）
       → 今天卖出收入 prices[i]
       → 利润 = f[j] + prices[i]

取最优：g[j] = max(g[j], f[j] + prices[i])
```

**关键点**：
- 必须从 `f[j]` 转移（不是 `f[j-1]`）
- 因为完成第j次交易，必须先进行第j次买入，然后卖出！

---

**转移方程总结**：
```cpp
f[j] = max(f[j], g[j-1] - prices[i])  // 从自己或g[j-1]转移
g[j] = max(g[j], f[j] + prices[i])     // 从自己或f[j]转移
```

---

#### 🔧 第四步：空间优化（二维→一维）⭐⭐⭐

**理论上的二维DP**：
```cpp
f[i][j] = max(f[i-1][j], g[i-1][j-1] - prices[i])
g[i][j] = max(g[i-1][j], f[i-1][j] + prices[i])
```

**观察**：`f[i][j]` 只依赖 `i-1` 行

**优化**：用一维数组，滚动更新
```cpp
vector<int> f(k+1);
vector<int> g(k+1);
```

---

#### 🔄 第五步：确定更新顺序（从后往前）⭐⭐⭐

**依赖关系分析**：
```cpp
f[j] = max(f[j], g[j-1] - prices[i])
       ↑         ↑
       自己      更小的索引
```

**关键问题**：`f[j]` 依赖 `g[j-1]`（索引更小）

**如果从前往后（j: 1→2→3）**：
```
j=1时：更新g[1] → g[1]变成"今天"的
j=2时：f[2]需要g[1] → 但g[1]已经是"今天"的了！❌
```

**如果从后往前（j: k→...→1）**：
```
j=k时：f[k]需要g[k-1] → g[k-1]还是"昨天"的 ✅
j=k-1时：f[k-1]需要g[k-2] → g[k-2]还是"昨天"的 ✅
...
```

**结论**：必须从后往前！

---

#### 💾 第六步：为什么需要临时变量？⭐⭐⭐

**问题**：
```cpp
for(int j = k; j >= 1; j--) {
    f[j] = max(f[j], g[j-1] - prices[i]);  // f[j]变成"今天"的
    g[j] = max(g[j], f[j] + prices[i]);     // 这里的f[j]是"今天"还是"昨天"？
}
```

**分析**：
- 第一行更新了 `f[j]`，变成"今天"的值
- 第二行立即使用 `f[j]`，但应该用"昨天"的值！
- 矛盾！

**解决方案：用临时变量**：
```cpp
for(int j = k; j >= 1; j--) {
    int new_f = max(f[j], g[j-1] - prices[i]);  // 计算，不修改
    int new_g = max(g[j], f[j] + prices[i]);     // f[j]还是"昨天"的 ✅
    
    f[j] = new_f;  // 统一更新
    g[j] = new_g;
}
```

**原理**：
- 先用"昨天"的值计算所有"今天"的值
- 然后统一更新原数组
- 保证计算过程中用的都是"昨天"的值

---

#### 🚀 第七步：特殊优化（k >= n/2）⭐

**观察**：
```
n天最多进行多少次完整交易？
答案：n/2次（买1天+卖1天=2天）

如果k >= n/2，意味着k足够大，等价于"无限次"交易！
```

**优化**：
```cpp
if(k >= n/2) {
    return maxProfitUnlimited(prices);  // 用贪心（股票II）
}
```

**好处**：
- 避免DP数组过大
- 贪心算法更快（O(n) vs O(nk)）

---

### 4.2 AC代码

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if(n == 0 || k == 0) return 0;
        
        // 优化：k太大时等价于无限次交易
        if(k >= n/2) {
            return maxProfitUnlimited(prices);
        }
        
        // 1. 创建dp表
        vector<int> f(k+1);  // f[j]: 第j次买入后的最大利润
        vector<int> g(k+1);  // g[j]: 完成j次交易的最大利润
        
        // 2. 初始化
        g[0] = 0;  // 没有交易，利润为0
        for(int j = 1; j <= k; j++) {
            f[j] = -prices[0];  // 第0天买入
            g[j] = 0;            // 第0天未完成交易
        }
        
        // 3. 填表（从后往前，用临时变量）
        for(int i = 1; i < n; i++) {
            for(int j = k; j >= 1; j--) {
                int new_f = max(f[j], g[j-1] - prices[i]);
                int new_g = max(g[j], f[j] + prices[i]);
                
                f[j] = new_f;
                g[j] = new_g;
            }
        }
        
        // 4. 返回答案
        return g[k];  // 最多完成k次交易
    }
    
private:
    // 无限次交易的贪心方法（股票II）
    int maxProfitUnlimited(vector<int>& prices) {
        int profit = 0;
        for(int i = 1; i < prices.size(); i++) {
            if(prices[i] > prices[i-1]) {
                profit += prices[i] - prices[i-1];
            }
        }
        return profit;
    }
};
```

---

### 4.3 复杂度分析

**时间复杂度**：
- 当 `k < n/2` 时：O(n × k)
  - 外层循环n次（天数）
  - 内层循环k次（交易次数）
- 当 `k >= n/2` 时：O(n)（贪心）

**空间复杂度**：O(k)
- 两个长度为k+1的数组：`f` 和 `g`

---

### 4.4 手动模拟（理解状态转移）

**输入**：k=2, prices=[3,2,6,5,0,3]

#### 初始化（i=0, prices[0]=3）：
```
g[0] = 0
f[1] = -3, g[1] = 0
f[2] = -3, g[2] = 0
```

#### i=1, prices[1]=2（从后往前）：

**j=2**：
```
new_f = max(f[2], g[1] - 2) = max(-3, 0 - 2) = -2
new_g = max(g[2], f[2] + 2) = max(0, -3 + 2) = 0
→ f[2] = -2, g[2] = 0
```

**j=1**：
```
new_f = max(f[1], g[0] - 2) = max(-3, 0 - 2) = -2
new_g = max(g[1], f[1] + 2) = max(0, -3 + 2) = 0
→ f[1] = -2, g[1] = 0
```

**状态**：f[1]=-2, g[1]=0, f[2]=-2, g[2]=0

---

#### i=2, prices[2]=6：

**j=2**：
```
new_f = max(-2, 0 - 6) = -2
new_g = max(0, -2 + 6) = 4
→ f[2] = -2, g[2] = 4
```

**j=1**：
```
new_f = max(-2, 0 - 6) = -2
new_g = max(0, -2 + 6) = 4
→ f[1] = -2, g[1] = 4
```

**状态**：f[1]=-2, g[1]=4, f[2]=-2, g[2]=4

---

#### i=3, prices[3]=5：
```
j=2: f[2] = max(-2, 4 - 5) = -2, g[2] = max(4, -2 + 5) = 4
j=1: f[1] = max(-2, 0 - 5) = -2, g[1] = max(4, -2 + 5) = 4
```

**状态**：f[1]=-2, g[1]=4, f[2]=-2, g[2]=4

---

#### i=4, prices[4]=0：
```
j=2: f[2] = max(-2, 4 - 0) = 4  ← 关键！第二次买入
     g[2] = max(4, -2 + 0) = 4
j=1: f[1] = max(-2, 0 - 0) = 0
     g[1] = max(4, -2 + 0) = 4
```

**状态**：f[1]=0, g[1]=4, f[2]=4, g[2]=4

---

#### i=5, prices[5]=3：
```
j=2: new_f = max(4, 4 - 3) = 4
     new_g = max(4, 4 + 3) = 7  ← 最终答案！
     → f[2] = 4, g[2] = 7
j=1: new_f = max(0, 0 - 3) = 0
     new_g = max(4, 0 + 3) = 4
     → f[1] = 0, g[1] = 4
```

**最终答案**：`g[2] = 7` ✅

**最优策略**：
- 第1天(prices[1]=2)买入，第2天(prices[2]=6)卖出，利润=4
- 第4天(prices[4]=0)买入，第5天(prices[5]=3)卖出，利润=3
- **总利润** = 4 + 3 = 7 ✅

---

### 4.5 关键点总结 ⭐⭐⭐

#### 1. 状态设计的核心逻辑

```
k次交易 → 2k个状态（每次交易需要"买入"和"卖出"2个状态）

状态链条：
g[0] → f[1] → g[1] → f[2] → g[2] → ... → f[k] → g[k]
初始   买1    卖1    买2    卖2          买k    卖k
```

#### 2. 状态转移的推导方法

**核心问题**：今天的状态从哪来？

```
f[j]（第j次买入）的来源：
  1. 昨天就持有 → f[j]
  2. 昨天完成j-1次，今天买入 → g[j-1] - prices[i]
  
g[j]（完成j次交易）的来源：
  1. 昨天就完成 → g[j]
  2. 昨天第j次买入，今天卖出 → f[j] + prices[i]
```

#### 3. 为什么从后往前？⭐⭐⭐

```
依赖关系：f[j] 依赖 g[j-1]（更小的索引）

从前往后：更新j时，j-1已经被修改成"今天"的值 ❌
从后往前：更新j时，j-1还保持"昨天"的值 ✅
```

#### 4. 为什么需要临时变量？⭐⭐⭐

```
问题：g[j] 需要用"昨天"的 f[j]
     但如果直接更新 f[j]，会破坏"昨天"的值

解决：用临时变量先计算，再统一更新
     int new_f = ...  // 不修改f[j]
     int new_g = ...  // 可以用"昨天"的f[j]
     f[j] = new_f;    // 统一更新
     g[j] = new_g;
```

#### 5. k >= n/2 的优化

```
n天最多进行n/2次完整交易
如果k >= n/2，等价于"无限次"交易
→ 用贪心算法（股票II），更快！
```

#### 6. 易错点总结 ⚠️

```cpp
// ❌ 错误1：从前往后
for(int j = 1; j <= k; j++)  // 错误！

// ✅ 正确：从后往前
for(int j = k; j >= 1; j--)

// ❌ 错误2：状态转移写错
f[j] = max(f[j-1], g[j-1] - prices[i])  // f[j]不从f[j-1]转移！

// ✅ 正确
f[j] = max(f[j], g[j-1] - prices[i])    // f[j]从自己转移

// ❌ 错误3：没用临时变量
f[j] = max(f[j], g[j-1] - prices[i]);
g[j] = max(g[j], f[j] + prices[i]);      // f[j]已经是"今天"的

// ✅ 正确：用临时变量
int new_f = max(f[j], g[j-1] - prices[i]);
int new_g = max(g[j], f[j] + prices[i]); // f[j]还是"昨天"的
f[j] = new_f;
g[j] = new_g;

// ❌ 错误4：返回max(g[1], g[2], ..., g[k])
return *max_element(g.begin() + 1, g.end());

// ✅ 正确：直接返回g[k]
return g[k];  // g[k]已经包含了"最多k次"的所有情况
```

---

### 4.6 完整解题流程 📋

```
第1步：理解题意 → k次交易
  ↓
第2步：联系已知 → 股票III的推广
  ↓
第3步：状态设计 → 2k个状态（f[1..k], g[1..k]）
  ↓
第4步：推导转移 → 从"今天状态从哪来"思考
  f[j] = max(f[j], g[j-1] - prices[i])
  g[j] = max(g[j], f[j] + prices[i])
  ↓
第5步：初始化 → 第0天的状态
  g[0] = 0, f[j] = -prices[0], g[j] = 0
  ↓
第6步：空间优化 → 二维→一维
  ↓
第7步：确定顺序 → 依赖j-1，从后往前
  ↓
第8步：临时变量 → 避免覆盖"昨天"的值
  ↓
第9步：特殊优化 → k >= n/2 用贪心
```

---

### 4.7 股票系列全景图 🗺️

```
买卖股票系列难度递进：

买卖股票I（1次交易）
    ↓ 简化：找最大差值
买卖股票II（无限次，无约束）
    ↓ 最简单：贪心或2状态DP
买卖股票+手续费（无限次+手续费）
    ↓ 加约束：转移时扣费用
买卖股票+冷冻期（无限次+冷冻期）
    ↓ 加约束：增加冷冻期状态
买卖股票III（2次交易）
    ↓ 限制次数：4个状态
买卖股票IV（k次交易）
    ↓ 推广：2k个状态 + 从后往前 + 临时变量 + k>=n/2优化
```

**统一思路**：
1. 确定交易次数限制（1次/2次/k次/无限）
2. 设计状态（持有/不持有，交易次数）
3. 推导转移（从"今天状态从哪来"思考）
4. 空间优化（临时变量，更新顺序）

---

## 💡 今日收获

### 核心概念

1. **多状态DP的状态扩展**
   - k次交易 → 2k个状态
   - 状态链条：g[0] → f[1] → g[1] → ... → f[k] → g[k]

2. **状态转移的推导方法**
   - 核心问题：今天的状态从哪来？
   - 枚举所有可能，用max/min取最优

3. **滚动数组优化的关键**
   - 分析依赖关系
   - 确定更新顺序（从前往后 vs 从后往前）
   - 用临时变量避免覆盖

4. **股票系列的统一思路**
   - 买入 = 利润减少（-prices[i]）
   - 卖出 = 利润增加（+prices[i]）
   - 无限次交易 = 可以从g转移
   - k次交易 = 需要2k个状态

### 方法论更新

**多状态DP的通用解题流程**：
1. 从特殊到一般（k=1 → k=2 → k=任意）
2. 设计状态（交易次数 × 持有状态）
3. 推导转移（枚举来源，取最优）
4. 空间优化（分析依赖，确定顺序，临时变量）
5. 特殊优化（边界处理，贪心替代）

**滚动数组优化的铁律**：
- 依赖更小索引 → 从后往前
- 依赖更大索引 → 从前往后
- 同时依赖新旧值 → 用临时变量

### 易错点

1. ❌ 状态转移写错（f[j]从f[j-1]转移）
   - ✅ f[j]从f[j]和g[j-1]转移

2. ❌ 更新顺序错误（从前往后）
   - ✅ 依赖j-1，必须从后往前

3. ❌ 没用临时变量（直接覆盖）
   - ✅ 用临时变量保护"昨天"的值

4. ❌ 返回max(g[1..k])
   - ✅ 直接返回g[k]（已包含所有情况）

---

## 🔗 相关链接

- [Day36笔记](./Day36-11.5-打家劫舍系列.md)
- [DP方法论v1.6](../DP专题/动态规划方法论体系.md)

---

**学习状态**：进行中 🔥

