# Day07 - 10月8日学习笔记

**开始时间：** 2025年10月8日  
**今日专题：** 前缀和（算法精品课1）

## 📝 快速回顾 Day06 关键点（5分钟）

### 滑动窗口关键点：
1. **固定窗口** - 先建窗口 → for循环滑动 → 先出后进
2. **可变窗口** - for right → while条件不满足 → 更新结果
3. **valid计数器** - 记录字符种类数，不是总个数
4. **思维转换** - 两端移除 → 中间最长子数组

---

## 🎯 今日题目（5题前缀和专题 - 算法精品课1）

**今天目标：** 掌握前缀和的核心思想和应用场景！

**题目来源：** 比特课程/算法精品课1.md - 前缀和部分

**前缀和核心思想：**
```cpp
// 1. 预处理前缀和数组
dp[i] = dp[i-1] + arr[i];  // dp[i] 表示 [0,i] 区间的和

// 2. O(1)时间求任意区间和
区间[l, r]的和 = dp[r] - dp[l-1];
```

---

### 第1题：寻找数组的中心下标（LeetCode 724）

**题目描述：**
给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于右侧同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。

**示例：**
```
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。

输入：nums = [1, 2, 3]
输出：-1
解释：数组中不存在满足此条件的中心下标。
```

**提示：**
- `1 <= nums.length <= 10^4`
- `-1000 <= nums[i] <= 1000`

**题目链接：** https://leetcode.cn/problems/find-pivot-index/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第27题

**思路提示：**
- 先求出数组总和 `sum`
- 遍历数组，维护左侧和 `leftSum`
- 右侧和 = `sum - leftSum - nums[i]`
- 如果左侧和 == 右侧和，返回 `i`

---

**我的思路：**
i作为中心下标，左侧为f，右侧为g，两个前缀和数组，一个是从左往右，一个是从右往左，然后判断f[i] == g[i]即可
注意前缀和f从1开始，g从n-2开始（因为防止越界）



---

**我的代码：**
```cpp
// 在这里写你的代码
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
    int n = nums.size();
    vector<int> f(n),g(n);

    //1.左前缀和
    for(int i = 1; i < n ; i++)
    {
        f[i] = f[i-1] + nums[i-1];
    }
    for(int i = n-2; i >= 0; i--)
    {
        g[i] = g[i+1] + nums[i+1];
    }
    for(int i = 0 ; i < n ; i++)
    {
        if(g[i] == f[i])
        return i ;
    }
    return -1;
    }
};
```

**提交结果：**
ac

---

**我的错误（如果有）：**




---

**正确代码：**
```cpp
// AC代码
```

---

**复杂度分析：**
- **时间复杂度：** O（n）
- **空间复杂度：** O（n）

---

**我的收获：**




---

### 第2题：除自身以外数组的乘积（LeetCode 238）⭐⭐

**题目描述：**
给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

**示例：**
```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]

输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**提示：**
- `2 <= nums.length <= 10^5`
- `-30 <= nums[i] <= 30`
- **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内

**题目链接：** https://leetcode.cn/problems/product-of-array-except-self/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第28题

**思路提示：**
- 类似前缀和，但这里是 **前缀积** 和 **后缀积**
- 用两个数组：`lprod[i]` 表示 i 左边所有元素的乘积，`rprod[i]` 表示 i 右边所有元素的乘积
- 结果：`ret[i] = lprod[i] * rprod[i]`

---

**我的思路：**




---

**我的代码：**
```cpp
// 在这里写你的代码
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n),g(n);
        vector<int> ret(n);
        //边界处理
        f[0] = 1;
        g[n-1] = 1;
        for(int i = 1; i < n ; i++)
        {
            f[i] = f[i-1]*nums[i-1];
        }
        for(int i = n-2; i >= 0; i--)
        {
            g[i] = g[i+1]*nums[i+1];
        }

        //处理乘法
        for(int i = 0; i < n ; i++)
        {
            ret[i] = f[i]*g[i];
     
        }
        return ret;
    }
};
```

**提交结果：**
ac

---

**我的错误（如果有）：**
最开始边界处理放在了前缀和处理的下面，导致结果错误，这里我没搞懂，后来我放上面就ac了
还有题目里面的不超过32位整数范围，不知道这个限制是干嘛的，做完也不知道有没有影响

**❓ 教练解答：**
1. **边界处理位置：** 必须在前缀积计算之前！因为 `f[0] = 1, g[n-1] = 1` 是初始值，如果放在后面会覆盖掉已经计算好的值。你的做法是对的！✅

2. **32位整数范围：** 这是告诉你**不用担心溢出**！乘积不会超过 `INT_MAX`，不需要用 `long long`。如果没这个保证，可能需要考虑溢出问题。

3. **空间复杂度：** 是的！**O(n)**，因为用了3个长度为n的数组（f, g, ret）。

---

**正确代码：**
```cpp
// 你的代码就是AC代码！✅
```

---

**复杂度分析：**
- **时间复杂度：** O(n) - 三次遍历
- **空间复杂度：** O(n) - 三个数组

---

**我的收获：**




---

### 第3题：和为k的子数组（LeetCode 560）⭐⭐⭐

**题目描述：**
给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 **该数组中和为 `k` 的连续子数组的个数** 。

**子数组**是数组中元素的连续非空序列。

**示例：**
```
输入：nums = [1,1,1], k = 2
输出：2

输入：nums = [1,2,3], k = 3
输出：2
```

**提示：**
- `1 <= nums.length <= 2 * 10^4`
- `-1000 <= nums[i] <= 1000`
- `-10^7 <= k <= 10^7`

**题目链接：** https://leetcode.cn/problems/subarray-sum-equals-k/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第29题

**思路提示：**
- **核心思想：** 前缀和 + 哈希表
- 如果 `sum[i] - sum[j] = k`，则 `sum[j] = sum[i] - k`
- 用哈希表记录每个前缀和出现的次数
- 遍历时，查找 `sum - k` 在哈希表中出现的次数

---

**我的思路：**
思路比较乱，看了讲解视频。最开始是暴力法，然后是前缀和，最后是前缀和+哈希表，哈希表用来快速查找前缀和出现的次数，但是这个里面的细节我还是没搞太懂

---

**我的代码：**
```cpp
// 看了讲解后写的
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int,int> hash; // 统计前缀和出现的次数
        hash[0] = 1;
        int sum = 0, ret = 0;
        for(auto x: nums) {
            sum += x; // 计算当前位置的前缀和
            if(hash.count(sum - k)) ret += hash[sum - k]; // 统计个数，看有没有满足此时前缀和为sum - k的前缀和存在与否
            hash[sum]++;//记录当前前缀和出现的次数，下一题是记录当前前缀和余数出现的次数异曲同工，判断中要的啥就记录啥，比如要判断余数，就记录余数出现的次数
        }
        return ret;
    }
};
```

**提交结果：** AC ✅

---

**❓ 我的理解（经过思考后）：**

**核心理解：**
1. **hash[x] = y 的含义：** 值为x的前缀和出现了y次
2. **为什么查 `hash[sum - k]`：**
   - 当前位置i的前缀和是 sum
   - 要找和为k的子数组
   - 如果之前位置j的前缀和是 sum - k
   - 那么从j+1到i的和 = sum - (sum - k) = k ✅
3. **sum不断右移，不断累加，每次都是新的前缀和**
4. **hash里存的是历史所有前缀和及其出现次数**

---

**💡 教练详细讲解（ASCII图解版）：**

**完整流程图：**
```
┌─────────────────────────────────────────────────────────────┐
│                    开始算法                                  │
│  初始化: hash = {0: 1},  sum = 0,  ret = 0                 │
└──────────────────────┬──────────────────────────────────────┘
                       │
                       ▼
         ┌─────────────────────────────┐
         │  遍历数组中的每个元素 x      │
         └──────────┬──────────────────┘
                    │
                    ▼
         ┌─────────────────────────────┐
         │  sum += x                   │
         │  (计算当前前缀和)            │
         └──────────┬──────────────────┘
                    │
                    ▼
         ┌─────────────────────────────┐
         │  查找 hash[sum - k]         │
         │  是否存在?                   │
         └──────┬─────────────┬────────┘
                │             │
          存在  │             │  不存在
                ▼             ▼
    ┌──────────────┐    ┌──────────┐
    │ ret += hash  │    │  什么都  │
    │  [sum - k]   │    │  不做    │
    └──────┬───────┘    └─────┬────┘
           │                  │
           └──────┬───────────┘
                  │
                  ▼
         ┌─────────────────────────────┐
         │  hash[sum]++                │
         │  (记录当前前缀和出现次数)    │
         └──────────┬──────────────────┘
                    │
                    ▼
         ┌─────────────────────────────┐
         │  还有下一个元素吗?           │
         └──────┬─────────────┬────────┘
          有    │             │  没有
                │             │
                ▼             ▼
         (回到遍历)    ┌──────────┐
                       │ 返回 ret │
                       └──────────┘
```

---

**具体例子演示：nums = [1, 2, 3], k = 3**

```
═══════════════════════════════════════════════════════════════
初始状态
═══════════════════════════════════════════════════════════════
hash = {0: 1}    sum = 0    ret = 0

说明: hash[0]=1 表示"虚拟起点"的前缀和是0


═══════════════════════════════════════════════════════════════
第1轮: 遍历 x = 1
═══════════════════════════════════════════════════════════════
① sum = 0 + 1 = 1     (现在的前缀和)

② 查找 hash[1 - 3] = hash[-2] ?
   ❌ 不存在，跳过

③ hash[1] = 1         (记录前缀和1出现过)

───────────────────────────────────────────────────────────────
当前状态:
hash = {0: 1, 1: 1}
sum = 1
ret = 0
───────────────────────────────────────────────────────────────


═══════════════════════════════════════════════════════════════
第2轮: 遍历 x = 2
═══════════════════════════════════════════════════════════════
① sum = 1 + 2 = 3     (现在的前缀和)

② 查找 hash[3 - 3] = hash[0] ?
   ✅ 存在! hash[0] = 1
   
   含义: 之前有1个位置的前缀和是0
         从那个位置的下一个到现在，和为3
         就是子数组 [1, 2]
   
   ret += 1  →  ret = 1

③ hash[3] = 1         (记录前缀和3出现过)

───────────────────────────────────────────────────────────────
当前状态:
hash = {0: 1, 1: 1, 3: 1}
sum = 3
ret = 1  ← 找到1个子数组
───────────────────────────────────────────────────────────────


═══════════════════════════════════════════════════════════════
第3轮: 遍历 x = 3
═══════════════════════════════════════════════════════════════
① sum = 3 + 3 = 6     (现在的前缀和)

② 查找 hash[6 - 3] = hash[3] ?
   ✅ 存在! hash[3] = 1
   
   含义: 之前有1个位置的前缀和是3
         从那个位置的下一个到现在，和为3
         就是子数组 [3]
   
   ret += 1  →  ret = 2

③ hash[6] = 1         (记录前缀和6出现过)

───────────────────────────────────────────────────────────────
最终状态:
hash = {0: 1, 1: 1, 3: 1, 6: 1}
sum = 6
ret = 2  ← 找到2个子数组: [1,2] 和 [3]
───────────────────────────────────────────────────────────────


═══════════════════════════════════════════════════════════════
返回结果: 2
═══════════════════════════════════════════════════════════════
```

---

**哈希表变化图：**

```
遍历过程中 hash 的变化:

初始:
┌────┬────┐
│ 0  │ 1  │  ← hash[0] = 1
└────┴────┘

遍历 x=1 后:
┌────┬────┐  ┌────┬────┐
│ 0  │ 1  │  │ 1  │ 1  │  ← 新增 hash[1] = 1
└────┴────┘  └────┴────┘

遍历 x=2 后:
┌────┬────┐  ┌────┬────┐  ┌────┬────┐
│ 0  │ 1  │  │ 1  │ 1  │  │ 3  │ 1  │  ← 新增 hash[3] = 1
└────┴────┘  └────┴────┘  └────┴────┘
                                ↑
                          查到了! ret += 1

遍历 x=3 后:
┌────┬────┐  ┌────┬────┐  ┌────┬────┐  ┌────┬────┐
│ 0  │ 1  │  │ 1  │ 1  │  │ 3  │ 1  │  │ 6  │ 1  │  ← 新增
└────┴────┘  └────┴────┘  └────┴────┘  └────┴────┘
                              ↑
                        又查到了! ret += 1
```

---

**前缀和的差值图解：**

```
数组:     [1,    2,    3]
下标:      0     1     2

前缀和:    1     3     6
          ↑     ↑     ↑
          │     │     │
        只有1  1+2  1+2+3


要找和为3的子数组:

情况1: 子数组 [1, 2]
      ┌─────────┐
      │    1  2 │
      └─────────┘
      前缀和[1] - 前缀和[-1] = 3 - 0 = 3 ✅
      (前缀和[-1]就是hash[0]=1)

情况2: 子数组 [3]
             ┌───┐
             │ 3 │
             └───┘
      前缀和[2] - 前缀和[1] = 6 - 3 = 3 ✅
```

---

**为什么要加 hash[sum - k] 的值？**

```
例子: nums = [1, -1, 1, -1], k = 0

遍历到最后:
sum = 0

查找 hash[0 - 0] = hash[0] = ?

hash[0] 可能等于 3 (出现了3次)

意思是: 有3个位置的前缀和是0
        从这3个位置的下一个到现在
        有3个子数组的和都是0

所以: ret += 3  (不是 ret += 1)
```

---

**关键点总结：**
1. **`hash[0] = 1` 的含义：** 表示"从数组开头"这个虚拟位置，用于找从头开始的子数组
2. **`hash[前缀和] = 次数`：** 记录每个前缀和出现的次数
3. **查找 `hash[sum - k]`：** 因为 `sum - (sum - k) = k`，找到之前的前缀和就能确定子数组
4. **`ret += hash[sum - k]`：** 有多少个历史前缀和等于`sum-k`，就有多少个和为k的子数组

---

**正确代码：**
```cpp
// 你的代码是对的！✅
```

---

**复杂度分析：**
- **时间复杂度：** O(n) - 一次遍历
- **空间复杂度：** O(n) - 哈希表最多存n个前缀和

---

**我的收获：**
1. 前缀和+哈希表的核心：`sum[i] - sum[j] = k` 转换为 `sum[j] = sum[i] - k`
2. `hash[0] = 1` 用于处理从头开始的子数组
3. 哈希表记录**次数**，因为可能有多个位置的前缀和相同




---

### 第4题：和可被K整除的子数组（LeetCode 974）

**题目描述：**
给定一个整数数组 `nums` 和一个整数 `k` ，返回其中元素之和可被 `k` 整除的非空 **子数组** 的数目。

**子数组** 是数组中 **连续** 的部分。

**示例：**
```
输入：nums = [4,5,0,-2,-3,1], k = 5
输出：7
解释：有 7 个子数组满足其元素之和可被 k = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]

输入: nums = [5], k = 9
输出: 0
```

**提示：**
- `1 <= nums.length <= 3 * 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `2 <= k <= 10^4`

**题目链接：** https://leetcode.cn/problems/subarray-sums-divisible-by-k/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第30题

**思路提示：**
- 类似 "和为k的子数组"，但这里是 **整除k**
- 如果 `(sum[i] - sum[j]) % k == 0`，则 `sum[i] % k == sum[j] % k`
- 用哈希表记录每个 **余数** 出现的次数
- **注意处理负数取模！** C++中负数取模结果可能是负数

---

**我的思路：**




---

**我的代码：**
```cpp
// 在这里写你的代码
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
         unordered_map<int,int> hash; // 统计前缀和出现的次数
        hash[0] = 1;
        int sum = 0, ret = 0;
        for(auto x: nums) {
            sum += x; // 计算当前位置的前缀和
            for(int i = 1; i*k < sum ;i++)
            if(hash.count(sum - k*i)) ret += hash[sum - k]; // 统计个数，看有没有满足此时前缀和为sum - k的倍数的前缀和存在与否
            hash[sum]++;
        }
        return ret;
    }
};
```

**提交结果：**


---

**提交结果：** ❌ WA (21/76)
- 输入：`nums = [4,5,0,-2,-3,1], k = 5`
- 我的输出：`2`
- 预期结果：`7`

---

**❌ 我的错误思路：**

我一开始想用循环查找 `sum - k`, `sum - 2k`, `sum - 3k`...

**问题在哪：**
1. ❌ 循环条件 `i*k < sum` 不对，因为sum可能是**负数**
2. ❌ 即使改对，这样做会**漏掉很多情况**（只检查了一部分可能）
3. ❌ 时间复杂度变成 O(n²)

**为什么这个思路不行：**
```
例如: sum = 14, k = 5
我会查找: hash[14-5=9], hash[14-10=4]

但实际上，如果之前有前缀和是4或9或14或19...
只要它们 mod 5 的余数和14一样，都应该统计！

我的方法漏掉了很多情况
```

---

**✅ 正确思路：用"余数"代替前缀和！**

**核心转换：**
```
问题: 找和能被k整除的子数组

如果子数组[i, j]的和能被k整除:
  (sum[j] - sum[i]) % k == 0
  
等价于:
  sum[j] % k == sum[i] % k
  
也就是: 两个前缀和的余数相同！
```

**数学原理：**
```
假设:
  sum[j] = a*k + r  (余数是r)
  sum[i] = b*k + r  (余数也是r)

那么:
  sum[j] - sum[i] = (a*k + r) - (b*k + r)
                  = (a - b) * k
                  
  ✅ 能被k整除！
```

**具体例子：nums = [4, 5, 0, -2, -3, 1], k = 5**

```
位置   nums  前缀和  余数(mod 5)
━━━━━━━━━━━━━━━━━━━━━━━━━━
-1     -      0       0      ← 虚拟起点
 0      4      4       4
 1      5      9       4      ← 余数和位置0相同！
 2      0      9       4      ← 余数和位置0,1相同！
 3     -2      7       2
 4     -3      4       4      ← 余数和位置0,1,2相同！
 5      1      5       0      ← 余数和起点相同！

余数0: 2个位置(起点, 位置5)  → 1个子数组
余数4: 4个位置(0,1,2,4)     → 6个子数组
余数2: 1个位置              → 0个子数组

总共: 1 + 6 = 7 ✅
```

**为什么4个位置能组成6个子数组？**
```
位置0,1,2,4 的余数都是4

任意两个位置之间的子数组都满足条件:
  [5]         (位置0到1)
  [5,0]       (位置0到2)
  [5,0,-2,-3] (位置0到4)
  [0]         (位置1到2)
  [0,-2,-3]   (位置1到4)
  [-2,-3]     (位置2到4)
  
组合数 = C(4,2) = 6
```

---

**正确代码：**
```cpp
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        unordered_map<int,int> hash; // 统计余数出现的次数
        hash[0] = 1;  // 虚拟起点的余数是0
        int sum = 0, ret = 0;
        
        for(auto x: nums) {
            sum += x;  // 计算前缀和
            
            int r = (sum % k + k) % k;  // ⚠️ 处理负数的余数
            
            if(hash.count(r)) {
                ret += hash[r];  // 有多少个相同余数，就有多少个子数组
            }
            hash[r]++;  // 记录这个余数出现过
        }
        
        return ret;
    }
};
```

**⚠️ 关键点：为什么要 `(sum % k + k) % k`？**
```
处理负数余数：

C++ 中：
  -3 % 5 = -3  (负数！)
  
但我们需要正数余数：
  -3 % 5 应该等于 2
  
所以：
  (-3 % 5 + 5) % 5 = (-3 + 5) % 5 = 2 ✅
  
通用公式：
  (sum % k + k) % k  → 保证余数是正数
```

---

**复杂度分析：**
- **时间复杂度：** O(n) - 遍历一遍数组
- **空间复杂度：** O(k) - 哈希表最多存k个不同的余数

---

**我的收获：**
1. **思维转换：** "整除k" → "余数相同"
2. **和第3题的区别：** 第3题查找的是前缀和，这题查找的是余数
3. **负数取模陷阱：** C++中负数取模结果可能是负数，需要 `(x % k + k) % k` 处理
4. **本质相同：** 和第3题一样，都是用哈希表记录历史状态，查找满足条件的组合




---

### 第5题：连续数组（LeetCode 525）

**题目描述：**
给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例：**
```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。

输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。
```

**提示：**
- `1 <= nums.length <= 10^5`
- `nums[i]` 不是 `0` 就是 `1`

**题目链接：** https://leetcode.cn/problems/contiguous-array/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第31题

**思路提示：**
- **思维转换！** 把 `0` 看作 `-1`，问题变成：找和为 `0` 的最长子数组
- 如果 `sum[i] == sum[j]`，则 `[j+1, i]` 区间的和为 0
- 用哈希表记录每个前缀和 **第一次出现的位置**
- 遍历时，查找当前前缀和在哈希表中的位置，更新最大长度

---

**我的思路：**




---

**我的代码：**
```cpp
// 在这里写你的代码
```

**提交结果：**


---

**我的错误（如果有）：**




---

**正确代码：**
```cpp
// AC代码
```

---

**复杂度分析：**
- **时间复杂度：** 
- **空间复杂度：** 

---

**我的收获：**




---

## 📊 今日完成情况

| 题目 | 状态 | 用时 | 错误次数 | 关键收获 |
|------|------|------|----------|----------|
| 寻找数组的中心下标 | ✅ AC | 约15分钟 | 0 | 前缀和基础应用 |
| 除自身以外数组的乘积 | ✅ AC | 约20分钟 | 0 | 前后缀和分开处理 |
| 和为k的子数组 | ✅ AC | 约1小时 | 理解困难 | 前缀和+哈希表核心思想 |
| 和可被K整除的子数组 | ❌ 未完成 | 约30分钟 | 1次WA | 余数思想，负数取模陷阱 |
| 连续数组 | ⏸️ 未开始 | - | - | - |

---

## 💡 今日总结

**今天完成题数：** 3/5 (第4题理解思路但未AC)

**累计完成：** 17题 → 20题

**用时：** 约3小时

**今天的关键收获：**
1. **前缀和+哈希表的核心思想：** 用哈希表记录历史前缀和，查找满足条件的组合
2. **"和为k"问题模板：** `hash[sum-k]` 表示之前有多少个前缀和能和当前前缀和组成和为k的子数组
3. **`ret += hash[sum-k]` 不是重复：** 有多少个历史前缀和满足条件，就有多少个子数组
4. **思维转换：** "整除k" → "余数相同"，把复杂问题转化成前缀和问题
5. **负数取模陷阱：** C++中负数取模可能是负数，需要 `(sum % k + k) % k` 处理

**我遇到的问题：**
1. **第3题理解困难：** 花了很久才理解为什么 `sum` 不断累加就是前缀和，以及为什么 `ret += hash[sum-k]` 不会重复统计
2. **第4题思路错误：** 一开始想用循环查找k的倍数，没想到用余数
3. **概念混淆：** 把前缀和数组和滚动的sum变量搞混了

**前缀和的核心套路：**
1. **基础前缀和：** `dp[i] = dp[i-1] + arr[i]`，用于快速求区间和
2. **前缀和+哈希表：** 用哈希表记录前缀和出现的次数或位置，核心：`hash[sum-k]` 或 `hash[sum%k]`
3. **思维转换：** 把复杂问题转换成前缀和问题（如"整除k" → "余数相同"）
4. **取模技巧：** 处理整除问题时，用余数代替前缀和，注意负数取模：`(x % k + k) % k`
5. **`hash[0] = 1` 的含义：** 表示虚拟起点，用于找从数组开头开始的子数组

**明天的目标：**
- 完成第4、5题
- 继续算法精品课1的其他内容

---

**学习进度：** Day07/150 ✅
