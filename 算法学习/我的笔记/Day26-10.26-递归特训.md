# Day26 - 递归方法论实战特训 (10.26)

> **训练目标**：使用递归方法论体系，完成6道题，并完善方法论

---

## 学习计划
- 训练时长：2小时
- 题目数量：6道（根据完成情况调整）
- 训练方法：严格按照递归方法论五步法

---

## 1. LeetCode 1863 - 找出所有子集的异或总和再求和 ✅

### 题目信息
- 比特课程：专题四_综合练习_找出所有子集的异或总和再求和_C++
- LeetCode编号：1863
- 难度：简单（但实际感觉比中等难）

### 题目理解
- 求出所有子集
- 计算每个子集的异或和
- 将所有异或和相加（注意是加法，不是异或！）

### 方法论应用

**第1步：明确函数语义**
```cpp
void dfs(vector<int>& nums, int pos, int currentXOR)
功能：从pos位置开始，构建所有子集，并累加每个子集的异或和
参数：
  - nums: 原数组
  - pos: 起始位置
  - currentXOR: 当前子集的异或和
```

**第2步：找递归出口**
- 隐式出口：for循环结束时自动返回
- 每个节点都要记录结果（子集问题特点）

**第3步：确定子问题**
- 从pos位置开始，选择后续元素
- 每选一个元素，异或和更新为 `currentXOR ^ nums[i]`
- 递归参数是 `i+1`（不是pos！）← **关键错误点**

**第4步：设计递归体**
- 先记录当前子集的异或和
- 遍历[pos, n)范围的元素
- 选择元素后递归到i+1

**第5步：检查语义一致性**
- ✅ 递归调用传入i+1，保证只往后选
- ✅ currentXOR在递归过程中正确更新

### 初始错误代码
```cpp
class Solution {
public:
    int ret = 0;
    vector<int> path;
    int sigXOR = 0;
    
    int subsetXORSum(vector<int>& nums) {
        dfs(nums, 0);
        return ret;
    }
    
    void dfs(vector<int>& nums, int pos) {
        // 计算当前path的异或和
        for(int i = 0; i < path.size(); i++) {
            if(path.size() == 0) sigXOR ^= 0;
            else sigXOR ^= path[i];
        }
        ret ^= sigXOR;  // ❌ 错误1：应该是加法，不是异或
        sigXOR = 0;
        
        for(int i = pos; i < nums.size(); i++) {
            path.push_back(nums[i]);
            dfs(nums, pos);  // ❌ 错误2：应该是i+1，不是pos！
            path.pop_back();
        }
    }
};
```

**错误分析**：
1. **致命错误**：`dfs(nums, pos)` → 导致无限递归，超时
   - 应该是 `dfs(nums, i+1)`
   - 原因：pos不变，会一直选择同一个元素
   
2. **逻辑错误**：`ret ^= sigXOR` → 题目要求是求和
   - 应该是 `ret += sigXOR`
   - 题目：将所有子集的异或和**相加**

### 正确代码（优化版）

```cpp
class Solution {
public:
    int ret = 0;
    
    int subsetXORSum(vector<int>& nums) {
        dfs(nums, 0, 0);
        return ret;
    }
    
    void dfs(vector<int>& nums, int pos, int currentXOR) {
        // 1. 记录当前子集的异或和
        ret += currentXOR;  // 加法，不是异或
        
        // 2. 选择后续元素
        for(int i = pos; i < nums.size(); i++) {
            // 选择nums[i]，异或和更新
            dfs(nums, i + 1, currentXOR ^ nums[i]);  // i+1，不是pos
        }
    }
};
```

**优化点**：
- ✅ 不需要path数组（直接传递异或和）
- ✅ 不需要恢复现场（currentXOR是值传递，天然回溯）
- ✅ 代码更简洁，效率更高

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(n) 递归栈

### 方法论反思

**有帮助的地方**：
1. ✅ 五步法帮助理清思路
2. ✅ 明确子问题时发现了参数错误

**遇到的问题**：
1. ❌ 第3步容易出错：写成`dfs(pos)`而不是`dfs(i+1)`
2. ❌ 题目理解：没注意到是"求和"而不是"异或"

**需要完善的地方**：
- 方法论应该强调：子集问题递归传参必须是`i+1`
- 需要添加典型错误检查清单：递归参数是否正确

### 核心收获

**子集问题的关键**：
```cpp
// ❌ 错误模式（导致无限递归）
for(int i = pos; i < n; i++) {
    dfs(nums, pos);  // 错！
}

// ✅ 正确模式
for(int i = pos; i < n; i++) {
    dfs(nums, i + 1);  // 对！
}
```

**记忆口诀**：
```
pos是起点，i是当前
递归传i+1，不能传pos
```

### 难度讨论

**为什么标记简单却感觉难？**
1. 需要理解子集的递归模板
2. 需要理解异或运算
3. 容易犯致命错误（pos vs i+1）
4. 比纯粹的子集问题多了一层计算

**实际难度**：类似中等题

---

## 2. LeetCode 47 - 全排列 II ✅

### 题目信息
- 比特课程：专题四_综合练习_全排列II_C++
- LeetCode编号：47
- 难度：中等

### 题目理解
- 给定包含重复数字的数组，返回所有不重复的全排列
- 关键：如何去重？

### 方法论应用

**第1步：明确函数语义**
```cpp
void dfs(vector<int>& nums)
功能：基于当前path，构建所有不重复的全排列
全局变量：
  - path: 当前排列
  - check: 标记是否已使用
  - ret: 存储所有结果
```

**第2步：找递归出口**
- 显式出口：`path.size() == nums.size()`
- 记录结果后返回

**第3步：确定子问题**
- 全排列型：每个位置都可以选任意未使用的元素
- 遍历所有元素（for从0开始）
- 用check数组判断是否已使用
- **关键**：需要同层去重

**第4步：设计递归体**
- 遍历所有元素
- 剪枝1：跳过已使用的元素
- 剪枝2：同层去重（核心！）
- 做选择 → 递归 → 恢复现场

**第5步：检查语义一致性**
- ✅ 全排列不需要pos参数
- ✅ 递归调用不传参数
- ✅ for循环从0开始

### 初始错误

**错误1：混淆了全排列和子集**
```cpp
void dfs(vector<int>& nums, int pos) {  // ❌ 不需要pos
    for(int i = 0; i < nums.size(); i++) {
        dfs(nums, i);  // ❌ 不需要传参数
    }
}
```

**错误2：去重条件不完整**
```cpp
if(i>=1 && nums[i]== nums[i-1]) return;  // ❌ 缺少check[i-1]检查
```

**错误3：忘记排序**
```cpp
// 去重的前提是数组必须有序！
sort(nums.begin(), nums.end());  // 必须先排序
```

### 正确代码

```cpp
class Solution {
public:
    vector<vector<int>> ret;
    vector<int> path;
    bool check[10];
    
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        // 1. 必须先排序！
        sort(nums.begin(), nums.end());
        
        // 2. 初始化check
        for(int i = 0; i < nums.size(); i++) {
            check[i] = false;
        }
        
        dfs(nums);
        return ret;
    }
    
    void dfs(vector<int>& nums) {
        // 1. 递归出口
        if(path.size() >= nums.size()) {
            ret.push_back(path);
            return;
        }
        
        // 2. 递归体
        for(int i = 0; i < nums.size(); i++) {
            // 剪枝1：已使用
            if(check[i]) continue;
            
            // 剪枝2：同层去重（核心！）
            if(i > 0 && nums[i] == nums[i-1] && !check[i-1]) {
                continue;
            }
            
            // 做选择
            path.push_back(nums[i]);
            check[i] = true;
            
            // 递归
            dfs(nums);
            
            // 恢复现场
            path.pop_back();
            check[i] = false;
        }
    }
};
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(n) 递归栈 + 辅助数组

### 核心知识点

#### **1. 去重条件详解**

```cpp
if(i > 0 && nums[i] == nums[i-1] && !check[i-1]) {
    continue;
}
```

**三个条件缺一不可**：

**条件1：`i > 0`**
- 不是第一个元素
- 第一个元素无法和"前一个"比较

**条件2：`nums[i] == nums[i-1]`**
- 当前元素和前一个元素值相同
- 可能产生重复

**条件3：`!check[i-1]`（最难理解）**
- 前一个元素没有被使用
- 说明前一个元素已经"用完并回溯"了
- 它的所有排列已经生成完毕

#### **2. check[i-1]的两种状态**

**状态1：check[i-1] == false（需要剪枝）**
```
时间线：
1. 选择nums[i-1]，生成所有以它开头的排列
2. 回溯，check[i-1] = false
3. 此时如果选nums[i]（值相同），会产生重复
4. 需要跳过

示例：nums = [1₁, 1₂, 2]
- 已经生成了以1₁开头的所有排列
- 现在考虑1₂，会产生重复
- 跳过！
```

**状态2：check[i-1] == true（不能剪枝）**
```
时间线：
1. 当前在nums[i-1]的子递归中
2. check[i-1] = true（正在使用）
3. 此时选nums[i]是合法的（不同位置）

示例：nums = [1₁, 1₂, 2]
- 选1₁作为第1个位置 [check[0]=true]
- 此时可以选1₂作为第2个位置
- 结果 [1,1,2] 是合法的！
```

#### **3. 决策树图解**

```
nums = [1, 1, 2] （排序后）

正确的决策树：
                    []
        /           |           \
      选1₁         选1₂         选2
      (i=0)       (i=1)        (i=2)
                    ↑
                  剪掉！
                  
为什么剪掉1₂？
- 在第1层选择时
- 1₁和1₂值相同
- check[0]=false（1₁已经用完回溯了）
- 1₂会产生和1₁完全相同的排列树
- 需要剪枝

为什么在第2层可以选1₂？
- 在第2层（1₁的子递归中）
- check[0]=true（1₁正在使用）
- 1₂和1₁在不同位置，合法
- 不剪枝
```

#### **4. 剪枝位置的两种写法**

**写法1：在if内部 + return**
```cpp
if(check[i] == false) {
    if(去重条件) return;  // 结束整个函数
    // 做选择...
}
```
- 能work，但return会结束整个函数
- 依赖父层的for循环继续

**写法2：在if外部 + continue（推荐）**
```cpp
if(check[i]) continue;
if(去重条件) continue;  // 只跳过当前i
// 做选择...
```
- 更清晰，只跳过当前循环
- 不依赖父层

### 方法论反思

**有帮助的地方**：
1. ✅ 第1步帮助识别：这是全排列型，不是子集型
2. ✅ 第3步帮助明确：不需要pos参数
3. ✅ 第5步检查：发现了参数传递错误

**遇到的困难**：
1. ❌ 容易混淆全排列和子集的写法
2. ❌ 去重条件很难理解（特别是check[i-1]）
3. ❌ 剪枝位置的选择有疑惑

**需要完善的地方**：
- 方法论需要明确区分全排列和子集的模板
- 需要专门讲解去重技巧
- 需要强调排序的重要性

### 核心收获

**全排列 vs 全排列II**：
```
全排列（无重复）：
- 只需要check数组判断是否已使用

全排列II（有重复）：
- 需要先排序
- 需要同层去重：!check[i-1]
- 多一个剪枝条件
```

**记忆口诀**：
```
全排列去重三步走：
1. 先排序（必须）
2. 同层去重看前一个
3. 前一个没用过就跳过

去重条件：
i > 0 && 
nums[i] == nums[i-1] && 
!check[i-1]
```

**与全排列的对比**：
| 特性 | 全排列 | 全排列II |
|------|--------|----------|
| 需要排序 | ❌ | ✅ |
| 剪枝条件 | 1个 | 2个 |
| check数组 | ✅ | ✅ |
| pos参数 | ❌ | ❌ |
| for起点 | 0 | 0 |
| 去重逻辑 | 无 | !check[i-1] |

---

## 3. LeetCode 17 - 电话号码的字母组合 ✅

### 题目信息
- 比特课程：专题四_综合练习_电话号码的字母组合_C++
- LeetCode编号：17
- 难度：中等（但比全排列II简单）

### 题目理解
- 给定数字字符串，每个数字对应若干字母
- 返回所有可能的字母组合
- 示例：digits="23" → ["ad","ae","af","bd","be","bf","cd","ce","cf"]

### 方法论应用

**第1步：明确函数语义**
```cpp
void dfs(string digits, int index)
功能：从index位置开始，构建字母组合
参数：
  - digits: 数字字符串
  - index: 当前处理第几个数字
全局变量：
  - path: 当前字母组合
  - charToStrMap: 数字→字母的映射
  - ret: 存储所有结果
```

**第2步：找递归出口**
- 显式出口：`index >= digits.size()`
- 说明所有数字都处理完了
- 记录当前path到结果集

**第3步：确定子问题**
- 每层处理一个数字（digits[index]）
- 从当前数字对应的字母中选一个
- 递归处理下一个数字（index+1）
- **关键**：每层从不同集合选，不需要check数组

**第4步：设计递归体**
- 获取当前数字对应的字母集合
- 遍历字母集合
- 选择 → 递归(index+1) → 恢复

**第5步：检查语义一致性**
- ✅ 递归传递index+1
- ✅ 只处理当前index的数字
- ✅ 不需要pos参数（index已经足够）

### 初始错误

**错误1：path类型错误**
```cpp
vector<string> path;  // ❌ 应该是string，不是vector<string>
```

**错误2：使用了check数组**
```cpp
bool check[30];  // ❌ 这题不需要check数组！
```

**错误3：缺少index参数**
```cpp
void dfs(string digits) {  // ❌ 缺少index参数
    for(int i = 0; i < digits.size(); i++) {  // ❌ 每次都遍历所有数字
        // 会导致无限递归
    }
}
```

**错误4：语法错误**
```cpp
ret.push(path);     // ❌ vector没有push方法，应该是push_back
path += s[j];       // ❌ path如果是vector<string>不能这样用
check[s[i]] = true; // ❌ s[i]是char，不应该用作数组索引
```

### 正确代码

```cpp
class Solution {
public:
    unordered_map<char, string> charToStrMap;
    vector<string> ret;
    string path;  // ✅ string类型
    
    vector<string> letterCombinations(string digits) {
        // 1. 特殊情况处理
        if(digits.empty()) return ret;
        
        // 2. 建立映射
        charToStrMap['2'] = "abc";
        charToStrMap['3'] = "def";
        charToStrMap['4'] = "ghi";
        charToStrMap['5'] = "jkl";
        charToStrMap['6'] = "mno";
        charToStrMap['7'] = "pqrs";
        charToStrMap['8'] = "tuv";
        charToStrMap['9'] = "wxyz";
        
        // 3. 递归
        dfs(digits, 0);  // ✅ 从index=0开始
        return ret;
    }
    
    void dfs(string digits, int index) {  // ✅ 需要index参数
        // 1. 递归出口
        if(index >= digits.size()) {  // ✅ 用index判断
            ret.push_back(path);
            return;
        }
        
        // 2. 只处理当前index的数字
        char digit = digits[index];
        string letters = charToStrMap[digit];
        
        // 3. 遍历当前数字对应的字母
        for(int j = 0; j < letters.size(); j++) {
            // 做选择
            path += letters[j];
            
            // 递归：处理下一个数字
            dfs(digits, index + 1);  // ✅ index+1
            
            // 恢复现场
            path.pop_back();
        }
    }
};
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(n) 递归栈

### 核心知识点

#### **1. 与全排列/子集的关键区别**

| 特性 | 全排列 | 子集 | 电话号码组合 |
|------|--------|------|-------------|
| **集合来源** | 同一个数组 | 同一个数组 | 每层不同集合 |
| **check数组** | ✅ 需要 | ❌ 不需要 | ❌ 不需要 |
| **pos/index** | ❌ 不需要 | ✅ 需要 | ✅ 需要 |
| **for起点** | 0（遍历全部） | pos（只往后） | 0（遍历当前集合） |
| **递归参数** | 不变 | i+1 | index+1 |
| **去重问题** | 可能需要 | 天然不重复 | 天然不重复 |

**核心区别图解**：
```
全排列：[1,2,3]
level0: 从[1,2,3]选 → check标记
level1: 从[1,2,3]选 → check标记（同一个集合）
level2: 从[1,2,3]选 → check标记

子集：[1,2,3]
level0: 从[1,2,3]选 → 选了1
level1: 从[2,3]选   → 只往后（index+1）
level2: 从[3]选     → 只往后

电话号码："23"
level0: 从"abc"选  → digits[0]的集合
level1: 从"def"选  → digits[1]的集合（不同集合！）
```

#### **2. 为什么不需要check数组？**

**全排列需要check的原因**：
```
nums = [1, 2, 3]
每层都从同一个集合选元素
需要标记哪些已经用过了

level0: 选1 → check[0]=true
level1: 不能再选1（check[0]=true）
       只能选2或3
```

**电话号码不需要check的原因**：
```
digits = "23"
每层从不同的集合选元素
不存在"已使用"的概念

level0: 从"abc"选 → 选'a'
level1: 从"def"选 → 可以选任意一个
       （和level0的集合不同，不会重复）
```

#### **3. path.size() vs index**

**这题两种写法都对**：
```cpp
// 写法1：用path.size()
if(path.size() >= digits.size()) {  // ✅ 能work
    ret.push_back(path);
}

// 写法2：用index（推荐）
if(index >= digits.size()) {  // ✅ 更好
    ret.push_back(path);
}
```

**为什么都对？**
```
因为在这题中：path.size() 永远等于 index

index=0: path=""    → path.size()=0
index=1: path="a"   → path.size()=1
index=2: path="ad"  → path.size()=2

path的长度和index始终同步！
```

**为什么推荐用index？**
1. ✅ 语义更清晰："处理了几个数字"
2. ✅ 与参数名一致
3. ✅ 不依赖path的实现细节
4. ✅ 更鲁棒（如果path添加分隔符也不会出错）

**什么时候必须用index？**
```cpp
// 当path长度和递归深度不一致时
void dfs(int index) {
    if(index == target) {  // 必须用index
        // path可能为空或有多个元素
    }
    // 跳步问题
    dfs(index + 2);  // 可能跳过某些index
}
```

#### **4. 决策树图解**

```
digits = "23"

                    ""  (index=0)
            /       |       \
           a        b        c    ← 从"abc"选
          /|\      /|\      /|\
         d e f    d e f    d e f  ← 从"def"选 (index=1)

执行过程：
dfs(index=0, path="")
├─ 选'a' → path="a"
│  └─ dfs(index=1, path="a")
│     ├─ 选'd' → path="ad" → 记录"ad" ✅
│     ├─ 选'e' → path="ae" → 记录"ae" ✅
│     └─ 选'f' → path="af" → 记录"af" ✅
├─ 选'b' → path="b"
│  └─ dfs(index=1, path="b")
│     ├─ 选'd' → path="bd" → 记录"bd" ✅
│     └─ ...
└─ 选'c' → ...
```

#### **5. index参数的作用**

```cpp
void dfs(string digits, int index) {
    // index的三个作用：
    
    // 1. 判断递归出口
    if(index >= digits.size()) return;
    
    // 2. 确定当前处理哪个数字
    char digit = digits[index];
    
    // 3. 传递给下一层
    dfs(digits, index + 1);
}
```

### 方法论反思

**有帮助的地方**：
1. ✅ 第1步帮助识别：需要index参数
2. ✅ 第3步帮助理解：每层从不同集合选
3. ✅ 第5步检查：发现不需要check数组

**遇到的困难**：
1. ❌ 最初想用check数组（理解错了）
2. ❌ path类型搞错了
3. ❌ 缺少index参数导致无限递归

**需要完善的地方**：
- 方法论需要强调：识别"同一集合"vs"不同集合"
- 需要明确何时需要check数组
- 需要对比不同题型的模板差异

### 核心收获

**回溯三大类型对比**：

```
类型1：全排列型
- 同一集合，关心顺序
- 需要check数组
- for从0开始，递归不传参数

类型2：子集/组合型
- 同一集合，不关心顺序
- 不需要check，用index
- for从index开始，递归传i+1

类型3：多集合组合型（本题）
- 不同集合，每层一个集合
- 不需要check，用index
- for遍历当前集合，递归传index+1
```

**记忆口诀**：
```
同一集合关心顺序 → 全排列（check数组）
同一集合不关心顺序 → 子集（index参数）
不同集合组合 → 电话号码（index参数，无check）

判断标准：
- 有重复使用风险？→ 需要check
- 每层不同集合？→ 不需要check
```

**关键理解**：
```
全排列：防止同一个元素被重复使用
子集：防止产生重复的子集
电话号码：每层不同集合，天然不重复
```

---

## 4. LeetCode 22 - 括号生成 ✅

### 题目信息
- 比特课程：专题四_综合练习_括号生成_C++
- LeetCode编号：22
- 难度：中等

### 题目理解
- 生成所有由n对括号组成的合法括号组合
- 示例：n=3 → ["((()))","(()())","(())()","()(())","()()()"]
- 关键：什么情况下可以放左括号？什么情况下可以放右括号？

### 方法论应用

**第1步：明确函数语义**
```cpp
void dfs(int n)
功能：基于当前状态，生成所有合法的括号组合
全局变量：
  - path: 当前括号序列
  - countl: 剩余左括号数量
  - countr: 剩余右括号数量
  - check: 已放的左括号数 - 已放的右括号数（合法性标记）
  - ret: 存储所有结果
```

**第2步：找递归出口**
- 显式出口：`countl == 0 && countr == 0 && check >= 0`
- 说明：所有括号都放完了，且合法（check>=0）

**第3步：确定子问题**
- 每个位置有两个选择：
  1. 放左括号（需要剪枝）
  2. 放右括号（需要剪枝）
- 递归尝试两个选择
- **关键**：需要剪枝保证合法性

**第4步：设计递归体**
- 选择1：尝试放左括号
  - 条件：`countl > 0`（还有剩余）
  - 操作：path添加'('，countl--，check++
  - 递归后恢复现场
- 选择2：尝试放右括号
  - 条件：`countr > 0 && check > 0`（剪枝！）
  - 操作：path添加')'，countr--，check--
  - 递归后恢复现场

**第5步：检查语义一致性**
- ✅ 每个位置尝试两个选择
- ✅ 剪枝条件保证合法性
- ✅ 恢复现场完整（path、countl/countr、check）

### 初始错误

**错误1：用while循环**
```cpp
while(countl > 0 | countr > 0) {  // ❌ 应该用if
    // while会一直循环，不符合回溯逻辑
}
```

**错误2：使用put标记变量**
```cpp
bool put = true;
if(countl > 0 && put) { ... }   // ❌ 不需要put标记
if(countr > 0 && !put) { ... }  // 错误理解：轮流放左右括号
```

**错误3：恢复现场不完整**
```cpp
countl++;  // ❌ 只恢复了countl
// 缺少：
// - path.pop_back()
// - check的恢复
// - countr的恢复
```

**错误4：语法错误**
```cpp
put = ture;  // ❌ 拼写错误，应该是true
```

### 正确代码

```cpp
class Solution {
public:
    vector<string> ret;
    string path;
    int countl, countr, check;
    
    vector<string> generateParenthesis(int n) {
        countl = n;
        countr = n;
        check = 0;
        dfs(n);
        return ret;
    }
    
    void dfs(int n) {
        // 1. 递归出口
        if(countl == 0 && countr == 0 && check >= 0) {
            ret.push_back(path);
            return;
        }
        
        // 2. 选择1：尝试放左括号
        if(countl > 0) {  // 剪枝1：还有剩余左括号
            path += '(';
            countl--;
            check++;
            dfs(n);
            // 恢复现场
            path.pop_back();
            countl++;
            check--;
        }
        
        // 3. 选择2：尝试放右括号
        if(countr > 0 && check > 0) {  // 剪枝2：还有剩余 且 保证合法
            path += ')';
            countr--;
            check--;
            dfs(n);
            // 恢复现场
            path.pop_back();
            countr++;
            check++;
        }
    }
};
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(n) 递归栈

### 核心知识点

#### **1. 剪枝条件（关键！）**

**剪枝1：左括号数量限制**
```cpp
if(countl > 0) {  // 还有剩余左括号才能放
    放左括号;
}
```

**剪枝2：右括号合法性限制**
```cpp
if(countr > 0 && check > 0) {
    // countr > 0：还有剩余右括号
    // check > 0：保证合法性（左括号 > 右括号）
    放右括号;
}
```

**为什么check > 0能保证合法？**
```
check = 已放的左括号数 - 已放的右括号数

合法括号的特点：
- 任意前缀，左括号数 >= 右括号数
- 即 check >= 0

当 check > 0 时：
- 左括号 > 右括号
- 可以安全地放右括号

当 check <= 0 时：
- 右括号 >= 左括号
- 不能再放右括号（会非法）

示例：
"(()" → check变化：0→1→2→1 ✅
"())" → check变化：0→1→0→-1 ❌
```

#### **2. check变量的巧妙之处**

```cpp
int check = 0;  // 初始化

// 放左括号：check++
path += '(';
check++;  // 左括号数+1

// 放右括号：check--
path += ')';
check--;  // 相对而言，右括号数+1

// 判断：check > 0
// 含义：左括号比右括号多，可以放右括号
```

**check的含义**：
- `check = 0`：左右括号数量相等
- `check > 0`：左括号多，可以放右括号
- `check < 0`：右括号多，非法！（不会出现）

#### **3. 决策树图解（n=2）**

```
                    "" (check=0)
                    /         \
                放'('          ❌不能先放')'
                  /              (check=0，不能放)
               "(" (check=1)
              /           \
          放'('          放')'
            /               \
        "((" (check=2)    "()" (check=0)
          |                 |
        放')'             放'('
          |                 |
       "(()" (check=1)   "()(" (check=1)
          |                 |
        放')'             放')'
          |                 |
      "(())" ✅         "()()" ✅

结果：["(())", "()()"]
```

#### **4. 为什么用if不用while？**

**错误理解：while循环**
```cpp
while(countl > 0) {
    放左括号;
    dfs();
}
// while会一直循环，直到条件为false
// 不符合回溯的"尝试-递归-回溯"模式
```

**正确理解：if判断**
```cpp
if(countl > 0) {
    放左括号;
    dfs();      // 递归探索这个选择
    恢复现场;    // 回溯
}
// if是"尝试一次，递归，回溯"
// 符合回溯模式
```

#### **5. 回溯的三部曲**

```cpp
// 对于每个选择：
// 1. 做选择
path += '(';
countl--;
check++;

// 2. 递归
dfs(n);

// 3. 撤销选择（恢复现场）
path.pop_back();
countl++;
check--;
```

**恢复现场必须完整！**
- ✅ path.pop_back()
- ✅ countl++（如果有countl--）
- ✅ countr++（如果有countr--）
- ✅ check恢复（如果有修改）

### 方法论反思

**有帮助的地方**：
1. ✅ 第3步帮助识别：每个位置有两个选择
2. ✅ 第4步帮助设计：需要剪枝条件
3. ✅ 第5步检查：发现恢复现场不完整

**遇到的困难**：
1. ❌ 最初用while循环（理解错了）
2. ❌ 想用put标记变量（多余的）
3. ❌ 恢复现场不完整
4. ❌ 剪枝条件理解花了些时间

**需要完善的地方**：
- 方法论需要强调：回溯用if，不用while
- 需要强调：恢复现场的完整性检查
- 需要强调：剪枝的重要性

### 核心收获

**括号生成的关键**：
```
1. 每个位置两个选择（不是轮流）
2. 剪枝保证合法性
   - 左括号：还有剩余
   - 右括号：还有剩余 且 左括号>右括号
3. check变量巧妙记录合法性
4. 完整恢复现场
```

**记忆口诀**：
```
括号生成两选择：
左括号看剩余（countl > 0）
右括号看合法（check > 0）

回溯三部曲：
做选择 → 递归 → 恢复现场

check变量作用：
左括号++ 右括号--
check>0 可放右括号
```

**与之前题目的对比**：
```
全排列/子集/电话号码：
- 选择不同元素

括号生成：
- 选择同一类元素（括号）
- 但需要剪枝保证合法性
- 剪枝是核心！
```

---

## 5. LeetCode 77 - 组合

### 题目信息
- 比特课程：专题四_综合练习_组合_C++
- LeetCode编号：77

### 方法论应用
**第1步：明确函数语义**
（待记录）

**第2步：找递归出口**
（待记录）

**第3步：确定子问题**
（待记录）

**第4步：设计递归体**
（待记录）

**第5步：检查语义一致性**
（待记录）

### 解题代码
```cpp
// 待完成
```

### 提交结果
- 提交时间：
- 执行用时：
- 内存消耗：

### 方法论反思
（记录方法论哪里有帮助，哪里需要完善）

---

## 6. LeetCode 494 - 目标和

### 题目信息
- 比特课程：专题四_综合练习_目标和_C++
- LeetCode编号：494

### 方法论应用
**第1步：明确函数语义**
（待记录）

**第2步：找递归出口**
（待记录）

**第3步：确定子问题**
（待记录）

**第4步：设计递归体**
（待记录）

**第5步：检查语义一致性**
（待记录）

### 解题代码
```cpp
// 待完成
```

### 提交结果
- 提交时间：
- 执行用时：
- 内存消耗：

### 方法论反思
（记录方法论哪里有帮助，哪里需要完善）

---

## 今日总结

### 完成情况
（记录完成的题目）

### 方法论测试结果
**有帮助的地方**：
（记录哪些步骤/检查点特别有用）

**需要完善的地方**：
（记录哪些地方不够清晰，需要补充）

**新增经验**：
（记录新发现的规律、技巧）

### 核心收获
（记录今天的核心收获）

### 方法论迭代建议
（记录对方法论的改进建议）

