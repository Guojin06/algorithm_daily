# Day48-11.19-背包问题扫尾

## 今日计划
- 背包问题扫尾：6道高频变种题目
- 掌握二维费用背包、特殊转化技巧
- 完善背包问题知识体系
- 每题按标准模板记录：题目小结、思路框架、代码、复盘要点

---

## 279. 完全平方数

### 题目小结
- 输入：正整数 `n`。
- 规则：找到和为 `n` 的**最少**完全平方数个数。
- 输出：最少完全平方数个数。
- 完全平方数：1, 4, 9, 16, ...

### 思路框架（完全背包最小值问题）

#### 1. 问题转化
- **物品**：完全平方数 `1, 4, 9, 16, ..., k² ≤ n`
- **重量**：完全平方数的值
- **价值**：1（每个平方数贡献1个数量）
- **目标**：凑成 `n` 的最少物品数
- **关键**：每个平方数可以用无限次

#### 2. 状态定义
- `dp[j]`：凑成整数 `j` 的最少完全平方数个数

#### 3. 初始化策略
```cpp
vector<int> dp(n + 1, n + 1);  // 初始化为最大值+1
dp[0] = 0;  // 凑成0需要0个平方数
```

#### 4. 状态转移
```cpp
// 完全背包：外层遍历物品，内层正序遍历容量
for (int i = 1; i * i <= n; ++i) {
    int square = i * i;
    for (int j = square; j <= n; ++j) {
        dp[j] = min(dp[j], dp[j - square] + 1);
    }
}
```

### 我的代码尝试

```cpp
class Solution {
public:
    int numSquares(int n) {
        // 完全背包的最小值问题
        // 物品：完全平方数1, 4, 9, 16
        // 重量：平方数的值
        // 价值：1（每个平方数贡献1个数量）
        // 目标：凑成n的最小物品数
        // 特点：每个平方数可以用无限次

        // 状态定义：dp[j]:凑成整数j的最少完全平方数个数
        vector<int> dp(n+1, n+1);  // 初始化为最大值+1
        dp[0] = 0;  // 凑成0需要0个平方数

        // 完全背包：外层遍历物品，内层正序遍历容量
        for(int i = 1; i*i <= n; i++) {
            int square = i*i;
            for(int j = square; j <= n; j++) {
                dp[j] = min(dp[j], dp[j-square] + 1);
            }
        }
        return dp[n];
    }
};
```

### 与LeetCode 322零钱兑换的对比分析

#### 相同点
```cpp
// 都是完全背包最小值问题的标准框架
vector<int> dp(amount + 1, amount + 1);  // 初始化为最大值+1
dp[0] = 0;  // 基础情况

for (物品) {
    for (int j = 重量; j <= 目标; ++j) {  // 正序遍历
        dp[j] = min(dp[j], dp[j-重量] + 1);
    }
}
```

**共同特征**：
1. **问题类型**：都是完全背包 + 最小值问题
2. **初始化策略**：`dp[0] = 0, dp[1..n] = n+1`（相当于无穷大）
3. **遍历顺序**：外层物品，内层容量，正序遍历
4. **转移操作**：用 `min` 求最小值
5. **可达性处理**：无需检查，`min`自动排除不可达状态

#### 不同点
| 对比项 | 零钱兑换I | 完全平方数 |
|--------|------------|------------|
| **物品来源** | 给定硬币数组 `coins` | 动态生成平方数 `i*i` |
| **物品范围** | `for (int coin : coins)` | `for (int i = 1; i*i <= n; ++i)` |
| **物品数量** | 最多300个硬币 | 最多√n个平方数 |
| **物品特性** | 任意正整数 | 必须是完全平方数 |
| **应用场景** | 货币找零 | 数学分解问题 |

#### 代码对比
```cpp
// 零钱兑换I
for (int coin : coins) {                    // 遍历给定硬币
    for (int j = coin; j <= amount; ++j) {
        dp[j] = min(dp[j], dp[j-coin] + 1);
    }
}

// 完全平方数
for (int i = 1; i*i <= n; ++i) {            // 动态生成平方数
    int square = i*i;
    for (int j = square; j <= n; ++j) {
        dp[j] = min(dp[j], dp[j-square] + 1);
    }
}
```

#### 思路相同点
1. **问题转化**：都成功转化为完全背包问题
2. **状态定义**：`dp[j]` 表示凑成目标值的最少物品数
3. **最优子结构**：基于剩余子问题的最优解构建当前解
4. **无后效性**：当前状态只依赖于前面的状态

#### 思路不同点
1. **物品生成方式**：
   - 零钱兑换：物品是输入给定的
   - 完全平方数：物品需要动态计算生成
2. **问题背景**：
   - 零钱兑换：经济应用场景
   - 完全平方数：数学分解场景
3. **约束条件**：
   - 零钱兑换：硬币面额任意
   - 完全平方数：必须是完全平方数

### 复盘要点
- [ ] ✅ 成功识别完全背包最小值问题：
  - 物品可重复使用（完全背包）
  - 求最少数量（最小值问题）
- [ ] ✅ 掌握标准初始化策略：
  - `dp[0] = 0, dp[1..n] = n+1`
  - 无穷大值设为 `n+1`（最多n个1）
- [ ] ✅ 理解物品动态生成：
  - 平方数需要通过循环计算 `i*i`
  - 范围限制 `i*i <= n`
- [ ] ✅ 与零钱兑换的对比理解：
  - 框架完全相同，只是物品来源不同
  - 体现了背包问题的通用性

---

## 377. 组合总和 Ⅳ

### 题目小结
- 输入：不同正整数数组 `nums`，目标整数 `target`。
- 规则：求和为 `target` 的**排列**数量。
- 输出：排列数量（结果可能很大，对 10⁹+7 取模）。
- 关键：顺序不同的序列算作不同的组合。

### 思路框架（完全背包排列数问题）

#### 1. 问题转化
- **物品**：数组中的数字
- **重量**：数字的值
- **价值**：1（每个数字贡献1种排列方式）
- **目标**：凑成 `target` 的排列数量
- **关键**：求排列数，不是组合数

#### 2. 状态定义
- `dp[j]`：凑成整数 `j` 的排列数量

#### 3. 初始化策略
```cpp
vector<int> dp(target + 1, 0);
dp[0] = 1;  // 凑成0有1种方式（空序列）
```

#### 4. 状态转移（排列数）
```cpp
// 排列数：外层遍历容量，内层遍历物品
for (int j = 1; j <= target; ++j) {
    for (int num : nums) {
        if (j >= num) dp[j] += dp[j - num];
    }
}
```

### 我的代码尝试

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<unsigned long long> dp(target + 1, 0);  // 防中间溢出
        dp[0] = 1;  // 凑成0有一种方法
        
        // dp[j] = 凑成整数j的排列数量
        for (int j = 1; j <= target; ++j) {
            for (int num : nums) {  // 外层容量，内层物品（排列数特征）
                if (j >= num) {
                    dp[j] = dp[j] + dp[j - num];  // 计数用加法
                }
            }
        }
        
        return (int)dp[target];  // 最终转换回int
    }
};
```

### 转移方程的深度理解

#### 方程含义：
```cpp
dp[j] = dp[j] + dp[j - num]

物理意义：
"凑成j的排列数" = "原有的排列数" + "最后一步用num的排列数"
```

#### 递归思想：
```cpp
f(j) = 凑成j的排列数
f(j) = f(j-1) + f(j-2) + f(j-3) + ...  (枚举所有可能的最后一步)
     = Σ f(j - num)

边界条件：f(0) = 1 (空排列)
```

#### 具体例子：`nums = [1,2,3], target = 3`
```cpp
计算 dp[3]：
- 最后一步用1：前面凑成2的排列 [1,1], [2] → [1,1,1], [2,1]
- 最后一步用2：前面凑成1的排列 [1] → [1,2]  
- 最后一步用3：前面凑成0的排列 [] → [3]

最终：[1,1,1], [2,1], [1,2], [3] → 4种排列
```

### 与LeetCode 518零钱兑换II的对比分析

#### 相同点
```cpp
// 都是完全背包计数问题的标准框架
vector<int> dp(target + 1, 0);
dp[0] = 1;  // 空集/空序列是一种有效方式

// 都用加法操作
dp[j] = dp[j] + dp[j - weight];
```

**共同特征**：
1. **问题类型**：完全背包 + 计数问题
2. **初始化策略**：`dp[0] = 1, dp[1..n] = 0`
3. **可达性处理**：无需检查，`0 + 0 = 0` 安全
4. **转移操作**：用加法求方法数

#### 不同点
| 对比项 | 零钱兑换II | 组合总和Ⅳ |
|--------|------------|------------|
| **要求类型** | 组合数 | 排列数 |
| **遍历顺序** | 外层物品，内层容量 | 外层容量，内层物品 |
| **顺序敏感性** | 顺序不重要 | 顺序重要 |
| **数据类型** | 可能需要防溢出 | 中间过程需要大类型 |

#### 代码对比
```cpp
// 零钱兑换II：组合数
for (int coin : coins) {                    // 外层：物品
    for (int j = coin; j <= amount; ++j) {  // 内层：容量
        dp[j] += dp[j - coin];
    }
}

// 组合总和Ⅳ：排列数
for (int j = 1; j <= target; ++j) {         // 外层：容量
    for (int num : nums) {                  // 内层：物品
        if (j >= num) dp[j] += dp[j - num];
    }
}
```

#### 结果差异示例
```cpp
nums = [1,2], target = 3

组合数（零钱兑换II）：[1,1,1], [1,2] → 2种
排列数（组合总和Ⅳ）：[1,1,1], [1,2], [2,1] → 3种
```

### 遍历顺序的物理意义

#### 组合数写法（外层物品内层容量）：
```cpp
for (int coin : coins) {
    for (int j = coin; j <= amount; ++j) {
        dp[j] += dp[j - coin];
    }
}

物理意义：
- 先决定用几个硬币1
- 再决定用几个硬币2
- 最后决定用几个硬币5
- 顺序固定，不会重复
```

#### 排列数写法（外层容量内层物品）：
```cpp
for (int j = 1; j <= target; ++j) {
    for (int num : nums) {
        if (j >= num) dp[j] += dp[j - num];
    }
}

物理意义：
- 凑成金额j的最后一步：
  - 可以是硬币1
  - 可以是硬币2
  - 可以是硬币5
- 枚举所有可能的最后一步
- 顺序可变，产生排列
```

### 关键技术点

#### 1. 数据类型选择
```cpp
// 题目说"符合32位整数范围"，但中间过程可能溢出
vector<unsigned long long> dp(target + 1, 0);  // 防中间溢出
return (int)dp[target];  // 最终转换回int
```

#### 2. 可达性处理
```cpp
// 计数问题天然安全，无需检查
dp[j] += dp[j - num];  // 0 + 0 = 0，不会产生虚假计数
```

#### 3. 遍历顺序的重要性
```cpp
// 组合数 vs 排列数的关键区别就是遍历顺序
// 外层物品内层容量 → 组合数（顺序固定）
// 外层容量内层物品 → 排列数（顺序可变）
```

### 复盘要点
- [ ] ✅ 成功识别完全背包排列数问题：
  - 物品可重复使用（完全背包）
  - 求排列数量（顺序重要）
- [ ] ✅ 掌握排列数的遍历顺序：
  - 外层遍历容量，内层遍历物品
  - 枚举所有可能的"最后一步"
- [ ] ✅ 理解转移方程的物理意义：
  - `dp[j] = dp[j] + dp[j - num]` 的递归含义
  - 枚举最后一步的思想
- [ ] ✅ 处理数据类型问题：
  - 中间过程用 `unsigned long long` 防溢出
  - 最终结果转换回 `int`
- [ ] ✅ 与组合数问题的深度对比：
  - 遍历顺序决定结果类型
  - 物理意义的本质差异

---

## 474. 一和零

### 题目小结
- 输入：二进制字符串数组 `strs`，两个整数 `m`（最多0的个数）、`n`（最多1的个数）。
- 规则：从 `strs` 中选出一个子集，使得其中所有字符串包含的 `0` 总数不超过 `m`，`1` 总数不超过 `n`.
- 输出：满足条件的**最大子集大小**。
- 关键：每个字符串要么选、要么不选，不能重复选 → 01 背包；同时有两个限制 → 二维费用背包。

### 思路框架（二维费用 01 背包，最大值问题）

#### 1. 问题转化
- **物品**：每个二进制字符串 `str`.
- **费用1**：该字符串中 `0` 的个数 `zeros`.
- **费用2**：该字符串中 `1` 的个数 `ones`.
- **容量1**：最多 `m` 个 `0`.
- **容量2**：最多 `n` 个 `1`.
- **价值**：1（选一个字符串，子集大小 +1）。
- **目标**：在不超过两个容量的前提下，让子集大小最大。

#### 2. 状态定义
- `dp[i][j]`：在 **最多** `i` 个 `0`、`j` 个 `1` 的限制下，能选出的字符串**最大个数**。

#### 3. 初始化策略
```cpp
vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
// 默认值为 0：不选任何字符串时，子集大小为 0
```

#### 4. 状态转移（二维 01 背包）
```cpp
for (string str : strs) {                 // 第1层：遍历每个字符串（物品）
    int zeros = 0, ones = 0;
    for (char c : str) {
        if (c == '0') ++zeros;
        else ++ones;
    }

    // 二维 01 背包：两个维度都要逆序遍历
    for (int i = m; i >= zeros; --i) {      // 维度1：0 的容量
        for (int j = n; j >= ones; --j) {   // 维度2：1 的容量
            dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);
        }
    }
}
```

### 我的代码尝试

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        // dp[i][j] = 在最多 i 个 0、j 个 1 的限制下能选出的最大字符串个数
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        for (const string& str : strs) {
            int zeros = 0, ones = 0;
            for (char c : str) {
                if (c == '0') ++zeros;
                else ++ones;
            }

            // 二维 01 背包：两个维度都逆序，防止同一个字符串被重复使用
            for (int i = m; i >= zeros; --i) {
                for (int j = n; j >= ones; --j) {
                    dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);
                }
            }
        }

        return dp[m][n];
    }
};
```

### 状态转移方程的含义

核心转移：
```cpp
dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1);
```

含义拆解：
- 当前考虑的字符串消耗：`zeros` 个 0、`ones` 个 1。
- 当前背包状态容量：最多 `i` 个 0、`j` 个 1。
- **不选这个字符串**：保持原状态 `dp[i][j]`.
- **选这个字符串**：
  - 先在容量缩小后的状态下选：`dp[i - zeros][j - ones]`，表示“已经用了 `zeros` 个 0 和 `ones` 个 1 之前的最优解”。
  - 再加上当前这个字符串本身：`+ 1`（子集大小+1）。
- 在“选”和“不选”两种方案中取最大值。

为什么循环要从 `i = m .. zeros`、`j = n .. ones` 逆序？
- 这是 **01 背包** 的标准写法，保证每个字符串最多只被用一次。
- 逆序保证更新 `dp[i][j]` 时，用到的 `dp[i-zeros][j-ones]` 仍然是“上一轮（没用当前字符串时）的结果”，不会在同一轮里重复叠加当前字符串。

也可以理解为：
- `dp[i][j]` = 在当前容量下“最好什么都不变”的方案 vs “强行选当前字符串”之后的方案，取一个更大的。

### 复盘要点
- [ ] ✅ 成功识别二维费用 01 背包问题：
  - 有两个容量限制（0 的个数、1 的个数）。
  - 每个字符串只能选一次 → 01 背包，二维都要逆序遍历。
- [ ] ✅ 理解状态定义：
  - `dp[i][j]` 表示“最多 i 个 0、j 个 1 时能选的最大字符串个数”。
- [ ] ✅ 理解状态转移方程含义：
  - `max(不选当前字符串, 选当前字符串)` 的典型 01 背包形式。
  - 选当前字符串需要从 `dp[i-zeros][j-ones]` 转移，并加 1。
- [ ] ✅ 掌握二维 01 背包的遍历顺序：
  - 两个维度都必须逆序，防止同一物品被使用多次。

---

## 879. 盈利计划

### 题目小结
- 输入：最多可用员工数 `n`，至少要达到的利润 `minProfit`，项目所需员工数组 `group`，项目利润数组 `profit`。
- 规则：选出若干项目，使得使用员工数 ≤ `n`，总利润 ≥ `minProfit`。
- 输出：满足条件的**方案数**（对 1e9+7 取模）。
- 关键：每个项目要么做要么不做 → 01 背包；两个约束维度（员工上限、利润下限）→ 二维费用背包 + 计数问题。

### 思路框架（二维费用 01 背包 + 计数问题）

#### 1. 问题转化
- **物品**：每个项目。
- **费用1**：`group[i]`（消耗的员工数）。
- **费用2**：`profit[i]`（贡献的利润）。
- **容量1**：最多 `n` 个员工。
- **容量2**：至少 `minProfit` 利润（下限约束）。
- **价值**：1（每种选法算 1 种方案）。
- **目标**：在不超过员工数、利润 ≥ minProfit 的前提下，方案数最大（计数）。

#### 2. 状态定义（关键技巧：利润截断）
- `dp[i][j]`：使用**恰好 i 个员工**，利润**至少为 j** 的方案数。
- `0 ≤ i ≤ n`，`0 ≤ j ≤ minProfit`
- 当实际利润 > minProfit 时，截断到 `j = minProfit` 存储。

#### 3. 初始化策略
```cpp
vector<vector<int>> dp(n + 1, vector<int>(minProfit + 1, 0));
dp[0][0] = 1;  // 基础情况：0员工0利润，什么都不做算1种方案
```

#### 4. 状态转移（二维 01 背包 + 计数）
```cpp
const int MOD = 1e9 + 7;

for (int k = 0; k < group.size(); ++k) {
    int members = group[k];
    int earn = profit[k];
    
    // 二维 01 背包：两个维度都要逆序遍历
    for (int i = n; i >= members; --i) {          // 员工维度逆序
        for (int j = minProfit; j >= 0; --j) {    // 利润维度逆序
            // 利润截断：超过 minProfit 的都算 minProfit
            int newProfit = min(minProfit, j + earn);
            dp[i][newProfit] = (dp[i][newProfit] + dp[i - members][j]) % MOD;
        }
    }
}
```

### 我的代码尝试

```cpp
class Solution {
public:
    int profitableSchemes(int n, int minProfit, vector<int>& group, vector<int>& profit) {
        const int MOD = 1e9 + 7;
        
        // dp[i][j] = 使用恰好 i 个员工，利润至少为 j 的方案数
        vector<vector<int>> dp(n + 1, vector<int>(minProfit + 1, 0));
        
        // 基础情况：0员工0利润，什么都不做算1种方案
        dp[0][0] = 1;
        
        // 遍历每个项目（物品）
        for (int k = 0; k < group.size(); ++k) {
            int members = group[k];     // 当前项目需要的员工数（费用1）
            int earn    = profit[k];    // 当前项目产生的利润（费用2）
            
            // 二维 01 背包：两个维度都要逆序遍历，防止重复使用当前项目
            for (int i = n; i >= members; --i) {          // 员工维度逆序
                for (int j = minProfit; j >= 0; --j) {    // 利润维度逆序
                    // 利润截断：超过 minProfit 的都算 minProfit
                    int newProfit = min(minProfit, j + earn);
                    
                    // 从"没用当前项目"的状态转移过来
                    dp[i][newProfit] = (dp[i][newProfit] + dp[i - members][j]) % MOD;
                }
            }
        }
        
        // 最终答案：所有员工数（0..n）下，利润至少 minProfit 的方案总数
        long long ans = 0;
        for (int i = 0; i <= n; ++i) {
            ans = (ans + dp[i][minProfit]) % MOD;
        }
        
        return (int)ans;
    }
};
```

### 利润截断技巧详解

#### 为什么需要截断？
- 传统二维背包：两个都是上限约束（如 474 题：0 ≤ m, 1 ≤ n）。
- 本题：员工是上限（≤ n），利润是**下限**约束（≥ minProfit）。
- 我们只关心利润是否达到 `minProfit`，不关心具体超过多少。

#### 截断的做法
```cpp
int newProfit = min(minProfit, j + earn);
```
- 如果 `j + earn < minProfit`：还没达标，存 `j + earn`。
- 如果 `j + earn ≥ minProfit`：已经达标，存 `minProfit`。

#### 举例说明
```
minProfit = 5, 当前 j = 4, earn = 2
原本利润应该是 6，但截断后存 5（因为 6 和 5 都是"已达标"）

minProfit = 5, 当前 j = 3, earn = 1  
利润是 4，还没达标，就存 4
```

#### 截断的好处
- **状态合并**：所有利润 ≥ minProfit 的状态合并到 `j = minProfit`。
- **不影响答案**：题目只问"至少 minProfit"，不问具体利润值。
- **节省空间**：利润维度从 `0..totalProfit` 压缩到 `0..minProfit`。

### 状态转移方程的含义

核心转移：
```cpp
dp[i][newProfit] = (dp[i][newProfit] + dp[i - members][j]) % MOD;
```

含义拆解：
- `dp[i - members][j]`：之前用 `i - members` 个员工、利润至少 `j` 的方案数。
- 加上当前项目后：
  - 员工数：`i - members + members = i`
  - 利润：`j + earn`，截断到 `newProfit`
- 所以新的方案数要累加到 `dp[i][newProfit]`。

为什么两个维度都要逆序？
- **员工维度逆序**：保证每个项目只用一次（01 背包特征）。
- **利润维度逆序**：防止同一项目在同一轮被多次利用更新到更高 `j` 时再被使用。

### 最终答案的构造

```cpp
long long ans = 0;
for (int i = 0; i <= n; ++i) {
    ans = (ans + dp[i][minProfit]) % MOD;
}
```
- 我们只需要所有员工数下，利润至少 `minProfit` 的方案总数。
- 不需要关心具体用了多少员工，只要不超过 `n` 即可。

### 复盘要点
- [ ] ✅ 成功识别二维费用 01 背包 + 计数问题：
  - 两个约束维度（员工上限、利润下限）。
  - 求方案数（计数问题）。
- [ ] ✅ 掌握利润截断技巧：
  - 下限约束转化为截断存储。
  - 所有 ≥ minProfit 的状态合并到 `j = minProfit`。
- [ ] ✅ 理解状态定义：
  - `dp[i][j]` 表示"恰好 i 个员工，利润至少 j"的方案数。
- [ ] ✅ 掌握二维 01 背包计数框架：
  - 两个维度都要逆序遍历。
  - 用加法累加方案数，注意取模。
- [ ] ✅ 理解最终答案构造：
  - 累加所有员工数下的 `dp[i][minProfit]`。

---

## 今日总结
- [ ] 完全平方数：完全背包最小值问题
- [ ] 组合总和 Ⅳ：完全背包排列数问题
- [ ] 一和零：二维费用 01 背包最大值问题
- [ ] 盈利计划：二维费用 01 背包计数问题
- [ ] 掌握组合数vs排列数的实现差异
- [ ] 理解完全背包与二维费用背包的变种处理
- [ ] 掌握利润截断技巧（下限约束的转化）

## 明日计划
- 继续背包问题扫尾：特殊转化问题
- 目标和、数位成本等题目
- 完善背包问题知识体系
