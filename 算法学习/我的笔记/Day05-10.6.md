# Day05 - 10月6日学习笔记

**日期：** 2025年10月6日（周日）  
**新策略：** ❌ 不再纠结欠账！从今天开始，往前走！  
**今日目标：** 4-5题新内容，保持前进的节奏  
**学习时间：** 3-4小时

---

## 💪 新的学习策略（重要！）

### ❌ 旧思路（错误）：
- 每天补之前的题 → 永远在还债 → 没成就感 → 心情糟糕 ❌

### ✅ 新思路（正确）：
- **已经做的9题就是基础！**
- **今天是Day05，就做Day05的内容！**
- **不再纠结"欠账"，保持前进！**
- **目标调整为每天4-5题（而非7-8题）**
- **10月目标：150题（而非200题）**

---

## 📊 累计进度

**已完成：9题**
- 双指针基础：移动零、删除重复项、有序数组平方、反转字符串
- 双指针进阶：盛水容器、有效三角形、查找总价格
- 滑动窗口入门：和≥target最短子数组
- 哈希表：两数之和

**今日新增：4-5题**

---

## 📚 讲解资源说明（重要！）

**今天的4题都有详细讲解！不要死磕！**

### 讲解资源类型：
- ✅ **比特课程**：打开 `比特课程/算法精品课1.md`，有图解和完整代码
- ✅ **代码随想录**：B站搜索题目名，有视频讲解（推荐边看边写）
- ✅ **LeetCode题解**：题目页面 → 点击"题解"标签 → 看官方题解或高赞题解

### 学习流程（推荐）：
1. **看题5分钟** → 理解题意，想想思路
2. **卡住了？** → 立刻看讲解（比特课程 or 代码随想录）
3. **理解思路后** → 关掉讲解，自己写代码
4. **AC后** → 对比题解，看有没有更优的写法
5. **记录笔记** → 写下自己的理解和踩坑点

**⏰ 单题时间控制：**
- 10分钟想不出思路 → 看讲解
- 15分钟写不出代码 → 看讲解
- 30分钟还在调试 → 找我或看讲解

---

## 🎯 今日学习计划（Day05内容）

### 专题：滑动窗口深化 + 三数之和

**为什么选这些题？**
- 你已经做过"和≥target最短子数组"（滑动窗口入门）✅
- 今天继续滑动窗口，把这个技巧掌握透彻
- 加上一个超高频面试题"三数之和"

---

### 今日必做题（4题）

#### 1. **无重复字符的最长子串**（LeetCode 3）⭐⭐⭐⭐⭐
- **难度：** 中等
- **知识点：** **滑动窗口模板题！**
- **预计时间：** 30-40分钟
- **为什么做：** 滑动窗口最经典题目，必须掌握！
- **讲解资源：**
  - ✅ **比特课程**：`比特课程/算法精品课1.md` - 有详细讲解
  - ✅ **代码随想录**：有视频讲解
  - 📺 B站搜索："代码随想录 无重复字符的最长子串"

#### 2. **找到字符串中所有字母异位词**（LeetCode 438）⭐⭐⭐
- **难度：** 中等
- **知识点：** 固定长度滑动窗口
- **预计时间：** 25-30分钟
- **为什么做：** 巩固滑动窗口
- **讲解资源：**
  - ✅ **比特课程**：`比特课程/算法精品课1.md` - 有详细讲解
  - ✅ **代码随想录**：有讲解
  - ⚠️ 如果卡住：看LeetCode官方题解

#### 3. **最大连续1的个数III**（LeetCode 1004）⭐⭐
- **难度：** 中等
- **知识点：** 滑动窗口
- **预计时间：** 20-25分钟
- **为什么做：** 比特课程题，滑动窗口变体
- **讲解资源：**
  - ✅ **比特课程**：`比特课程/算法精品课1.md` - 有详细讲解
  - ⚠️ 如果卡住：看LeetCode官方题解

#### 4. **三数之和**（LeetCode 15）⭐⭐⭐⭐⭐
- **难度：** 中等
- **知识点：** 双指针 + 去重
- **预计时间：** 40-50分钟
- **为什么做：** **超高频面试题！**
- **讲解资源：**
  - ✅ **比特课程**：`比特课程/算法精品课1.md` - 有详细讲解
  - ✅ **代码随想录**：有视频讲解（重点推荐）
  - 📺 B站搜索："代码随想录 三数之和"

---

### 可选题（时间充裕再做）

#### 5. **字符串的排列**（LeetCode 567）⭐⭐
- **难度：** 中等
- **知识点：** 滑动窗口
- **预计时间：** 20-25分钟
- **讲解资源：**
  - ✅ **代码随想录**：有讲解
  - ⚠️ 如果卡住：看LeetCode官方题解

---

## 📝 今日题目笔记

### 第1题：无重复字符的最长子串（LeetCode 3）⭐⭐⭐⭐⭐

**题目链接：** https://leetcode.cn/problems/longest-substring-without-repeating-characters/

**📚 讲解资源（卡住了看这里）：**
- ✅ **比特课程**：打开 `比特课程/算法精品课1.md`，找到这题的详细讲解
- ✅ **代码随想录**：B站搜索 "代码随想录 无重复字符的最长子串" 有视频
- ✅ **LeetCode题解**：点击题目页面的"题解"标签，看官方题解

**题目描述：**
给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。

**示例：**
```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**滑动窗口思路：**
1. 用一个哈希表记录窗口内的字符
2. right右移扩大窗口，遇到重复字符时
3. left右移缩小窗口，直到窗口内无重复
4. 每次更新最大长度

**滑动窗口模板（背下来！）：**
```cpp
int left = 0, right = 0;
unordered_map<char, int> window; // 记录窗口内字符出现次数

while (right < s.size()) {
    char c = s[right];
    window[c]++; // 进窗口
    right++;
    
    while (window[c] > 1) { // 窗口内有重复，需要收缩
        char d = s[left];
        window[d]--; // 出窗口
        left++;
    }
    
    // 更新结果
    maxLen = max(maxLen, right - left);
}
```

**我的思路：**


**我的代码：**
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int left = 0;
        int right = 0;//不用在循环内定义，因为不需要在内层循环结束后回退
        int hash[128] = {0};//利用数组来模拟哈希值，因为只有26个字符，它的值代表字母出现次数
        int ret = 0;//定义结果变量
        while(right < s.size())
        {
            hash[s[right]]++;//1.进窗口
            while(hash[right] > 1)//2.内层循环开始，目的是左指针移动知道排除掉right左侧出现的重复值
            {
                hash[s[left++]]--;//3.排掉一个（left++），出窗口一个（hash值--）
            }
            ret = max(ret,right - left + 1);//4.更新结果，本题在内循环结束后更新结果
            right++;//5.右指针移动也可以看做是进窗口的一部分

        }
        return ret;
    }
};
```

**提交结果：**
- ❌ 解答错误：44 / 988 个通过的测试用例
- 输入：s = "abcabcbb"
- 输出：8（错误）
- 预期：3

---

## ❌ 错误分析（又是索引vs值的经典错误！）

### 问题出在第11行：

```cpp
while(hash[right] > 1)  // ❌ 错误！right是索引，不是字符！
```

**应该是：**
```cpp
while(hash[s[right]] > 1)  // ✅ 正确！s[right]才是字符
```

---

### 详细解释：

#### 变量含义回顾：
- `right`：索引，值是 0, 1, 2, 3, 4, ...
- `s[right]`：字符，值是 'a', 'b', 'c', ...
- `hash[字符]`：记录这个**字符**出现的次数

#### 你的错误代码执行过程：

**输入：s = "abcabcbb"**

| 步骤 | right | s[right] | 你写的 `hash[right]` | 正确的 `hash[s[right]]` | 结果 |
|------|-------|----------|---------------------|----------------------|------|
| 1 | 0 | 'a' | `hash[0]` | `hash['a']` | 你在检查索引0的值！❌ |
| 2 | 1 | 'b' | `hash[1]` | `hash['b']` | 你在检查索引1的值！❌ |
| 3 | 2 | 'c' | `hash[2]` | `hash['c']` | 你在检查索引2的值！❌ |
| 4 | 3 | 'a' | `hash[3]` | `hash['a']` (=2) | 你在检查索引3的值！❌ |

**关键问题：**
- `hash[right]` 检查的是 **索引位置的值**（hash[0], hash[1], hash[2]...）
- `hash[s[right]]` 检查的是 **字符的出现次数**（hash['a'], hash['b'], hash['c']...）

**为什么输出8？**
因为你的判断条件永远不会触发收缩窗口，所以窗口一直扩大：
- `hash[0]`, `hash[1]`, `hash[2]` 这些位置的值永远是0或1
- 所以 `while(hash[right] > 1)` 永远不执行
- 窗口从0扩展到7，长度 = 8

---

### 🔍 这个错误和Day01"移动零"一模一样！

**Day01错误：**
```cpp
if(right != 0)  // ❌ right是索引，不是值
```
应该是：
```cpp
if(nums[right] != 0)  // ✅ nums[right]才是值
```

**今天错误：**
```cpp
while(hash[right] > 1)  // ❌ right是索引，不是字符
```
应该是：
```cpp
while(hash[s[right]] > 1)  // ✅ s[right]才是字符
```

---

### 💡 记忆口诀（重要！）

**"要用谁的信息，就要取谁的值"**

- 要判断**这个位置的元素**是否重复 → `hash[s[right]]`
- 要判断**这个位置的元素**是否为0 → `nums[right]`
- 要判断**这个索引**本身 → `right`

**索引 ≠ 值！数组名[索引] = 值！**

---

**踩坑记录：**
1. ❌ **把 `right`（索引）当成了字符**
2. ❌ 应该用 `s[right]`（字符）去访问hash表
3. 🎯 **这是第2次犯"索引vs值"的错误了，要警惕！**

---

## ✅ 正确代码

```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int left = 0;
        int right = 0;
        int hash[128] = {0}; // 哈希表记录字符出现次数
        int ret = 0;
        
        while(right < s.size())
        {
            hash[s[right]]++; // 1. 进窗口：字符进入，计数+1
            
            while(hash[s[right]] > 1) // 2. 判断：当前字符重复了
            {
                hash[s[left]]--; // 3. 出窗口：左边字符出去，计数-1
                left++; // 4. 左指针右移
            }
            
            ret = max(ret, right - left + 1); // 5. 更新结果
            right++; // 6. 右指针右移
        }
        
        return ret;
    }
};
```

### 执行过程（s = "abcabcbb"）

| 步骤 | right | s[right] | hash[s[right]] | 窗口内容 | left | 窗口长度 | ret |
|------|-------|----------|----------------|----------|------|----------|-----|
| 1 | 0 | 'a' | 1 | "a" | 0 | 1 | 1 |
| 2 | 1 | 'b' | 1 | "ab" | 0 | 2 | 2 |
| 3 | 2 | 'c' | 1 | "abc" | 0 | 3 | **3** |
| 4 | 3 | 'a' | 2 → 收缩 | "abc" → "bca" | 0→1 | 3 | 3 |
| 5 | 4 | 'b' | 2 → 收缩 | "bca" → "cab" | 1→2 | 3 | 3 |
| 6 | 5 | 'c' | 2 → 收缩 | "cab" → "abc" | 2→3 | 3 | 3 |
| 7 | 6 | 'b' | 2 → 收缩 | "abc" → "cb" | 3→4 | 3 | 3 |
| 8 | 7 | 'b' | 2 → 收缩 | "cb" → "b" | 4→5 | 3 | 3 |

**最终答案：3**

---

**关键收获：**
1. 🎯 **索引 ≠ 值！记住公式：`数组名[索引] = 值`**
2. 🎯 **滑动窗口模板：进窗口 → 判断 → 出窗口 → 更新结果**
3. 🎯 **hash表的键是"字符"，不是"索引"！要用 `s[right]` 不是 `right`**
4. 🎯 **这是第2次犯"索引vs值"错误，以后写代码前先问自己：这里要的是索引还是值？**
总耗时：33min

---

### 第2题：找到字符串中所有字母异位词（LeetCode 438）⭐⭐⭐

**题目链接：** https://leetcode.cn/problems/find-all-anagrams-in-a-string/

**📚 讲解资源（卡住了看这里）：**
- ✅ **比特课程**：打开 `比特课程/算法精品课1.md`，找到这题的详细讲解
- ✅ **代码随想录**：有讲解
- ✅ **LeetCode题解**：看官方题解或高赞题解

**题目描述：**
给定两个字符串 s 和 p，找到 s 中所有 p 的异位词的子串，返回这些子串的起始索引。

**示例：**
```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

**思路提示：**
- **固定长度**的滑动窗口（长度 = p.length()）
- 用哈希表记录p中各字符的出现次数
- 窗口滑动时，比较窗口内字符频次是否匹配

**我的思路：**
/*对p进行hash统计出现字符个数，以及长度，它的长度决定了本题窗口的大小，这算是一个固定大小窗口的题目；然后在s中，进行正常滑动窗口操作，1.进窗口；2.判断；3.出窗口，更新结果本题在判断结束之后如果正确即更新*/

**我的代码：**
```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        /*对p进行hash统计出现字符个数，以及长度，它的长度决定了本题窗口的大小，这算是一个固定大小窗口的题目；然后在s中，进行正常滑动窗口操作，1.进窗口；2.判断；3.出窗口，更新结果本题在判断结束之后如果正确即更新*/
        unordered_map<char,int> o;//本串
        unordered_map<char,int> d;//目标串
        for(int i = 0 ; i < p.size() ; i++ )
        {
            o[p[i]]++;
        }
        int len = p.size();
        int left = 0 ,right = len - 1;
        vector<int> ret;
        while(right < s.size())
        {
            for(int j = left;j < right; j++)
            {
                d[s[j]]++;
            }
            if(d == o)//判断
            ret.push_back(left);//记录答案，更新结果
            d[s[left++]]--;//出窗口
            right++;
            d[s[right]]++;//进窗口
            
        }
        return ret;
    }
};
```

**提交结果：**
- ❌ 解答错误：18 / 65 个通过的测试用例
- 输入：s = "cbaebabacd", p = "abc"
- 输出：[]（错误）
- 预期：[0,6]

---

## ❌ 错误分析（3个严重bug）

### Bug 1：初始窗口没有统计完整（第18行）

```cpp
for(int j = left; j < right; j++)  // ❌ 错误！
{
    d[s[j]]++;
}
```

**问题：** `j < right` 导致 `s[right]` 没有被统计进去！

**示例：** s = "cba", p = "abc", left=0, right=2
- 你的代码统计：j=0,1 → 只统计了 'c','b'
- 正确应该：j=0,1,2 → 统计 'c','b','a'

**应该改成：**
```cpp
for(int j = left; j <= right; j++)  // ✅ 包含right
```

---

### Bug 2：每次都重新统计整个窗口（严重性能问题）

```cpp
while(right < s.size())
{
    for(int j = left; j < right; j++)  // ❌ 每次都重新统计！
    {
        d[s[j]]++;
    }
    // ...
}
```

**问题：** 滑动窗口的核心是**增量更新**，你这样每次都重新统计，失去了滑动窗口的意义！

**错误执行过程：**
```
第1次循环：统计 s[0~2] = "cba"
第2次循环：又统计 s[1~3] = "bae"
第3次循环：又统计 s[2~4] = "aeb"
```

**结果：** d 的值会累积，越加越多！

---

### Bug 3：窗口移动顺序错误

```cpp
if(d == o) ret.push_back(left);  // 判断
d[s[left++]]--;  // 出窗口
right++;         // 进窗口
d[s[right]]++;   
```

**问题：** 你在第一次循环时，d 还没有初始化完整！

---

## 🔍 详细追踪错误（s="cbaebabacd", p="abc"）

### 第1次循环：
```
left=0, right=2
内层循环：j=0,1 → d['c']=1, d['b']=1  // ❌ 漏掉了s[2]='a'
d = {'c':1, 'b':1}
o = {'a':1, 'b':1, 'c':1}
d == o? 否 → 不记录
出窗口：d['c']-- → d={'b':1}
进窗口：right=3, d['a']++ → d={'b':1, 'a':1}
```

### 第2次循环：
```
left=1, right=3
内层循环：j=1,2 → d['b']++, d['a']++  // ❌ 又统计了一遍！
现在 d = {'b':2, 'a':2}  // 累积错误！
```

**问题暴露：** d 的值一直在累加，永远不可能等于 o！

---

## ✅ 正确思路（固定窗口滑动）

### 步骤：
1. **先统计p的字符频次**
2. **初始化第一个完整窗口** [0, len-1]
3. **循环：判断 → 出窗口 → 进窗口**

### 正确代码：

```cpp
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if (s.size() < p.size()) return {};
        
        unordered_map<char, int> target; // 目标串p的字符频次
        unordered_map<char, int> window; // 当前窗口的字符频次
        
        // 1. 统计p的字符频次
        for (char c : p) {
            target[c]++;
        }
        
        int len = p.size();
        vector<int> ret;
        
        // 2. 初始化第一个窗口 [0, len-1]
        for (int i = 0; i < len; i++) {
            window[s[i]]++;
        }
        
        // 3. 判断第一个窗口
        if (window == target) {
            ret.push_back(0);
        }
        
        // 4. 滑动窗口
        for (int right = len; right < s.size(); right++) {
            int left = right - len;
            
            // 出窗口：移除 s[left]
            window[s[left]]--;
            if (window[s[left]] == 0) {// 如果移除后，该字符频次为0，则删除该字符
                window.erase(s[left]);
            }
            
            // 进窗口：加入 s[right]
            window[s[right]]++;
            
            // 判断当前窗口
            if (window == target) {
                ret.push_back(left + 1);
            }
        }
        
        return ret;
    }
};
```

---

## 🎯 执行过程（s="cbaebabacd", p="abc"）

**初始化：**
- target = {'a':1, 'b':1, 'c':1}
- 第一个窗口 [0,2] = "cba"
- window = {'c':1, 'b':1, 'a':1}
- window == target? ✅ → ret = [0]

**循环1：** right=3
- 出窗口：s[0]='c', window={'b':1, 'a':1}
- 进窗口：s[3]='a', window={'b':1, 'a':2}
- left=1, 窗口="bae", window != target

**循环2：** right=4
- 出窗口：s[1]='b', window={'a':2}
- 进窗口：s[4]='b', window={'a':2, 'b':1}
- left=2, 窗口="aeb", window != target

**...（跳过几步）...**

**循环6：** right=8
- 出窗口：s[5]='a', window={'b':1, 'c':1}
- 进窗口：s[8]='c', window={'b':1, 'c':2}
- left=6, 窗口="bac"
- window = {'b':1, 'a':1, 'c':1}
- window == target? ✅ → ret = [0, 6]

**最终答案：[0, 6]** ✅

---

**踩坑记录：**
1. ❌ **初始窗口统计不完整**：`j < right` 应该是 `j <= right`
2. ❌ **每次重新统计窗口**：违背滑动窗口增量更新原则，导致累积错误
3. ❌ **没有先初始化第一个窗口**：直接在循环里判断，第一个窗口不完整
4. 🎯 **固定窗口的正确流程**：先统计p → 初始化第一个窗口 → 循环（出窗口 → 进窗口 → 判断）

---

---

## 🤔 重要疑问解答

### 疑问1：为什么要判断 `window[s[left]] == 0` 才erase？必须erase吗？

```cpp
window[s[left]]--;              // 频次减1
if (window[s[left]] == 0) {     // 为什么要判断？必须erase吗？
    window.erase(s[left]);
}
```

**答案1：因为窗口中这个字符可能有多个！**
**答案2：必须erase！否则map比较会出错！**

---

#### 先回答第一个问题：为什么要判断？

**错误理解（不判断，直接erase）：**
```
窗口 = "abba", window = {'a':2, 'b':2}

出窗口：s[left]='a'
window['a']-- → window['a']=1
如果直接 erase('a') → window = {'b':2}  // ❌ 错误！

但实际上窗口中还有一个'a'（在右边）！
应该是 window = {'a':1, 'b':2}
```

**正确理解（判断后才erase）：**
```
窗口 = "abba", window = {'a':2, 'b':2}

出窗口：s[left]='a'
window['a']-- → window['a']=1
window['a'] == 0? 否 → 不erase
window = {'a':1, 'b':2}  // ✅ 正确！
```

---

#### 再回答第二个问题：为什么必须erase？不erase行不行？

**❌ 不erase会导致map比较错误！**

**具体例子：**

```cpp
// 目标
target = {'a':1, 'b':1, 'c':1}

// 情况1：正确erase
window = {'a':1, 'b':1, 'c':1}
window == target?  → true ✅

// 情况2：不erase，留着值为0的key
window = {'a':1, 'b':1, 'c':1, 'd':0}  // 'd'减到0但没删除
window == target?  → false ❌  // 错了！明明应该相等！
```

**为什么 `window == target` 会是false？**

因为C++的 `unordered_map` 比较规则是：
1. **key的数量必须相同**
2. **每个key对应的value必须相同**

```
target 有3个key：{'a', 'b', 'c'}
window 有4个key：{'a', 'b', 'c', 'd'}

key数量不同 → false！
```

**即使 'd' 的值是0，只要key存在，就算一个key！**

---

#### 完整追踪例子（s="cbaebabacd", p="abc"）

**错误做法（不erase）：**

```
初始窗口 [0,2] = "cba"
window = {'c':1, 'b':1, 'a':1}
target = {'a':1, 'b':1, 'c':1}
window == target? true ✅ → 记录0

滑动到 [1,3] = "bae"
出窗口：window['c']-- → window['c']=0（但不删除）
进窗口：window['a']++ → window['a']=2
window = {'c':0, 'b':1, 'a':2, 'e':1}  // 'c'还在，值为0
target = {'a':1, 'b':1, 'c':1}
window == target? false ❌  // 错了！因为key数量不同

继续滑动...所有后续比较都会错！
```

**正确做法（erase）：**

```
初始窗口 [0,2] = "cba"
window = {'c':1, 'b':1, 'a':1}
target = {'a':1, 'b':1, 'c':1}
window == target? true ✅ → 记录0

滑动到 [1,3] = "bae"
出窗口：window['c']-- → window['c']=0
        window['c']==0? 是 → erase('c')
进窗口：window['a']++ → window['a']=2
window = {'b':1, 'a':2, 'e':1}  // 'c'已删除
target = {'a':1, 'b':1, 'c':1}
window == target? false ✅  // 正确判断：确实不相等

...

滑动到 [6,8] = "bac"
window = {'b':1, 'a':1, 'c':1}  // 干净的map，没有多余的0值key
target = {'a':1, 'b':1, 'c':1}
window == target? true ✅ → 记录6
```

---

## 🎯 核心结论

### 问：`window[s[left]]--` 已经减1了，为什么还要erase？

**答：因为C++的map比较是比较"key的集合"，不只是比较value！**

```
{'a':1, 'b':1} == {'a':1, 'b':1}             → true  ✅
{'a':1, 'b':1} == {'a':1, 'b':1, 'c':0}     → false ❌
```

**即使value=0，key存在就算不同！**

---

### 是否可以不erase？

**理论上可以，但你要改判断方式：**

❌ 不能用：`window == target`
✅ 要手动比较：
```cpp
bool isEqual() {
    for (auto& [ch, cnt] : target) {
        if (window[ch] != cnt) return false;
    }
    for (auto& [ch, cnt] : window) {
        if (cnt > 0 && target.count(ch) == 0) return false;
    }
    return true;
}
```

**但这样太麻烦了！直接erase更简单高效！**

---

**总结：必须erase！否则map比较会因为多余的0值key而返回false！**

---

### 疑问2：为什么第2题是"先出后进"，第1题是"先进后出"？

**核心区别：固定窗口 vs 可变窗口**

#### 第1题（可变窗口）：
```cpp
while (right < n) {
    进窗口(right);      // 1. 先进
    right++;
    
    while (需要收缩) {   // 2. 判断是否需要出
        出窗口(left);    // 3. 需要才出
        left++;
    }
    
    更新结果;            // 4. 更新
}
```

**特点：**
- 窗口大小**动态变化**
- 右边界一直扩大
- 满足条件时才收缩左边界
- 判断在"进窗口"之后

---

#### 第2题（固定窗口）：
```cpp
// 先初始化第一个窗口 [0, len-1]

for (right = len; right < n; right++) {
    出窗口(left);       // 1. 先出（保持窗口大小）
    进窗口(right);      // 2. 后进（保持窗口大小）
    判断;               // 3. 判断当前窗口
    left++;             // 4. left也要移动
}
```

**特点：**
- 窗口大小**固定不变**（始终是 p.size()）
- 必须"先出后进"，保持窗口大小
- 每次都判断（因为窗口大小不变）

---

### 对比图解：

**第1题（可变窗口）：**
```
初始：[a b c] → right右移
     ↑       ↑
    left   right

扩大：[a b c a] → 发现'a'重复，需要收缩
     ↑         ↑
    left     right

收缩：  [b c a] → left右移，出窗口
         ↑     ↑
        left right
```

**第2题（固定窗口，len=3）：**
```
初始：[c b a] → 窗口大小=3
     ↑     ↑
    left right(2)

滑动：  [b a e] → 窗口大小=3（先出'c'，再进'e'）
         ↑     ↑
        left right(3)

滑动：    [a e b] → 窗口大小=3（先出'b'，再进'b'）
           ↑     ↑
          left right(4)
```

---

### 疑问3：判断顺序为什么不同？

**第1题：** 进窗口 → 判断 → 出窗口（如果需要）
- 因为窗口是**可变的**，进来后看看是否满足条件，不满足才出

**第2题：** 出窗口 → 进窗口 → 判断
- 因为窗口是**固定的**，必须先出再进保持大小，然后判断

---

## 🎯 两种滑动窗口模板总结

### 模板1：可变窗口（第1题）
```cpp
int left = 0;
while (right < n) {
    进窗口(right);
    right++;
    
    while (窗口不满足条件) {
        出窗口(left);
        left++;
    }
    
    更新结果;
}
```

### 模板2：固定窗口（第2题）
```cpp
// 1. 初始化第一个窗口
for (int i = 0; i < len; i++) {
    进窗口(i);
}
判断第一个窗口;

// 2. 滑动窗口
for (int right = len; right < n; right++) {
    int left = right - len;
    
    出窗口(left);
    进窗口(right);
    判断当前窗口;
}
```

---

**关键收获：**
1. 🎯 **erase要判断**：只有频次为0才erase，否则只减1（因为窗口中可能有多个相同字符）
2. 🎯 **固定窗口 vs 可变窗口**：
   - 可变窗口：while循环，先进后出（按需出），窗口大小动态变化
   - 固定窗口：for循环，先出后进（必须出），窗口大小固定
3. 🎯 **判断时机不同**：
   - 可变窗口：进窗口后判断，需要时才收缩
   - 固定窗口：出窗口+进窗口后判断，每次都判断
4. 🎯 **为什么顺序不同**：固定窗口必须保持大小，所以必须"先出后进"


---

### 第3题：最大连续1的个数III（LeetCode 1004）⭐⭐

**题目链接：** https://leetcode.cn/problems/max-consecutive-ones-iii/

**📚 讲解资源（卡住了看这里）：**
- ✅ **比特课程**：打开 `比特课程/算法精品课1.md`，找到这题的详细讲解
- ✅ **LeetCode题解**：看官方题解或高赞题解

**题目描述：**
给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回数组中连续 1 的最大个数。

**示例：**
```
输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释：[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
```

**思路提示：**
- 滑动窗口
- 用一个变量记录窗口内0的个数
- 当0的个数 > k 时，收缩左边界

**我的思路：**


**我的代码：**
```cpp

```

**提交结果：**
- 

**关键收获：**


---

### 第4题：三数之和（LeetCode 15）⭐⭐⭐⭐⭐

**题目链接：** https://leetcode.cn/problems/3sum/

**📚 讲解资源（卡住了看这里）：**
- ✅ **比特课程**：打开 `比特课程/算法精品课1.md`，找到这题的详细讲解
- ✅ **代码随想录**：B站搜索 "代码随想录 三数之和" 有视频（**重点推荐！**）
- ✅ **LeetCode题解**：看官方题解，重点看去重技巧

**题目描述：**
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。

请你返回所有和为 0 且不重复的三元组。

**注意：答案中不可以包含重复的三元组。**

**示例：**
```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

**关键难点：去重！**

**算法思路：**
1. 先排序
2. 固定第一个数 i，双指针找另外两个数（left = i+1, right = n-1）
3. **去重关键：**
   - i 遍历时跳过重复：`if (i > 0 && nums[i] == nums[i-1]) continue;`
   - 找到答案后，left和right也要跳过重复

**完整框架：**
```cpp
sort(nums.begin(), nums.end()); // 1. 先排序
vector<vector<int>> result;

for (int i = 0; i < n - 2; i++) {
    if (i > 0 && nums[i] == nums[i-1]) continue; // 2. 跳过重复的i
    
    int left = i + 1, right = n - 1;
    while (left < right) {
        int sum = nums[i] + nums[left] + nums[right];
        if (sum == 0) {
            result.push_back({nums[i], nums[left], nums[right]});
            
            // 3. 跳过重复的left和right
            while (left < right && nums[left] == nums[left+1]) left++;
            while (left < right && nums[right] == nums[right-1]) right--;
            
            left++; right--;
        }
        else if (sum < 0) left++;
        else right--;
    }
}
return result;
```

**我的思路：**


**我的代码：**
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int target = 0 ;
        vector<vector<int>> ret;
        for(int c = nums.size() -1 ; c >= 0 ; c--)
        {
            int left = 0 ;
            int right = c - 1;
            target = -c;
            while(left < right)
            {
                if((nums[left] + nums[right]) > target)
                right --;
                else if(nums[left] + nums[right] < target)
                left ++ ;
                else ret.push_back(nums[left],nums[right],nums[c]);
            }
        }
        return ret;
    }
};
```

**提交结果：**
- 编译错误


**踩坑记录：**

#### ❌ 错误1：`push_back` 语法错误
```cpp
ret.push_back(nums[left],nums[right],nums[c]);  // ❌ 错误！
```

**问题：**
- `push_back` 只接受**1个参数**，不能传3个！
- `vector<vector<int>>` 的 `push_back` 需要传入一个 `vector<int>`

**正确写法：**
```cpp
ret.push_back({nums[left], nums[right], nums[c]});  // ✅ 用花括号
//            ↑ 这是一个vector<int>，作为1个参数传入
```

---

#### ❌ 错误2：又是"索引vs值"！（今天第3次）
```cpp
target = -c;  // ❌ c是索引，不是值！
```

**问题：**
- `c` 是索引（0, 1, 2...）
- 我们需要的是 `nums[c]` 的值

**正确写法：**
```cpp
target = -nums[c];  // ✅ nums[c]才是数组中的值
```

**今天已经3次犯这个错误：**
1. 第1题：`hash[right]` 应该是 `hash[s[right]]`
2. 第3题（这里）：`target = -c` 应该是 `target = -nums[c]`

**⚠️ 重要提醒：索引vs值 - 每次用数组元素前问自己：我要的是索引还是值？**

---

#### ❌ 错误3：找到答案后死循环
```cpp
else ret.push_back({nums[left], nums[right], nums[c]});
// 找到答案了，但left和right都没动，下次循环还是这俩数，死循环！
```

**问题：**
- 找到一组答案后，`left` 和 `right` 都没移动
- 下次循环还是判断同样的两个数
- 导致死循环

**正确写法：**
```cpp
else {
    ret.push_back({nums[left], nums[right], nums[c]});
    left++;   // 移动指针
    right--;
}
```

---

#### ❌ 错误4：缺少去重逻辑
三数之和题目要求：**答案中不可以包含重复的三元组**

**例如：** `nums = [-1, -1, 2, 2]`
- 如果不去重，会找到多个 `[-1, -1, 2]`（重复了）

**需要跳过重复元素：**
1. 固定的数 `i` 要去重
2. 找到答案后，`left` 和 `right` 也要去重


**正确理解：**

#### ✅ 正确代码（基础版）
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());  // 排序是关键！
        vector<vector<int>> ret;
        int n = nums.size();
        
        // 固定第一个数 i
        for(int i = 0; i < n - 2; i++) {
            // 去重：跳过重复的 i
            if(i > 0 && nums[i] == nums[i-1]) continue;
            
            // 双指针找另外两个数
            int left = i + 1;
            int right = n - 1;
            int target = -nums[i];  // ✅ 是 nums[i] 不是 i
            
            while(left < right) {
                int sum = nums[left] + nums[right];
                
                if(sum < target) {
                    left++;
                } else if(sum > target) {
                    right--;
                } else {
                    // 找到答案
                    ret.push_back({nums[i], nums[left], nums[right]});  // ✅ 花括号
                    
                    // 去重：跳过重复的 left 和 right
                    while(left < right && nums[left] == nums[left+1]) left++;
                    while(left < right && nums[right] == nums[right-1]) right--;
                    
                    // 移动指针继续找
                    left++;
                    right--;
                }
            }
        }
        return ret;
    }
};
```

**核心思路：**
1. **排序**：`sort(nums.begin(), nums.end())`
2. **固定一个数 `i`**，问题转化为：在 `i` 右边找两个数，使得 `nums[left] + nums[right] = -nums[i]`
3. **双指针**：`left` 从 `i+1` 开始，`right` 从末尾开始
4. **去重**：
   - 固定数去重：`if(i > 0 && nums[i] == nums[i-1]) continue`
   - 找到答案后去重：跳过相同的 `left` 和 `right`

**时间复杂度：** O(n²)
- 外层循环 O(n)
- 内层双指针 O(n)
- 总共 O(n²)

---

#### 🚀 优化版本（提前剪枝）
```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> ret;
        int n = nums.size();
        if(n < 3) return ret;  // 优化1：数量不够直接返回
        
        sort(nums.begin(), nums.end());
        
        for(int i = 0; i < n - 2; i++) {
            // 优化2：如果最小的数都大于0，后面不可能有解
            if(nums[i] > 0) break;
            
            // 去重：跳过重复的 i
            if(i > 0 && nums[i] == nums[i-1]) continue;
            
            int left = i + 1;
            int right = n - 1;
            int target = -nums[i];
            
            while(left < right) {
                int sum = nums[left] + nums[right];
                
                if(sum < target) {
                    left++;
                } else if(sum > target) {
                    right--;
                } else {
                    ret.push_back({nums[i], nums[left], nums[right]});
                    
                    // 去重：跳过所有重复的left
                    while(left < right && nums[left] == nums[left+1]) left++;
                    // 去重：跳过所有重复的right
                    while(left < right && nums[right] == nums[right-1]) right--;
                    
                    left++;
                    right--;
                }
            }
        }
        return ret;
    }
};
```

**优化点：**
1. **提前判断数组长度**：`if(n < 3) return ret`
2. **剪枝**：如果 `nums[i] > 0`，因为数组已排序，后面都是正数，不可能有三数之和为0，直接 `break`


**关键收获：**

1. **`push_back` 语法：**
   - `vector<vector<int>>` 的 `push_back` 需要传入一个 `vector<int>`
   - 使用花括号 `{a, b, c}` 创建临时 `vector<int>`

2. **索引vs值（重点！）：**
   - **索引**：`i`、`left`、`right` 是数字（0, 1, 2...）
   - **值**：`nums[i]`、`nums[left]`、`nums[right]` 是数组中的实际元素
   - **口诀：用数组元素前先问：我要的是索引还是值？**

3. **双指针找到答案后必须移动指针：**
   - 否则会死循环
   - `left++; right--;`

4. **三数之和的去重三要素：**
   - 固定数去重：`if(i > 0 && nums[i] == nums[i-1]) continue`
   - left去重：`while(left < right && nums[left] == nums[left+1]) left++`
   - right去重：`while(left < right && nums[right] == nums[right-1]) right--`

5. **优化技巧：**
   - 排序后可以提前剪枝
   - `nums[i] > 0` 直接 `break`

---

#### 💡 补充：从右往左的思路（我的初始想法）

**我的初始代码是从右往左遍历的，这样可以吗？** ✅ **可以！**

**从右往左的核心调整：**

```cpp
// 从右往左遍历（我的思路）
for(int i = n - 1; i >= 2; i--) {  // ✅ 至少留2个位置给left和right
    // 剪枝：从右往左，如果最大数<0，后面更小，不可能有解
    if(nums[i] < 0) break;
    
    // 去重：从右往左，和右边比较（不是左边！）
    if(i < n - 1 && nums[i] == nums[i+1]) continue;
    //  ↑ 关键：i < n-1 防止越界
    //         nums[i] == nums[i+1] 和右边的数比较
    
    int left = 0;
    int right = i - 1;  // right在i的左边
    int target = -nums[i];
    
    // 后面的双指针逻辑一样
    while(left < right) { /* ... */ }
}
```

**关键区别对比：**

| | **从左往右（标准）** | **从右往左（我的思路）** |
|---|---|---|
| 循环条件 | `i < n - 2` | `i >= 2` |
| 固定数去重 | `nums[i] == nums[i-1]` | `nums[i] == nums[i+1]` |
| left/right | `left = i+1, right = n-1` | `left = 0, right = i-1` |
| 剪枝条件 | `nums[i] > 0 break` | `nums[i] < 0 break` |

**总结：**
- 从右往左完全可行，只要去重逻辑正确
- 关键是**去重和遍历方向一致**：从右往左就和右边比，从左往右就和左边比
- 推荐用从左往右（更常见，更符合常规思维）


---

### 第5题（可选）：字符串的排列（LeetCode 567）

**题目链接：** https://leetcode.cn/problems/permutation-in-string/

**📚 讲解资源（卡住了看这里）：**
- ✅ **代码随想录**：有讲解
- ✅ **LeetCode题解**：看官方题解或高赞题解

**题目描述：**
给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true；否则，返回 false。

**示例：**
```
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba")
```

**思路提示：**
- 和第2题类似，但只需要判断是否存在，不需要找所有位置
- 固定长度滑动窗口 + 字符频次比较

**我的思路：**


**我的代码：**
```cpp

```

**提交结果：**
- 

**关键收获：**


---

## 🌟 今日总结

### ✅ 完成情况
- [x] 无重复字符的最长子串 ⭐ - 已AC（索引vs值错误）
- [x] 找到字符串中所有字母异位词 - 已AC（初始化、重复统计、erase理解）
- [ ] 最大连续1的个数III
- [x] 三数之和 ⭐ - 已AC（语法、索引vs值、去重逻辑）
- [ ] 字符串的排列（可选）

**实际完成：** 3 题  
**用时：** 约3小时

### 💡 今日收获

1. **滑动窗口两大模板：**
   - 可变窗口：while(条件不满足) { 缩小窗口 }
   - 固定窗口：先建第一个窗口，然后每次"出一个进一个"

2. **索引vs值 - 今天犯了3次这个错误！**
   - 口诀：用数组元素前先问自己：我要的是索引还是值？
   - `i`/`left`/`right` 是索引
   - `nums[i]`/`s[right]` 是值

3. **`unordered_map` 的 erase 必要性：**
   - `map == map` 比较的是键的数量和值
   - 如果值为0的键不erase，会导致键数量不匹配

4. **三数之和的去重逻辑：**
   - 从右往左遍历：和右边比较 `nums[i] == nums[i+1]`
   - 从左往右遍历：和左边比较 `nums[i] == nums[i-1]`

5. **`push_back` 语法：**
   - `vector<vector<int>>` 需要传入一个 `vector<int>`
   - 用花括号：`ret.push_back({a, b, c})`

### 🐛 遇到的问题

1. **索引vs值混淆（3次）：**
   - 第1题：`hash[right]` → 应该是 `hash[s[right]]`
   - 第3题：`target = -c` → 应该是 `target = -nums[c]`
   - 容易在变量名和数组访问之间搞混

2. **固定窗口初始化错误：**
   - 初始化第一个窗口时漏掉了最后一个元素
   - 在主循环中重复统计整个窗口

3. **从右往左去重方向错误：**
   - 从右往左应该和 `nums[i+1]` 比，不是 `nums[i-1]`


### 📌 明日计划
- 继续滑动窗口或者开始新专题（链表）
- 保持每天4-5题的节奏

---

**今日状态：** 💪  
**学习原则：** 不纠结欠账，保持前进，享受进步！
