# Day31 - 10.31 动态规划入门

**日期**：2025年10月31日  
**主题**：动态规划基础 - 斐波那契模型  
**学习目标**：理解DP核心思想，掌握DP四步法

---

## 📋 今日计划

### 核心题目（斐波那契模型）
1. ⭐⭐ LeetCode 1137 - 第N个泰波那契数（Easy）
2. ⭐⭐⭐ LeetCode 70 - 爬楼梯（Easy）
3. ⭐⭐ LeetCode 746 - 使用最小花费爬楼梯（Easy）
4. LeetCode 509 - 斐波那契数（Easy）- 可选

---

## 💡 动态规划核心思想

### 什么是动态规划？

**三个关键特征**：
```
1. 大问题可以分解为小问题
2. 小问题的解可以推导大问题的解
3. 存在重复子问题（可以用数组存储结果）
```

**举例：爬楼梯**
```
问题：爬到第10阶有多少种方法？

分解：
- 爬到第10阶 = 从第9阶爬1步 + 从第8阶爬2步
- 爬到第9阶 = 从第8阶爬1步 + 从第7阶爬2步
- ...

重复子问题：
- 计算第10阶时需要第9阶和第8阶
- 计算第9阶时也需要第8阶
- 第8阶被重复计算了！
```

---

### DP四步法 ⭐⭐⭐

**每道DP题都按这四步思考**：

```
Step 1：状态表示
- dp[i] 表示什么？
- 明确问题的子问题是什么

Step 2：状态转移方程
- dp[i] 如何从前面的状态推导？
- 找到递推关系

Step 3：初始化
- dp[0] 或 dp[1] 等于多少？
- 哪些状态无法通过转移方程得到？

Step 4：填表顺序
- 从左往右？从右往左？
- 二维DP：从上到下？对角线？
```

---

### DP vs 递归

**递归（自顶向下）**：
```cpp
// 斐波那契数列 - 递归实现
int fib(int n) {
    if(n <= 1) return n;
    return fib(n-1) + fib(n-2);  // 重复计算！
}
// 时间复杂度：O(2^n) - 指数级
```

**动态规划（自底向上）**：
```cpp
// 斐波那契数列 - DP实现
int fib(int n) {
    if(n <= 1) return n;
    vector<int> dp(n+1);
    dp[0] = 0, dp[1] = 1;
    for(int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // 每个状态只计算一次
    }
    return dp[n];
}
// 时间复杂度：O(n)
```

**关键区别**：
- 递归：从大问题往小问题分解（自顶向下）
- DP：从小问题往大问题累积（自底向上）
- DP用数组存储中间结果，避免重复计算

---

## 1. LeetCode 1137 - 第N个泰波那契数

### 📌 题目信息
- **难度**：Easy
- **标签**：动态规划、记忆化搜索
- **链接**：[LeetCode 1137](https://leetcode.com/problems/n-th-tribonacci-number/)

---

### 📋 题目描述

泰波那契序列 Tn 定义如下：
- T₀ = 0, T₁ = 1, T₂ = 1
- Tₙ₊₃ = Tₙ + Tₙ₊₁ + Tₙ₊₂（n ≥ 0）

给你整数 n，请返回第 n 个泰波那契数 Tₙ 的值。

**示例 1**：
```
输入：n = 4
输出：4
解释：
T₃ = 0 + 1 + 1 = 2
T₄ = 1 + 1 + 2 = 4
```

**示例 2**：
```
输入：n = 25
输出：1389537
```

---

### 🤔 解题思路

**应用DP四步法**：

**Step 1：状态表示**
```
dp[i] 表示：第 i 个泰波那契数的值
```

**Step 2：状态转移方程**
```
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
```

**Step 3：初始化**
```
dp[0] = 0
dp[1] = 1
dp[2] = 1
```

**Step 4：填表顺序**
```
从左往右：i 从 3 到 n
```

---

### 💻 代码实现

#### **方法1：标准DP解法**

```cpp
class Solution {
public:
    int tribonacci(int n) {
        // DP四步法：
        // 1. 创建dp表
        // 2. 初始化
        // 3. 填表
        // 4. 返回值
        
        // 处理边界情况
        if(n == 0) return 0;
        if(n == 1 || n == 2) return 1;

        vector<int> dp(n+1);
        dp[0] = 0, dp[1] = dp[2] = 1;
        
        for(int i = 3; i <= n; i++)
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
            
        return dp[n]; 
    }
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

#### **方法2：空间优化解法** ⭐⭐⭐

```cpp
class Solution {
public:
    int tribonacci(int n) {
        // 空间优化：滚动变量
        
        // 处理边界情况
        if(n == 0) return 0;
        if(n == 1 || n == 2) return 1;

        int a = 0, b = 1, c = 1, d = 0;
        for(int i = 3; i <= n; i++) {
            d = a + b + c;
            // 滚动操作
            a = b;
            b = c;
            c = d;
        }
        return d; 
    }
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(1) ⭐ 从O(n)优化到O(1)

---

### 核心知识点

#### **DP空间优化技巧** ⭐⭐⭐

**观察**：
```cpp
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

关键发现：
- dp[i] 只依赖前3个状态
- 不需要保存所有n+1个状态
- 只需要保存最近的3个状态
```

**优化思路**：
```
原始：dp[0], dp[1], dp[2], ..., dp[n]  // 需要n+1个空间

优化：只用4个变量滚动
     a      b      c      d
    ↓      ↓      ↓      ↓
  dp[i-3] dp[i-2] dp[i-1] dp[i]

每次计算完d后：
a = b;  // a滚动到b的位置
b = c;  // b滚动到c的位置
c = d;  // c滚动到d的位置
```

**图解**：
```
i=3: a=0, b=1, c=1  →  d=0+1+1=2  →  a=1, b=1, c=2
i=4: a=1, b=1, c=2  →  d=1+1+2=4  →  a=1, b=2, c=4
i=5: a=1, b=2, c=4  →  d=1+2+4=7  →  a=2, b=4, c=7
...
```

**适用场景**：
```
当 dp[i] 只依赖前面固定的几个状态时，可以用滚动变量优化

典型例子：
- 斐波那契数列：dp[i] = dp[i-1] + dp[i-2]  →  2个变量
- 泰波那契数列：dp[i] = dp[i-1] + dp[i-2] + dp[i-3]  →  3个变量
- 爬楼梯：dp[i] = dp[i-1] + dp[i-2]  →  2个变量
```

---

### 提交结果
- 提交时间：一次AC ✅
- 执行用时：符合预期
- 内存消耗：方法1 O(n)，方法2 O(1)

---

## 2. 三步问题 - 爬楼梯变种

### 📌 题目信息
- **难度**：Easy
- **标签**：动态规划
- **类型**：爬楼梯变种（可以走1步、2步或3步）

---

### 📋 题目描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 **1步、2步 或 3步**。你有多少种不同的方法可以爬到楼顶呢？

**结果需要对 1e9+7 取模**

**示例**：
```
输入：n = 3
输出：4
解释：有4种方法可以爬到楼顶。
1. 1 + 1 + 1
2. 1 + 2
3. 2 + 1
4. 3
```

---

### 🤔 解题思路

**核心分析**：
```
要爬到第 i 阶，有三种方式：
1. 从第 i-1 阶爬 1 步
2. 从第 i-2 阶爬 2 步
3. 从第 i-3 阶爬 3 步

所以：dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
```

**与第1题的联系**：
```
第1题（泰波那契数列）：T(n) = T(n-1) + T(n-2) + T(n-3)
本题：dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

完全一样！区别只是初始化不同：
- 泰波那契：T(0)=0, T(1)=1, T(2)=1
- 本题：dp[1]=1, dp[2)=2, dp[3]=4
```

**DP四步法**：

**Step 1：状态表示**
```
dp[i] 表示：爬到第 i 阶的方法数
```

**Step 2：状态转移方程**
```
dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
```

**Step 3：初始化**
```
dp[1] = 1  （1种方法：爬1步）
dp[2] = 2  （2种方法：1+1 或 2）
dp[3] = 4  （4种方法：1+1+1, 1+2, 2+1, 3）
```

**Step 4：填表顺序**
```
从左往右：i 从 4 到 n
```

---

### 💻 代码实现

```cpp
class Solution {
public:
    int waysToStep(int n) {
        // DP四步法：
        // 1. 创建dp表
        // 2. 初始化
        // 3. 填表
        // 4. 返回值
        
        const int MOD = 1e9 + 7;
        
        // 处理边界条件
        if(n == 1 || n == 2) return n;
        if(n == 3) return 4;
        
        vector<int> dp(n + 1);
        dp[1] = 1, dp[2] = 2, dp[3] = 4;
        
        for(int i = 4; i <= n; i++)
            dp[i] = ((dp[i-1] + dp[i-2]) % MOD + dp[i-3]) % MOD;
        
        return dp[n]; 
    }
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

### 核心知识点

#### **1. 取模运算的注意事项** ⭐⭐⭐

**为什么要分两次取模？**
```cpp
// 方法1：先加再取模（可能溢出）
dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % MOD;  // 可能溢出

// 方法2：分步取模（推荐）✅
dp[i] = ((dp[i-1] + dp[i-2]) % MOD + dp[i-3]) % MOD;  // 安全
```

**原理**：
```
(a + b + c) % MOD = ((a + b) % MOD + c) % MOD

分步取模可以避免中间结果溢出
```

#### **2. 边界条件的处理**

本题有两种处理方式：

**方法1：提前返回（本题方法）**
```cpp
if(n == 1 || n == 2) return n;
if(n == 3) return 4;
```

**方法2：特殊初始化**
```cpp
vector<int> dp(n + 1);
if(n >= 1) dp[1] = 1;
if(n >= 2) dp[2] = 2;
if(n >= 3) dp[3] = 4;
```

两种方法都可以，方法1更简洁。

#### **3. 与泰波那契数列的对比**

| 特性 | 泰波那契数列 | 三步问题 |
|------|------------|---------|
| 状态转移 | `T(n) = T(n-1) + T(n-2) + T(n-3)` | `dp[i] = dp[i-1] + dp[i-2) + dp[i-3]` |
| 初始化 | `T(0)=0, T(1)=1, T(2)=1` | `dp[1]=1, dp[2]=2, dp[3]=4` |
| 是否取模 | ❌ | ✅ |

**本质**：两道题的递推关系完全相同，只是初始化不同。

---

### 提交结果
- 提交时间：一次AC ✅
- 执行用时：符合预期
- 内存消耗：O(n)

---

## 3. LeetCode 70 - 爬楼梯

### 📌 题目信息
- **难度**：Easy（但很经典！）
- **标签**：动态规划、数学
- **链接**：[LeetCode 70](https://leetcode.com/problems/climbing-stairs/)

---

### 📋 题目描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1**：
```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2**：
```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

---

### 🤔 解题思路

**核心分析**：
```
要爬到第 i 阶，有两种方式：
1. 从第 i-1 阶爬 1 步
2. 从第 i-2 阶爬 2 步

所以：爬到第 i 阶的方法数 = 爬到第 i-1 阶的方法数 + 爬到第 i-2 阶的方法数
```

**DP四步法**：

**Step 1：状态表示**
```
dp[i] 表示：爬到第 i 阶的方法数
```

**Step 2：状态转移方程**
```
dp[i] = dp[i-1] + dp[i-2]
```

**Step 3：初始化**
```
dp[1] = 1（只有1种方法：爬1步）
dp[2] = 2（2种方法：1+1 或 2）
```

**Step 4：填表顺序**
```
从左往右：i 从 3 到 n
```

**图解**：
```
n = 5 的过程：

i:     1   2   3   4   5
dp[i]: 1   2   3   5   8

推导：
dp[3] = dp[2] + dp[1] = 2 + 1 = 3
dp[4] = dp[3] + dp[2] = 3 + 2 = 5
dp[5] = dp[4] + dp[3] = 5 + 3 = 8
```

---

### 💻 代码实现

（自己先尝试实现，AC后再记录）

```cpp
// 你的代码






```

**时间复杂度**：  
**空间复杂度**：

---

### 提交结果
- 提交时间：
- 执行用时：
- 内存消耗：

---

## 3. LeetCode 746 - 使用最小花费爬楼梯

### 📌 题目信息
- **难度**：Easy
- **标签**：动态规划
- **链接**：[LeetCode 746](https://leetcode.com/problems/min-cost-climbing-stairs/)

---

### 📋 题目描述

给你一个整数数组 `cost`，其中 `cost[i]` 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1**：
```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2**：
```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

---

### 🤔 解题思路

**与爬楼梯的区别**：
```
爬楼梯：求方法数
本题：求最小花费（求最优）
```

**DP四步法**：

**Step 1：状态表示**
```
dp[i] 表示：爬到第 i 阶的最小花费
```

**Step 2：状态转移方程**
```
dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])

解释：
- 从第 i-1 阶爬1步，需要支付 cost[i-1]
- 从第 i-2 阶爬2步，需要支付 cost[i-2]
- 取最小值
```

**Step 3：初始化**
```
dp[0] = 0（可以从0开始，不需要花费）
dp[1] = 0（可以从1开始，不需要花费）
```

**Step 4：填表顺序**
```
从左往右：i 从 2 到 n
```

---

### 💻 代码实现

（自己先尝试实现，AC后再记录）

```cpp
// 你的代码






```

**时间复杂度**：  
**空间复杂度**：

---

### 提交结果
- 提交时间：
- 执行用时：
- 内存消耗：

---

## 今日总结

### 完成情况
- [x] LeetCode 1137 - 第N个泰波那契数 ✅
- [x] 三步问题 - 爬楼梯变种 ✅
- [ ] LeetCode 70 - 爬楼梯
- [ ] LeetCode 746 - 使用最小花费爬楼梯

### 核心知识点

#### **1. 动态规划三要素**

```
1. 最优子结构
   - 大问题的最优解包含小问题的最优解

2. 重叠子问题
   - 同一个子问题被重复计算多次

3. 无后效性
   - 当前状态只依赖前面的状态，不依赖后面的状态
```

---

#### **2. DP四步法（必须掌握）** ⭐⭐⭐

```
Step 1：状态表示 - dp[i] 表示什么？
Step 2：状态转移方程 - dp[i] 如何推导？
Step 3：初始化 - 哪些状态需要手动初始化？
Step 4：填表顺序 - 从哪个方向填表？
```

**应用示例**：
```
爬楼梯问题：
1. 状态：dp[i] = 爬到第i阶的方法数
2. 转移：dp[i] = dp[i-1] + dp[i-2]
3. 初始：dp[1] = 1, dp[2] = 2
4. 顺序：从左往右
```

---

#### **3. 斐波那契模型识别**

**特征**：
```
✓ 当前状态只依赖前面1-3个状态
✓ 状态转移是简单的加法或min/max
✓ 一维DP数组
```

**典型题目**：
```
- 斐波那契数列：dp[i] = dp[i-1] + dp[i-2]
- 泰波那契数列：dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
- 爬楼梯：dp[i] = dp[i-1] + dp[i-2]
- 最小花费爬楼梯：dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
```

---

#### **4. DP vs 递归**

| 特性 | 递归 | 动态规划 |
|------|------|----------|
| **方向** | 自顶向下 | 自底向上 |
| **重复计算** | 大量重复 | 避免重复 |
| **时间复杂度** | 指数级 O(2^n) | 线性/多项式 O(n) |
| **空间复杂度** | 递归栈 | DP数组 |
| **实现难度** | 简单直观 | 需要思考状态 |

---

### 收获与反思

#### **今日核心收获** 🎯

（AC后自己总结）

---

#### **易错点记录**

（遇到的坑记录在这里）

---

#### **下一步计划**

**明天学习**：
- [ ] Day32 - 打家劫舍系列（DP经典）
- [ ] 继续巩固DP四步法

---

---

**Day31学习完成时间**：  
**今日总用时**：  
**累计学习天数**：31天 🎉

---

