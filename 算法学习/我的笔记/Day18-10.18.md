# Day18 - 10.18 链表专题

## 今日目标

**主题：** 链表（Linked List）

**题目列表：**
1. LeetCode 2 - 两数相加（medium）
2. LeetCode 24 - 两两交换链表中的节点（medium）
3. LeetCode 143 - 重排链表（medium）
4. LeetCode 23 - 合并K个升序链表（hard）
5. LeetCode 25 - K个一组翻转链表（hard）

**预计用时：** 3-4小时

---

## 知识点梳理

### 链表基础

**链表节点定义：**
```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

### 链表常用技巧

#### 1. 虚拟头节点（Dummy Head）
- **作用：** 简化头节点的特殊处理
- **模板：**
```cpp
ListNode* dummy = new ListNode(0);
dummy->next = head;
// ... 操作
return dummy->next;
```

#### 2. 快慢指针（Fast-Slow Pointer）
- **作用：** 找中间节点、判断环
- **模板：**
```cpp
ListNode *slow = head, *fast = head;
while(fast && fast->next) {
    slow = slow->next;
    fast = fast->next->next;
}
// slow 指向中间节点
```

#### 3. 反转链表（头插法）
- **作用：** 反转链表或部分链表
- **模板：**
```cpp
ListNode* newHead = new ListNode(0);
ListNode* cur = head;
while(cur) {
    ListNode* next = cur->next;
    cur->next = newHead->next;
    newHead->next = cur;
    cur = next;
}
return newHead->next;
```

#### 4. 合并两个有序链表
- **作用：** 双指针合并
- **模板：**
```cpp
ListNode* dummy = new ListNode(0);
ListNode* prev = dummy;
while(l1 && l2) {
    if(l1->val <= l2->val) {
        prev->next = l1;
        l1 = l1->next;
    } else {
        prev->next = l2;
        l2 = l2->next;
    }
    prev = prev->next;
}
prev->next = l1 ? l1 : l2;
return dummy->next;
```

---

## 题目解析

### 1. 两数相加（LeetCode 2）⭐

**链接：** https://leetcode.cn/problems/add-two-numbers/

**题目描述：**

给你两个非空的链表，表示两个非负的整数。它们每位数字都是按照逆序的方式存储的，并且每个节点只能存储一位数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**
```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**
```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**
```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**提示：**
- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

**解题思路：**

<details>
<summary>点击查看思路提示</summary>

**核心思想：** 模拟加法运算

**关键点：**
1. 两个链表已经逆序存储，可以直接从头开始相加
2. 需要维护一个进位变量 `t`
3. 处理三种情况：
   - 链表1还有节点
   - 链表2还有节点
   - 还有进位
4. 用虚拟头节点简化操作

**步骤：**
1. 创建虚拟头节点和尾指针
2. 用 `while(cur1 || cur2 || t)` 循环
3. 依次加上链表1、链表2的值（如果存在）
4. 创建新节点：`new ListNode(t % 10)`
5. 更新进位：`t /= 10`
6. 返回 `dummy->next`

</details>

#### 我的思路

1. 创建虚拟头节点 `newhead` 和尾指针 `prev`
2. 用变量 `t` 记录进位
3. 循环条件：`cur1 || cur2 || t`（任意一个满足就继续）
4. 在循环中：
   - 先判断 `cur1` 是否存在，存在则加上 `cur1->val` 并移动
   - 再判断 `cur2` 是否存在，存在则加上 `cur2->val` 并移动
   - 创建新节点，值为 `t % 10`
   - 更新进位 `t /= 10`
5. 返回 `newhead->next`（跳过虚拟头节点）

#### 我的代码

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* newhead = new ListNode(0);
        ListNode* prev = newhead;
        int t = 0; // 记录进位变量
        ListNode* cur1 = l1;
        ListNode* cur2 = l2;
        
        while(cur1 || cur2 || t) // 只要还有链表或进位没处理完就循环不止
        {
            // 不能直接 t += cur1->val + cur2->val
            // 因为一个链表为空了那便是访问空指针了
            if(cur1) {
                t += cur1->val;
                cur1 = cur1->next;
            }
            if(cur2) {
                t += cur2->val;
                cur2 = cur2->next;
            }
            
            // 先创建节点（值为 t % 10）
            prev->next = new ListNode(t % 10);
            prev = prev->next;
            // 再更新进位
            t /= 10;
        }
        
        prev = newhead->next;
        delete newhead;
        return prev;
    }
};
```

#### 提交结果

- **状态：** ✅ Accepted
- **用时：** 约25分钟
- **时间复杂度：** O(max(m, n))
- **空间复杂度：** O(max(m, n))

#### 我的理解

**1. 为什么不能直接访问 `cur1->val`？**

因为在循环条件 `cur1 || cur2 || t` 中，只要有一个条件满足就会继续循环。如果 `cur1` 已经为空，但 `cur2` 还有节点，此时直接访问 `cur1->val` 会导致空指针访问错误。

**2. 为什么不能先 `t %= 10` 再 `t /= 10`？**

```cpp
// ❌ 错误写法
t %= 10;  // t 变成余数
t /= 10;  // 余数除以10永远是0！

// ✅ 正确写法
int current = t % 10;  // 先取出当前位
t /= 10;  // 再更新进位
```

假设 `t = 19`：
- 错误写法：`t %= 10` → `t = 9`，再 `t /= 10` → `t = 0`（进位丢失！）
- 正确写法：先用 `t % 10 = 9` 创建节点，再 `t /= 10 = 1`（保留进位）

**3. 虚拟头节点的作用？**

- 统一处理头节点，避免特殊判断
- 最后返回 `newhead->next` 即可
- 记得 `delete newhead` 释放内存

**4. 时间复杂度为什么是 O(max(m, n))？**

- 循环次数取决于较长的链表
- 每次循环做常数时间操作
- 最多多执行1次（最后的进位）

#### 易错点

<details>
<summary>点击查看易错点</summary>

1. **忘记处理进位：** 最后还有进位时需要新建节点
2. **循环条件错误：** 应该是 `cur1 || cur2 || t`，而不是 `&&`
3. **指针移动遗漏：** 忘记 `prev = prev->next`
4. **边界处理：** 两个链表长度不同

</details>

---

### 2. 两两交换链表中的节点（LeetCode 24）⭐

**链接：** https://leetcode.cn/problems/swap-nodes-in-pairs/

**题目描述：**

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**
```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**
```
输入：head = []
输出：[]
```

**示例 3：**
```
输入：head = [1]
输出：[1]
```

**提示：**
- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

**解题思路：**

<details>
<summary>点击查看思路提示</summary>

**核心思想：** 模拟交换

**关键点：**
1. **画图！** 这题最重要的是画图理解指针关系
2. 需要记录前一个节点 `prev`
3. 每次处理两个节点
4. 用虚拟头节点简化头节点处理

**交换过程：**
```
原始：prev -> node1 -> node2 -> next

步骤1：node1->next = node2->next
步骤2：node2->next = node1
步骤3：prev->next = node2

结果：prev -> node2 -> node1 -> next
```

**循环条件：** `cur && cur->next`（至少有两个节点）

</details>

#### 我的思路

1. 前置判断：如果链表为空或只有一个节点，直接返回
2. 创建虚拟头节点，初始化 `prev`、`cur`、`next`、`nnext` 四个指针
3. 循环条件：`cur && next`（至少有两个节点）
4. 在循环中交换相邻两个节点：
   - `prev->next = next`
   - `next->next = cur`
   - `cur->next = nnext`
5. 更新指针，并加上条件判断避免越界
6. 返回 `newhead->next`

#### 我的代码

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == nullptr || head->next == nullptr) return head;
        ListNode* newhead = new ListNode(0); 
        newhead->next = head;
        ListNode* prev = newhead;
        ListNode* cur = prev->next;
        ListNode* next = prev->next->next;
        ListNode* nnext = prev->next->next->next;  // 可能越界，需要前面判断
        
        while(cur && next)
        {
            prev->next = next;
            next->next = cur;
            cur->next = nnext;
            
            // 交换完之后更新指针
            prev = cur;
            cur = prev->next;
            if(cur) next = cur->next;
            if(next) nnext = next->next;
        }
        
        ListNode* result = newhead->next;
        delete newhead;
        return result;
    }
};
```

#### 提交结果

- **状态：** ✅ Accepted
- **用时：** 约15-20分钟
- **时间复杂度：** O(n)
- **空间复杂度：** O(1)

#### 我的理解

**1. 为什么需要前置判断？**

虽然后面有循环条件，但前置判断可以：
- 避免创建不必要的虚拟头节点
- 代码更清晰
- 性能略有提升

**2. 为什么 `nnext = prev->next->next->next` 可能越界？**

当链表只有2个节点时：
- `prev->next` → 第1个节点 ✅
- `prev->next->next` → 第2个节点 ✅
- `prev->next->next->next` → `nullptr` ✅（赋值没问题）

但如果没有前置判断，链表为空时就会出错。

**3. 为什么更新指针时需要条件判断？**

```cpp
cur = prev->next;
if(cur) next = cur->next;      // cur可能为nullptr
if(next) nnext = next->next;   // next可能为nullptr
```

这样避免了在循环内部访问空指针。

**4. 交换的指针顺序为什么重要？**

```
原始：prev -> cur -> next -> nnext

步骤1：prev->next = next      (prev跳过cur，指向next)
步骤2：next->next = cur       (next指向cur)
步骤3：cur->next = nnext      (cur指向nnext)

结果：prev -> next -> cur -> nnext
```

如果顺序错了，可能会丢失节点的引用！

#### 易错点

<details>
<summary>点击查看易错点</summary>

1. **指针顺序错误：** 必须先保存 `next`，再修改指针
2. **循环条件错误：** 应该是 `cur && cur->next`
3. **prev移动错误：** 交换后 `prev` 应该移动到 `node1`
4. **忘记画图：** 不画图很容易搞错指针关系

</details>

---

### 3. 重排链表（LeetCode 143）⭐⭐

**链接：** https://leetcode.cn/problems/reorder-list/

**题目描述：**

给定一个单链表 `L` 的头节点 `head`，单链表 `L` 表示为：

```
L(0) → L(1) → … → L(n - 1) → L(n)
```

请将其重新排列后变为：

```
L(0) → L(n) → L(1) → L(n - 1) → L(2) → L(n - 2) → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例 1：**
```
输入：head = [1,2,3,4]
输出：[1,4,2,3]
```

**示例 2：**
```
输入：head = [1,2,3,4,5]
输出：[1,5,2,4,3]
```

**提示：**
- 链表的长度范围为 `[1, 5 * 10^4]`
- `1 <= node.val <= 1000`

**解题思路：**

<details>
<summary>点击查看思路提示</summary>

**核心思想：** 三步骤

**关键点：**
1. **找中间节点** - 快慢指针
2. **反转后半部分** - 头插法
3. **合并两个链表** - 双指针

**为什么这样做？**
- 链表不能像数组一样随机访问
- 要交叉访问，需要把后半部分反转后再合并

**步骤详解：**

**Step 1: 找中间节点**
```
快慢指针，slow 最终停在中间
奇数个节点：slow 停在中间
偶数个节点：slow 停在前半部分最后
```

**Step 2: 反转后半部分**
```
用头插法反转 slow->next 开始的链表
记得断开：slow->next = nullptr
```

**Step 3: 合并两个链表**
```
交替取节点：先取前半部分，再取后半部分
```

</details>

#### 我的代码

```cpp
// 在这里写你的代码


```

#### 提交结果

- **状态：** 
- **用时：** 
- **内存：** 

#### 易错点

<details>
<summary>点击查看易错点</summary>

1. **slow的落点：** 要画图确认 slow 停在哪里
2. **忘记断开：** `slow->next = nullptr` 必须写
3. **合并顺序：** 先取第一个链表，再取第二个链表
4. **边界处理：** 第二个链表可能先结束

</details>

---

### 4. 合并K个升序链表（LeetCode 23）⭐⭐⭐

**链接：** https://leetcode.cn/problems/merge-k-sorted-lists/

**题目描述：**

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**
```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**
```
输入：lists = []
输出：[]
```

**示例 3：**
```
输入：lists = [[]]
输出：[]
```

**提示：**
- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按升序排列
- `lists[i].length` 的总和不超过 `10^4`

**解题思路：**

<details>
<summary>点击查看思路提示</summary>

**方法1：优先队列（小根堆）**

**核心思想：** 每次从 K 个链表中选最小的头节点

**关键点：**
1. 创建小根堆
2. 把所有头节点放入堆
3. 每次取堆顶（最小值）
4. 如果该节点有 next，把 next 放入堆

**时间复杂度：** O(N log K)，N 是总节点数，K 是链表数

---

**方法2：分治（递归）**

**核心思想：** 两两合并，类似归并排序

**关键点：**
1. 递归地平分链表数组
2. 左右两部分分别合并
3. 最后合并两个有序链表

**时间复杂度：** O(N log K)

**为什么分治更优？**
```
逐一合并：(0, 100), (100, 100), (200, 100), ... → 总长度 3600
分治合并：(100, 100) x 4, (200, 200) x 2, (400, 400) → 总长度 2400
```

</details>

#### 我的代码 - 方法1（堆）

```cpp
// 在这里写你的代码


```

#### 我的代码 - 方法2（分治）

```cpp
// 在这里写你的代码


```

#### 提交结果

- **状态：** 
- **用时：** 
- **内存：** 

#### 易错点

<details>
<summary>点击查看易错点</summary>

**方法1（堆）：**
1. **自定义比较器：** 小根堆需要 `return l1->val > l2->val`
2. **空链表处理：** `if(l) heap.push(l)` 要判空
3. **忘记push next：** `if(t->next) heap.push(t->next)`

**方法2（分治）：**
1. **递归出口：** `left > right` 返回 nullptr，`left == right` 返回 `lists[left]`
2. **合并两个有序链表：** 要正确实现
3. **mid计算：** `int mid = (left + right) >> 1`

</details>

---

### 5. K个一组翻转链表（LeetCode 25）⭐⭐⭐

**链接：** https://leetcode.cn/problems/reverse-nodes-in-k-group/

**题目描述：**

给你链表的头节点 `head`，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

**示例 1：**
```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**
```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

**提示：**
- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

**进阶：** 你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？

**解题思路：**

<details>
<summary>点击查看思路提示</summary>

**核心思想：** 分组反转

**关键点：**
1. 先计算总共需要反转多少组：`n = length / k`
2. 重复 n 次，每次反转 k 个节点
3. 需要记录：
   - 当前组的起点
   - 当前组的终点
   - 反转后的头尾节点
4. 把反转后的组连接回原链表

**步骤：**
1. 创建虚拟头节点
2. `prev` 指向待反转部分的前一个节点
3. 循环 n 次：
   - 找到当前组的起点和终点
   - 反转当前组
   - 连接前后
   - 移动 `prev`

**难点：** 指针关系复杂，需要仔细画图

</details>

#### 我的代码

```cpp
// 在这里写你的代码


```

#### 提交结果

- **状态：** 
- **用时：** 
- **内存：** 

#### 易错点

<details>
<summary>点击查看易错点</summary>

1. **计算组数：** `n = length / k`，不是 `length`
2. **找终点：** 需要循环 k-1 次
3. **断开连接：** 反转前要断开当前组和后续节点
4. **连接前后：** 反转后要正确连接
5. **移动prev：** `prev` 应该移动到当前组反转后的尾节点

</details>

---

## 今日总结

### 完成情况

- [ ] LeetCode 2 - 两数相加
- [ ] LeetCode 24 - 两两交换链表中的节点
- [ ] LeetCode 143 - 重排链表
- [ ] LeetCode 23 - 合并K个升序链表
- [ ] LeetCode 25 - K个一组翻转链表

### 时间统计

| 题目 | 用时 | 一次AC？ |
|------|------|---------|
| 两数相加 | | |
| 两两交换链表中的节点 | | |
| 重排链表 | | |
| 合并K个升序链表 | | |
| K个一组翻转链表 | | |
| **总计** | | |

### 核心收获

（做完题目后填写）

### 易错点总结

（做完题目后填写）

---

## 链表技巧总结

### 1. 虚拟头节点
- **适用场景：** 头节点可能改变
- **优点：** 统一处理，避免特判

### 2. 快慢指针
- **适用场景：** 找中间节点、判断环
- **快指针：** `fast = fast->next->next`
- **慢指针：** `slow = slow->next`

### 3. 头插法反转
- **适用场景：** 反转链表
- **关键：** 先保存 next，再修改指针

### 4. 画图
- **重要性：** ⭐⭐⭐⭐⭐
- **链表题必须画图！** 不画图很容易搞错指针关系

### 5. 边界处理
- **空链表：** `head == nullptr`
- **单节点：** `head->next == nullptr`
- **两节点：** `head->next->next == nullptr`

---

## 下一步计划

- 继续下一个专题
- 复习链表的经典题目

---

**记录时间：** 2024年10月18日

