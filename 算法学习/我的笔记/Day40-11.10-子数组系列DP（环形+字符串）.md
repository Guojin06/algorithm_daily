# Day40 - 子数组系列DP（环形+字符串）

**日期**：2025年11月10日  
**学习重点**：环形子数组DP、字符串子数组DP

---

## 📋 今日计划

### 子数组系列DP进阶
- [ ] 环形子数组最大和（环形DP）⭐
- [ ] 单词拆分（字符串DP）
- [ ] 环绕字符串中唯一的子字符串（字符串DP）

---

## 🎯 学习目标

1. 掌握环形数组问题的处理技巧
2. 理解字符串DP的状态设计
3. 学习如何将环形问题转化为线性问题

---

## 📝 题目记录

### 题目1：环形子数组最大和 ⭐

**题目链接**：[LeetCode 918 - 环形子数组最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)

**核心思路**：
- 分别考虑“未跨界”和“跨界”两种情况：未跨界就是经典最大子数组和；跨界相当于总和减去一段最小子数组和。
- 同时维护以当前位置结尾的最大子数组和`f[i]`与最小子数组和`g[i]`，累计数组元素总和。
- 当数组全为负数时会出现`sum == minSubArray`，此时只能取`fmax`（即最大单个元素），不能用`sum - minSubArray`。

**AC代码**：

```cpp
class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int n = nums.size();
        vector<int> f(n + 1), g(n + 1); // f: 最大子数组和, g: 最小子数组和
        int fmax = INT_MIN, gmin = INT_MAX, sum = 0;
        for(int i = 1; i <= n; i++) {
            int x = nums[i - 1];
            f[i] = max(x, x + f[i - 1]);
            fmax = max(fmax, f[i]);
            g[i] = min(x, x + g[i - 1]);
            gmin = min(gmin, g[i]);
            sum += x;
        }
        return sum == gmin ? fmax : max(fmax, sum - gmin);
    }
};
```

---

### 题目2：单词拆分

**题目链接**：[LeetCode 139 - 单词拆分](https://leetcode.cn/problems/word-break/)

**核心思路**：
- 典型字符串DP，定义`dp[i]`表示前`i`个字符是否可拆分。
- 枚举末尾位置`i`，向前寻找`j`，保证前缀`[0, j-1]`能拆分且后缀`[j, i]`在字典中。
- 使用`unordered_set`存字典，`dp[0]=true`作为虚拟起点，保证第一次匹配成功。

**AC代码**：

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> hash(wordDict.begin(), wordDict.end());
        int n = s.size();
        vector<bool> dp(n + 1);
        dp[0] = true;              // 虚拟起点
        s = ' ' + s;               // 下标统一成1开始
        for(int i = 1; i <= n; i++) {
            for(int j = i; j >= 1; j--) {
                if(dp[j - 1] && hash.count(s.substr(j, i - j + 1))) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
};
```

---

### 题目3：环绕字符串中唯一的子字符串

**题目链接**：[LeetCode 467 - 环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)

**核心思路**：

**AC代码**：

```cpp

```

---

## 💡 今日总结

### 核心收获

1. **环形DP**：枚举边界情况或转化为线性问题
2. **字符串DP**：利用哈希表优化查找效率
3. **状态设计**：根据问题特点设计合适的状态

### 关键技巧

- 环形问题：分类讨论（不跨越边界 vs 跨越边界）
- 字符串DP：用`unordered_set`存储字典，O(1)查找
- 子串问题：注意"以i结尾"的状态定义

---

*笔记格式：简洁记录核心思路和AC代码*  
*Cursor Write It-qcf*

