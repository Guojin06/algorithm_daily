# Day14 - 10月15日学习笔记

## 📚 今日专题：模拟算法

### 🎯 学习目标
- 掌握模拟算法的核心思想：按题目描述直接实现
- 完成5道经典模拟题目
- 重点关注边界处理和细节实现

### 📝 专题理论

**模拟算法特点：**
1. **直观性**：按照题目描述的逻辑直接编码
2. **细节性**：重点在于处理各种边界情况
3. **实现性**：考验代码实现能力而非算法技巧

**常见模拟类型：**
- 字符串处理模拟
- 数组操作模拟  
- 状态转换模拟
- 游戏规则模拟

---

## 🔥 刷题记录

### 题目1：替换所有的问号 (LeetCode 1576)

**题目描述：**
给你一个仅包含小写英文字母和 '?' 的字符串 s，请你将所有的 '?' 转换为某些小写字母，使得最终的字符串不包含任何连续重复的字符。

**示例：**
- 输入：s = "?zs"
- 输出："azs"
- 解释：该示例共有 25 种解决方案，从 "azs" 到 "yzs" 都是符合题目要求的。只需要确保任意相邻位置不出现相同字符即可。

**我的思路：**
遍历字符串，遇到'?'就尝试用'a'到'z'的字母替换，找到第一个不与前后字符相同的字母即可。需要注意边界条件的处理。

**我的代码（第一次）：**
```cpp
class Solution {
public:
    string modifyString(string s) {
        int n = s.size();
        for(int i = 0; i < n; i++) {
            if(s[i] == '?') {
                for(int ch = 'a'; ch <= 'z'; ch++) {
                    if((i = 0 || ch != s[i-1]) && ((i == n-1) || ch != s[i+1])) {
                        s[i] = ch;
                        break;
                    }
                }
            }
        }
        return s;
    }
};
```

**错误分析：**
第一次提交Runtime Error！错误信息显示数组越界。仔细检查发现是经典的 `i = 0` vs `i == 0` 错误：
- `i = 0` 是赋值操作，把i改成了0，然后访问 `s[i-1]` 就是 `s[-1]`，导致越界
- 应该用 `i == 0` 进行比较判断

**AC代码：**
```cpp
class Solution {
public:
    string modifyString(string s) {
        int n = s.size();
        for(int i = 0; i < n; i++) {
            if(s[i] == '?') {
                for(int ch = 'a'; ch <= 'z'; ch++) {
                    if((i == 0 || ch != s[i-1]) && ((i == n-1) || ch != s[i+1])) {
                        s[i] = ch;
                        break;
                    }
                }
            }
        }
        return s;
    }
};
```

**提交结果：** ✅ AC
**耗时：** 20分钟（包含调试时间）
**关键理解：** 
1. 贪心策略：每次选择第一个可用字母即可
2. 边界检查：访问 `s[i-1]` 前确保 `i > 0`，访问 `s[i+1]` 前确保 `i < n-1`
3. 经典错误：`=` vs `==` 的区别，赋值会改变变量值并可能导致越界 

---

### 题目2：提莫攻击 (LeetCode 495)

**题目描述：**
在《英雄联盟》的世界中，有一个叫 "提莫" 的英雄。他的攻击可以让敌方英雄艾希进入中毒状态。当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。

给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在第 timeSeries[i] 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 duration 。

返回艾希处于中毒状态的总秒数。

**示例：**
- 输入：timeSeries = [1,4], duration = 2
- 输出：4
- 解释：提莫攻击对艾希的影响如下：
  - 第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。
  - 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。
  - 艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。

**我的思路：**


**我的代码：**
class Solution {
public:
    int findPoisonedDuration(vector<int>& timeSeries, int duration) {
        int ret = 0;
        for(int i = 1 ; i < timeSeries.size(); i++)
        {
            if((timeSeries[i] - timeSeries[i-1]) > duration) ret += duration;
            else ret += (timeSeries[i] - timeSeries[i-1]);
        }
        return ret + duration;
    }
};

**提交结果：** ✅ AC
**耗时：** 17分钟
**关键理解：** 
1. **时间区间重叠处理**：关键在于比较相邻两次攻击的时间间隔与duration的大小
2. **两种遍历思路**：
   - 向后看：`for(i=1; i<n; i++)` 计算 `timeSeries[i] - timeSeries[i-1]`
   - 向前看：`for(i=0; i<n-1; i++)` 计算 `timeSeries[i+1] - timeSeries[i]`
   - 两种方法等价，都需要最后单独处理最后一次攻击的完整duration
3. **边界处理**：无论哪种写法，最后一次攻击都要加上完整的duration时间 

---

### 题目3：Z字形变换 (LeetCode 6) ⭐⭐⭐

**题目描述：**
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：
```
P   A   H   R
A P L S I I G
Y   I   N
```
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

**我的思路：**
使用二维数组直接模拟Z字形填充过程：
1. 创建 `numRows × n` 的二维字符数组，空位用空格填充
2. 用 `goingDown` 标记控制移动方向（向下或斜向上）
3. 遍历字符串，按照Z字形规律填充到二维数组中
4. 最后按行遍历二维数组，跳过空格，拼接结果

**我的代码：**
```cpp
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows == 1) return s;  // 特殊情况：只有1行时直接返回
        
        vector<vector<char>> ret(numRows, vector<char>(s.size(), ' '));
        int row = 0, col = 0;
        bool goingDown = true;
        
        for(char c : s) {
            ret[row][col] = c;
            
            // 判断是否需要切换方向（移动前判断，避免越界后回退）
            if(row == 0) {
                goingDown = true;
            } 
            else if(row == numRows - 1) {
                goingDown = false;
            }
            
            // 根据方向移动位置
            if(goingDown) {
                row++;  // 向下走：行+1，列不变
            } else {
                row--;  // 斜向上走：行-1，列+1
                col++;
            }
        }
        
        // 按行遍历二维数组，拼接非空字符
        string result = "";
        for(int i = 0; i < numRows; i++) {
            for(int j = 0; j < s.size(); j++) {
                if(ret[i][j] != ' ') {
                    result += ret[i][j];
                }
            }
        }
        
        return result;
    }
};
```

**提交结果：** ✅ AC
**耗时：** 约35分钟（包含思考和调试）

**优化解法（找规律）：**
```cpp
class Solution {
public:
    string convert(string s, int numRows) {
        if(numRows == 1) return s;
        
        string ret;
        int d = 2 * numRows - 2;  // 周期：每个完整Z字的字符数
        int n = s.size();
        
        // 1. 处理第一行：下标为 0, d, 2d, 3d, ...
        for(int i = 0; i < n; i += d)
            ret += s[i];
        
        // 2. 处理中间行：每行有两个规律的下标
        for(int k = 1; k < numRows - 1; k++) {
            for(int i = k, j = d - k; i < n || j < n; i += d, j += d) {
                if(i < n) ret += s[i];
                if(j < n) ret += s[j];
            }
        }
        
        // 3. 处理最后一行：下标为 numRows-1, numRows-1+d, ...
        for(int i = numRows - 1; i < n; i += d)
            ret += s[i];
        
        return ret;
    }
};
```

**关键理解：** 
1. **模拟解法（二维数组）**：
   - 空间复杂度 O(n×numRows)，逻辑直观
   - 适合理解Z字形的填充过程
   - 方向切换时机：移动前判断避免越界
   
2. **优化解法（找规律）**：
   - 空间复杂度 O(1)，直接按行输出
   - 核心：找到每行字符在原串中的下标规律
   - **周期 d = 2×numRows - 2**：每个完整Z字包含的字符数
   - **第一行**：下标为 0, d, 2d, 3d, ...
   - **中间第k行**：有两组下标
     - 竖线上的：k, k+d, k+2d, ...
     - 斜线上的：d-k, d-k+d, d-k+2d, ...
   - **最后一行**：下标为 numRows-1, numRows-1+d, ...
   
3. **两种解法对比**：
   - 模拟法：易于理解和实现，适合初学
   - 规律法：需要观察和推导，但效率更高 

---

### 题目4：外观数列 (LeetCode 38)

**题目描述：**
给定一个正整数 n ，输出外观数列的第 n 项。

外观数列是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

前五项如下：
1. 1
2. 11
3. 21
4. 1211
5. 111221

第一项是数字 1
描述前一项，这个数是 1 即 " 一 个 1 "，记作 "11"
描述前一项，这个数是 11 即 " 二 个 1 " ，记作 "21"
描述前一项，这个数是 21 即 " 一 个 2 + 一 个 1 " ，记作 "1211"
描述前一项，这个数是 1211 即 " 一 个 1 + 一 个 2 + 二 个 1 " ，记作 "111221"

**我的思路：**
从 "1" 开始，每次对当前字符串进行"读数"描述，生成下一项。用双指针统计连续相同字符的个数。

**我的代码：**
```cpp
class Solution {
public:
    string countAndSay(int n) {
        string ret = "1";
        for(int i = 1; i < n; i++) {  // 描述n-1次
            string tmp;  // 临时存储对ret的描述，必须在循环内定义保证每次清空
            int len = ret.size();
            for(int left = 0, right = 0; right < len;) {
                // right向右扫描，找到第一个不同的字符
                while(right < len && ret[left] == ret[right]) 
                    right++;
                // 统计：right-left个ret[left]
                tmp += to_string(right - left) + ret[left];
                // left跳到right，继续处理下一段
                left = right;
            }
            ret = tmp;  // 更新ret为新的描述
        }
        return ret;
    }
};
```

**执行过程示例（n=4）：**
```
初始: ret = "1"

第1次描述 "1":
  "1" → 1个'1' → tmp = "11"
  ret = "11"

第2次描述 "11":
  "11" → 2个'1' → tmp = "21"
  ret = "21"

第3次描述 "21":
  "21" → 1个'2' + 1个'1' → tmp = "12" + "11" = "1211"
  ret = "1211"

返回: "1211"
```

**提交结果：** ✅ AC
**耗时：** 约20分钟
**关键理解：** 
1. **双指针统计**：`left` 指向连续段起点，`right` 向右扫描找到第一个不同字符
   - 连续段长度：`right - left`
   - 连续段字符：`ret[left]`
2. **tmp的作用**：每次循环都要对新的 `ret` 进行描述，所以 `tmp` 必须在循环内定义（或手动清空），保证每次都是空的
3. **迭代过程**：`ret` 存储当前结果，`tmp` 存储对 `ret` 的描述，描述完成后 `ret = tmp`
4. **循环次数**：要得到第n项，只需描述n-1次（初始已有第1项 "1"）
5. **时间复杂度分析**：
   - 外层循环：O(n)
   - 内层循环：遍历当前字符串，长度记为 L
   - 字符串长度增长：每次描述后，字符串长度大约翻倍（最坏情况）
   - 总时间复杂度：O(n × L)，其中 L 是第n项的字符串长度
   - 由于 L 随 n 指数增长，实际复杂度约为 O(2^n) 

---

### 题目5：数青蛙 (LeetCode 1419) ⭐⭐

**题目描述：**
给你一个字符串 croakOfFrogs，它表示不同青蛙发出的蛙鸣声（字符串 "croak" ）的组合。由于同一时间可以有多只青蛙在呱呱作响，所以 croakOfFrogs 中会混合多个 "croak" 。

请你返回模拟字符串 croakOfFrogs 所需不同青蛙的最少数目。

要想发出蛙鸣声，青蛙必须 依序 输出 'c', 'r', 'o', 'a', 'k' 这 5 个字母。如果没有输出全部五个字母，那么它就不会发出声音。如果字符串 croakOfFrogs 不是由若干有效的 "croak" 字符串组合而成，请返回 -1 。

**示例：**
- 输入：croakOfFrogs = "croakcroak"
- 输出：1 
- 解释：一只青蛙 "呱呱" 两次

**我的思路：**
用状态机思想，记录处于每个状态的青蛙数量。每只青蛙按顺序发出 'c'→'r'→'o'→'a'→'k'，叫完可以复用。

**我的代码（第一次，编译错误）：**
```cpp
class Solution {
public:
    int minNumberOfFrogs(string croakOfFrogs) {
        unordered_map hash{'c','r','o','a','k'};  // ❌ 语法错误
        if (croakOfFrogs[0] != 'c') return -1;
        else hash[c]++;
        int cur = 0;
        for(int i = 1; i < croakOfFrogs.size(); i++) {
            cur = croakOfFrogs[i];
            if(cur != 'c') {
                if((cur == 'r') && hash[c] != 0) {hash[c]--;hash[cur]++;}
                else if((cur == 'o') && hash[r] != 0) {hash[r]--;hash[cur]++;} 
                else if((cur == 'a') && hash[o] != 0) {hash[o]--;hash[cur]++;} 
                else if((cur == 'k') && hash[a] != 0) {hash[a]--;hash[cur]++;}
                else return -1; 
            } else {
                if(hash[k] != 0) {hash[k]--;hash[cur]++}
                else hash[cur]++;
            }
        }
        return hash[k] == 0 ? -1 : hash[k];
    }
};
```

**错误分析：**
1. **unordered_map定义错误**：`unordered_map` 需要指定键值对类型 `<char, int>`，不能直接用初始化列表
2. **变量名冲突**：如果用 `c, r, o, a, k` 作为变量名，就不能同时用字符 `'c'` 索引哈希表
3. **逻辑问题**：
   - 没有统计"同时存在的青蛙数"的最大值
   - 遇到'k'时应该让青蛙变为空闲状态，可以被复用
   - 最后应该检查所有青蛙是否都完成了完整的叫声

**修正后的代码（基于我的原始逻辑）：**
```cpp
class Solution {
public:
    int minNumberOfFrogs(string croakOfFrogs) {
        // 方案1：用简单变量代替unordered_map
        int cnt_c = 0, cnt_r = 0, cnt_o = 0, cnt_a = 0, cnt_k = 0;
        
        if (croakOfFrogs[0] != 'c') return -1;
        cnt_c++;
        
        int maxFrogs = 1;  // 记录最大青蛙数
        
        for(int i = 1; i < croakOfFrogs.size(); i++) {
            char cur = croakOfFrogs[i];
            
            if(cur != 'c') {  // 如果是r,o,a,k，找前驱字符
                if((cur == 'r') && cnt_c != 0) {cnt_c--; cnt_r++;}
                else if((cur == 'o') && cnt_r != 0) {cnt_r--; cnt_o++;} 
                else if((cur == 'a') && cnt_o != 0) {cnt_o--; cnt_a++;} 
                else if((cur == 'k') && cnt_a != 0) {cnt_a--; cnt_k++;}
                else return -1; 
            } 
            else {  // cur为'c'
                // 如果有完成的青蛙(cnt_k>0)，复用它；否则增加新青蛙
                if(cnt_k != 0) {
                    cnt_k--;
                    cnt_c++;
                } else {
                    cnt_c++;
                }
            }
            
            // 统计当前正在叫的青蛙数
            int current = cnt_c + cnt_r + cnt_o + cnt_a;
            maxFrogs = max(maxFrogs, current);
        }
        
        // 检查是否所有青蛙都完成了
        return (cnt_c == 0 && cnt_r == 0 && cnt_o == 0 && cnt_a == 0) ? maxFrogs : -1;
    }
};
```

**提交结果：** ✅ AC
**耗时：** 约30分钟
**关键理解：** 
1. **状态机思想**：每只青蛙按顺序经历 `空闲 → c → r → o → a → k → 空闲`
2. **青蛙复用**：叫完'k'的青蛙变为空闲，遇到新的'c'时优先复用
3. **统计技巧**：
   - `cnt_c + cnt_r + cnt_o + cnt_a`：当前**正在叫**的青蛙数（占用中）
   - `cnt_k`：已完成、空闲的青蛙（可复用，不计入当前占用）
   - `maxFrogs`：记录同一时刻最多有几只青蛙在叫（即答案）
4. **为什么不直接返回cnt_k？**
   - 例如 "croakcroak"：1只青蛙叫两次，cnt_k=1 ✅
   - 例如 "crcoakroak"：2只青蛙交错叫，maxFrogs=2，但最后cnt_k可能=1
   - 题目求的是"同时最多需要几只"，而非"一共完成了几次"

**哈希表 vs 简单变量的对比：**

**方案1：简单变量（当前实现）**
```cpp
int cnt_c = 0, cnt_r = 0, cnt_o = 0, cnt_a = 0, cnt_k = 0;
// 访问：cnt_c++
// 时间复杂度：O(1)
```

**方案2：哈希表**
```cpp
unordered_map<char, int> hash = {{'c',0}, {'r',0}, {'o',0}, {'a',0}, {'k',0}};
// 访问：hash['c']++
// 时间复杂度：O(1)，但常数较大（需要哈希计算）
```

**方案3：数组模拟哈希**
```cpp
int hash[128] = {0};  // ASCII码做索引
// 访问：hash['c']++
// 时间复杂度：O(1)，常数小
```

**对比分析：**

| 方案 | 时间复杂度 | 空间复杂度 | 代码可读性 | 效率 |
|------|-----------|-----------|-----------|------|
| 简单变量 | O(n) | O(1) | 最好 | 最高 |
| 哈希表 | O(n) | O(1) | 中等 | 中等（哈希开销） |
| 数组模拟 | O(n) | O(128) | 好 | 高 |

**使用哈希表的注意点：**
1. **定义方式**：`unordered_map<char, int> hash = {{'c',0}, {'r',0}, ...};`
2. **变量名冲突**：不能用 `c, r, o, a, k` 作为变量名，因为要用字符 `'c'` 索引
3. **常数开销**：哈希函数计算有额外开销，虽然复杂度都是O(1)
4. **代码复杂度**：访问 `hash['c']` 比 `cnt_c` 更啰嗦

**结论：**
- 对于这道题，**简单变量最优**：只有5个状态，直接用变量最清晰高效
- 如果状态很多（如26个字母），用**数组模拟哈希**更好
- 真正的 `unordered_map` 适合状态不连续或数量不确定的场景

**时间复杂度（总体）：**
- 三种方案都是 **O(n)**，n 为字符串长度
- 空间复杂度都是 **O(1)**（固定5个状态）
- 实际运行效率：简单变量 > 数组 > unordered_map

**哈希表实现示例：**
```cpp
class Solution {
public:
    int minNumberOfFrogs(string croakOfFrogs) {
        // 用unordered_map存储每个状态的青蛙数
        unordered_map<char, int> cnt = {{'c',0}, {'r',0}, {'o',0}, {'a',0}, {'k',0}};
        int maxFrogs = 0;
        
        for(char ch : croakOfFrogs) {
            if(ch == 'c') {
                if(cnt['k'] > 0) {
                    cnt['k']--;  // 复用空闲青蛙
                }
                cnt['c']++;
            }
            else if(ch == 'r') {
                if(cnt['c'] == 0) return -1;
                cnt['c']--; cnt['r']++;
            }
            else if(ch == 'o') {
                if(cnt['r'] == 0) return -1;
                cnt['r']--; cnt['o']++;
            }
            else if(ch == 'a') {
                if(cnt['o'] == 0) return -1;
                cnt['o']--; cnt['a']++;
            }
            else if(ch == 'k') {
                if(cnt['a'] == 0) return -1;
                cnt['a']--; cnt['k']++;
            }
            else {
                return -1;
            }
            
            // 统计当前正在叫的青蛙数
            int current = cnt['c'] + cnt['r'] + cnt['o'] + cnt['a'];
            maxFrogs = max(maxFrogs, current);
        }
        
        return (cnt['c']==0 && cnt['r']==0 && cnt['o']==0 && cnt['a']==0) ? maxFrogs : -1;
    }
};
```

**数组模拟哈希实现：**
```cpp
class Solution {
public:
    int minNumberOfFrogs(string croakOfFrogs) {
        // 用数组模拟哈希，ASCII码做索引
        int cnt[128] = {0};  // 足够大，覆盖所有ASCII字符
        int maxFrogs = 0;
        
        for(char ch : croakOfFrogs) {
            if(ch == 'c') {
                if(cnt['k'] > 0) {
                    cnt['k']--;
                }
                cnt['c']++;
            }
            else if(ch == 'r') {
                if(cnt['c'] == 0) return -1;
                cnt['c']--; cnt['r']++;
            }
            else if(ch == 'o') {
                if(cnt['r'] == 0) return -1;
                cnt['r']--; cnt['o']++;
            }
            else if(ch == 'a') {
                if(cnt['o'] == 0) return -1;
                cnt['o']--; cnt['a']++;
            }
            else if(ch == 'k') {
                if(cnt['a'] == 0) return -1;
                cnt['a']--; cnt['k']++;
            }
            else {
                return -1;
            }
            
            int current = cnt['c'] + cnt['r'] + cnt['o'] + cnt['a'];
            maxFrogs = max(maxFrogs, current);
        }
        
        return (cnt['c']==0 && cnt['r']==0 && cnt['o']==0 && cnt['a']==0) ? maxFrogs : -1;
    }
};
```

**三种实现的代码对比：**

| 特性 | 简单变量 | 数组模拟 | unordered_map |
|------|---------|---------|---------------|
| 定义 | `int cnt_c=0;` | `int cnt[128]={0};` | `unordered_map<char,int> cnt;` |
| 访问 | `cnt_c++` | `cnt['c']++` | `cnt['c']++` |
| 可读性 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 性能 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| 扩展性 | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

**选择建议：**
- 状态≤10个：简单变量（最优）
- 状态10-100个：数组模拟（平衡）
- 状态不固定/稀疏：unordered_map（灵活）

---

## 📊 今日总结

### ✅ 完成情况
- **题目数量：** 5题全部AC
- **总耗时：** 约2小时20分钟
- **难度分布：** easy×2, medium×3

### 🎯 核心收获

1. **模拟算法本质：** 直接按题目描述实现，重点在细节处理
2. **状态转换：** Z字形变换中方向切换的时机很关键
3. **状态机思想：** 数青蛙问题用状态机模拟非常清晰
4. **边界处理：** 每道题都要仔细考虑边界情况

### 🤔 思考与疑问

**关于Z字形变换：**
- 为什么我第一次实现时方向切换有问题？
- 状态转换的时机应该在处理字符之前还是之后？

**关于数青蛙：**
- 状态机的设计思路是如何想到的？
- 如何保证统计的青蛙数量是最少的？

### 📈 明日计划
继续模拟专题，或根据比特课程安排进入下一个专题。

---

**今日刷题完成时间：** 10月15日 晚上
**Git提交状态：** 待提交
