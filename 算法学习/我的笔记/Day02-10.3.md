比特课程题目（5题）
✅ 盛水最多的容器（LeetCode 11，中等）⭐⭐⭐
✅ 有效三角形的个数（LeetCode 611，中等）
✅ 查找总价格为目标值的两个商品（LeetCode 剑指Offer II 006）
✅ 和大于等于target的最短子数组（LeetCode 209，中等）
✅ 长度最小的子数组（LeetCode 209，中等，同上）
补充LeetCode高频题（3题）
✅ 三数之和（LeetCode 15，中等）⭐⭐⭐⭐
✅ 接雨水（LeetCode 42，困难）⭐⭐⭐
✅ 颜色分类（LeetCode 75，中等）


1. 盛水最多的容器（LeetCode 11，中等）⭐⭐⭐
方法一：暴力法
直接两层for循环，枚举所有情况，找到最大值，时间复杂度O(n^2)，会超时

方法二：双指针法
定义两个指针，left=0指向最左边，right = nums.size() -1指向最右边，通过左右指针的移动来计算最大值，用一个max来保存最大值，时间复杂度O(n)，左右移动的原则：哪个值小哪个指针朝中间移动，直到left>=right；每次移动之后计算一次体积値v，vmax = max(max, v)，最后返回max即可

原始代码：```cpp
class Solution {
public:
    
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int v = 0;
        int calv(int a,int b){
            if(height[a] < height[b]) return height[a]*height[a]*(b-a);
            else return height[b]*height[b]*(b-a);
        };
        int vmax = calv(left,right);
        for(;left <= right ;)
        {
            if(height[left] < height[right])
            {
                left++;
                v = calv(left,right);
                vmax = max(v,vmax);
            }
            else {
                right--;
                v = calv(left,right);
                vmax = max(v,vmax);
            }
        }
        return vmax;
    }
};
```

**错误分析**：
1. ❌ C++不支持在函数内部定义函数（calv函数位置错误）
2. ❌ 容积公式错误：`height[a]*height[a]*(b-a)` 高度不应该平方！
3. ❌ 循环条件：`left <= right` 应该是 `left < right`

**正确代码**：
```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int vmax = 0;
        
        while(left < right) {
            // 计算当前容积：较短的高度 × 宽度
            int h = min(height[left], height[right]);
            int width = right - left;
            int v = h * width;
            vmax = max(vmax, v);
            
            // 移动较短的那一边
            if(height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return vmax;
    }
};
```

**关键点**：
- 容积公式：`min(height[left], height[right]) * (right - left)`
- 移动策略：移动较短的一边，因为容积受限于较短边
- 时间复杂度：O(n)，空间复杂度：O(1)

**遇到的问题**：
- 想自己封装计算函数，但C++不支持嵌套函数定义
- 容积公式写错了，高度不应该平方

**耗时**：约30分钟（写代码10分钟 + 调试错误20分钟）
**提交结果**：✅ AC通过
