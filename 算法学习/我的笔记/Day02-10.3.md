比特课程题目（5题）
✅ 盛水最多的容器（LeetCode 11，中等）⭐⭐⭐
✅ 有效三角形的个数（LeetCode 611，中等）
✅ 查找总价格为目标值的两个商品（LeetCode 剑指Offer II 006）
✅ 和大于等于target的最短子数组（LeetCode 209，中等）
✅ 长度最小的子数组（LeetCode 209，中等，同上）
补充LeetCode高频题（3题）
✅ 三数之和（LeetCode 15，中等）⭐⭐⭐⭐
✅ 接雨水（LeetCode 42，困难）⭐⭐⭐
✅ 颜色分类（LeetCode 75，中等）


1. 盛水最多的容器（LeetCode 11，中等）⭐⭐⭐
方法一：暴力法
直接两层for循环，枚举所有情况，找到最大值，时间复杂度O(n^2)，会超时

方法二：双指针法
定义两个指针，left=0指向最左边，right = nums.size() -1指向最右边，通过左右指针的移动来计算最大值，用一个max来保存最大值，时间复杂度O(n)，左右移动的原则：哪个值小哪个指针朝中间移动，直到left>=right；每次移动之后计算一次体积値v，vmax = max(max, v)，最后返回max即可

原始代码：```cpp
class Solution {
public:
    
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int v = 0;
        int calv(int a,int b){
            if(height[a] < height[b]) return height[a]*height[a]*(b-a);
            else return height[b]*height[b]*(b-a);
        };
        int vmax = calv(left,right);
        for(;left <= right ;)
        {
            if(height[left] < height[right])
            {
                left++;
                v = calv(left,right);
                vmax = max(v,vmax);
            }
            else {
                right--;
                v = calv(left,right);
                vmax = max(v,vmax);
            }
        }
        return vmax;
    }
};
```

**错误分析**：
1. ❌ C++不支持在函数内部定义函数（calv函数位置错误）
2. ❌ 容积公式错误：`height[a]*height[a]*(b-a)` 高度不应该平方！
3. ❌ 循环条件：`left <= right` 应该是 `left < right`

**正确代码**：
```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0;
        int right = height.size() - 1;
        int vmax = 0;
        
        while(left < right) {
            // 计算当前容积：较短的高度 × 宽度
            int h = min(height[left], height[right]);
            int width = right - left;
            int v = h * width;
            vmax = max(vmax, v);
            
            // 移动较短的那一边
            if(height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        return vmax;
    }
};
```

**关键点**：
- 容积公式：`min(height[left], height[right]) * (right - left)`
- 移动策略：移动较短的一边，因为容积受限于较短边
- 时间复杂度：O(n)，空间复杂度：O(1)

**遇到的问题**：
- 想自己封装计算函数，但C++不支持嵌套函数定义
- 容积公式写错了，高度不应该平方

**耗时**：约30分钟（写代码10分钟 + 调试错误20分钟）
**提交结果**：✅ AC通过


2.有效三角形个数(leetcode 611) 中等 
思路：法一：排序+暴力枚举三层，时间复杂度O(n^3)，法二：排序+双指针，时间复杂度O(n^2)
法二：排序+双指针
1）先排序，从小到大排，固定最右边数
2）在最右边数的左区间内利用双指针，找到满足条件的三角形个数
3）条件：三数中最小的两个数之和大于第三数即可构成三角形
4）移动条件：如果最小两数之和大于最右边的数，则移动右指针，有效三角形个数直接就是右下标减去左下标因为都满足了其他数字此时，然后固定的最右边数左移一位换最新整体左区间继续循环；否则移动左指针，右移左指针，直到找到左值+右值大于最右边的数，这个停止条件是左指针大于等于右指针
初步代码：```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        int n = nums.size()-1;
        int rightmax = n-1;
        int left = 0;
        int right = n-2;
        int ret = 0;//承载结果个数
        sort(nums.begin(),nums.end());
        for(;rightmax>2;)//控制最右值左移
        {
            while(left<right)
            {
                if(nums[left] + nums[right] >nums[rightmax])
                {
                    ret += right-left;
                    right--;
                    rightmax--;
                }
                else left++;
            }

        }
        return ret;
    }
};
```
结果错误解答错误
16 / 241 个通过的测试用例

官方题解
输入
nums =
[2,2,3,4]

添加到测试用例
输出
0
预期结果
3

错误点：
错误1：循环结构完全错了
问题：
rightmax-- 放错位置了！应该在外层循环每次固定完一个数后才减
每次固定新的rightmax后，没有重新初始化left和right
循环条件应该是 rightmax >= 2
错误2：指针没有重置
每次固定一个新的最右边的数后，left和right应该重新指向左区间的两端，但我的代码没做。
错误3：循环逻辑混乱
内层while循环结束后，rightmax应该在外层减1，但我把它放在if里面了。

正确代码：```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        // 1. 先排序，从小到大
        sort(nums.begin(), nums.end());
        
        int n = nums.size();
        int ret = 0;  // 记录有效三角形的个数
        
        // 2. 固定最大的边（从右往左遍历）
        for(int rightmax = n-1; rightmax >= 2; rightmax--) {
            // 3. 在 [0, rightmax-1] 区间内用双指针找另外两条边
            int left = 0;
            int right = rightmax - 1;  // ⚠️ 关键：right是rightmax-1，不是n-2！
            
            // 4. 双指针移动
            while(left < right) {
                // 判断能否构成三角形：两小边之和 > 最大边
                if(nums[left] + nums[right] > nums[rightmax]) {
                    // ✅ 满足条件！此时 [left, left+1, ..., right-1] 
                    // 都能和right、rightmax构成三角形
                    ret += right - left;  // 一次性加上所有满足的组合
                    right--;  // 右指针左移，继续找
                } else {
                    // ❌ 不满足，说明left太小了
                    left++;  // 左指针右移，增大和
                }
            }
        }
        
        return ret;
    }
};
```

**关键点**：
- 三角形条件：任意两边之和大于第三边（排序后只需检查：最小两边和 > 最大边）
- 固定最大边，用双指针在左区间找另外两条边
- `ret += right - left`：一次性统计所有满足条件的三角形
- 时间复杂度：O(n²)，空间复杂度：O(1)

**易错点**：
1. ❌ `int n = nums.size()-1` → ✅ `int n = nums.size()`
2. ❌ `int right = n-2` → ✅ `int right = rightmax - 1`
3. ❌ 循环条件 `rightmax > 2` → ✅ `rightmax >= 2`
4. ❌ 指针不重置 → ✅ 每次外层循环都要重新初始化left和right

**为什么 `ret += right - left`？**
当 `nums[left] + nums[right] > nums[rightmax]` 时：
- `nums[left]` 和 `nums[right]` 能构成三角形 ✅
- `nums[left+1]` 和 `nums[right]` 也能（因为更大） ✅
- `nums[left+2]` 和 `nums[right]` 也能 ✅
- ... 一共有 `right - left` 个！

**耗时**：约35分钟（理解思路10分钟 + 写代码10分钟 + 调试错误15分钟）
**提交结果**：✅ AC通过


3.✅ 查找总价格为目标值的两个商品（LeetCode 剑指Offer II 006）简单

错误代码：
class Solution {
public:
    vector<int> twoSum(vector<int>& price, int target) {
        int n = price.size() - 1;
        int left = 0; 
        int right = n;
        vector<int> ret =[];
        for(;left < right;right--)
        {
            while(left < right)
            {
                if(price[left] + price[right] == target) 
                {
                    ret = {price[left],price[right]};
                }
                else left++;
            }

        }
        return ret;
    }
};
反馈：vector使用模糊，还有这个最后ret该咋把值返回承接，push_back模糊，left和right初始化位置是否正确，循环该咋设置，设置方法

错在哪：
1. vector<int> ret =[]; 这个写法不对，C++里应该直接 vector<int> ret; 或者 vector<int> ret{};
2. 我又写了两层循环，外面for里面while，根本不需要，对撞指针一个while就够了
3. 找到答案了居然没return，还继续循环，这不浪费时间吗
4. else只写了left++，但其实应该判断sum和target的大小，sum小了就left++，sum大了就right--
5. 我n又写成n-1了，这个坏习惯得改

正确代码：
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& price, int target) {
        int left = 0;
        int right = price.size() - 1;
        
        while(left < right) {
            int sum = price[left] + price[right];
            
            if(sum == target) {
                return {price[left], price[right]};  // 找到了直接返回
            } 
            else if(sum < target) {
                left++;  // 和太小，左指针右移
            } 
            else {
                right--;  // 和太大，右指针左移
            }
        }
        
        return {};  // 没找到返回空（虽然题目保证有解）
    }
};
```

思路：
就是对撞指针，因为数组是有序的。左右指针从两头开始，算和，等于target就返回，小了就left++，大了就right--。这题比第一天做的两数之和简单多了，因为有序。

易错：
- 不要写两层循环！一个while就够
- 找到了记得直接return，别继续循环
- 要判断sum和target的大小关系，不能只写left++

耗时：12分钟（看了下比特课程的讲解，然后自己写，但循环写复杂了）
结果：✅ AC



4.和大于等于target的最短子数组（LeetCode 209，中等）
方法：暴力枚举每个子数组，然后判断和是否大于等于target，找到最小的子数组长度。时间复杂度O(n^3)。
方法2：滑动窗口，
思路：滑动窗口经典问题的解决，
- 看到有单调性的问题，可以想到滑动窗口
- 滑动窗口本质是同向移动的两个指针，两个for循环
- 首先定义left，right= 0;然后循环，右指针移动，进窗口，sum去维护窗口内的和；接下来判断，sum>target，记录长度结果更新结果（注意更新结果顺序，因题而定，本题判断成立之后即更新结果）；然后满足出窗口条件，left++，sum减去left指向的值，直到不满足sum>target，此时right++，继续循环。
代码：
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0;
        int n = nums.size();
        int right = 0;
        int sum = 0;
        int len = INT_MAX;
        for(; right < n; right++ )
        {
            sum += nums[right];//进窗口
            while(sum >= target)//判断
            {
                //找到结果，更新结果，然后出窗口
                len = min( len , right - left + 1 );
                sum -= nums[left++];//出窗口操作
                
            }
        }
        return len == (INT_MAX)? 0: len;
    }
};
耗时：15分钟（看了下比特课程的讲解，然后自己写）
结果：✅ AC

**关键点**：
- 滑动窗口适用于：找连续子数组/子串满足某条件的问题
- 窗口操作三步走：①进窗口（right++，更新数据）→ ②判断（while条件）→ ③出窗口（left++，更新数据）
- 本题是"找最短"，所以在while里更新结果
- `INT_MAX` 用来初始化最小值，最后判断是否找到答案

**易错点**：
- ⚠️ 时间复杂度：虽然有两层循环（for + while），但实际是O(n)！因为left和right都只向右移动，每个元素最多进窗口一次、出窗口一次
- ⚠️ 返回值：如果len没被更新（还是INT_MAX），说明没找到，返回0
- ⚠️ 长度计算：`right - left + 1`（包含两端）

---

## 📊 Day02 总结（10.3）

**今日完成：4/8题**
- ✅ 盛水最多的容器（双指针）
- ✅ 有效三角形个数（排序+双指针）
- ✅ 查找总价格为目标值的两个商品（对撞指针）
- ✅ 和大于等于target的最短子数组（滑动窗口）

**今日收获：**
1. **双指针进阶**：从简单的对撞指针到固定最大值+双指针找另外两个数
2. **滑动窗口入门**：理解了窗口操作三步走（进窗口→判断→出窗口）
3. **时间复杂度分析**：明白了为什么滑动窗口是O(n)而不是O(n²)
4. **C++基础巩固**：vector初始化、函数定义位置、循环结构优化

**典型错误：**
- C++不支持嵌套函数定义
- 循环结构容易写复杂（不需要两层循环的地方写了两层）
- 指针没有在外层循环重新初始化
- 找到答案后忘记return直接返回

**总耗时：** 约72分钟
**剩余任务：** 明天补上4题滑动窗口（904、1658、713、76）

**明日计划：** 
- 上午：完成剩余4题滑动窗口
- 晚上：开始比特课程Day3内容（栈与队列）

💪 坚持就是胜利！明天加油！