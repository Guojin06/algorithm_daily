# Day15 - 10月16日学习笔记

## 📚 今日专题：分治算法

### 🎯 学习目标
- 掌握分治算法的核心思想：分而治之
- 完成快速排序和归并排序两大核心算法
- 理解递归与分治的关系
- 目标：完成至少5道题

### 📝 专题理论

**分治算法核心思想：**
1. **分（Divide）**：将原问题分解为若干个规模较小的子问题
2. **治（Conquer）**：递归地解决这些子问题
3. **合（Combine）**：将子问题的解合并为原问题的解

**分治算法的三要素：**
- 问题可以分解为若干个子问题
- 子问题与原问题性质相同，只是规模变小
- 子问题的解可以合并为原问题的解

**本专题包含：**
- **快速排序系列**（4题）：
  - 颜色分类（LeetCode 75）- 三指针法
  - 快速排序（LeetCode 912）- 分三块 + 随机基准
  - 快速选择算法（LeetCode 215）- 第K大元素
  - 最小的k个数（剑指Offer 40）
  
- **归并排序系列**（4题）：
  - 归并排序（LeetCode 912）
  - 数组中的逆序对（剑指Offer 51）⭐⭐
  - 计算右侧小于当前元素的个数（LeetCode 315）⭐⭐
  - 翻转对（LeetCode 493）⭐⭐

---

## 🔥 刷题记录

### 题目1：颜色分类 (LeetCode 75)

**题目描述：**
给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 0、1 和 2 分别表示红色、白色和蓝色。

必须在不使用库的 sort 函数的情况下解决这个问题。

**示例：**
- 输入：nums = [2,0,2,1,1,0]
- 输出：[0,0,1,1,2,2]

**我的思路：**
使用三指针法将数组分成四段：
- `left`：指向0序列的最右边，初始化为-1（0序列为空）
- `i`：当前遍历指针，初始化为0
- `right`：指向2序列的最左边，初始化为n（2序列为空）
- 数组四段：`[0, left]` 是0，`[left+1, i-1]` 是1，`[i, right-1]` 是待处理，`[right, n-1]` 是2

遍历过程：
1. `nums[i] == 0`：交换`nums[++left]`和`nums[i++]`，因为left+1位置要么是1要么是i本身，交换后一定正确，所以i可以++
2. `nums[i] == 1`：当前位置就对了，直接`i++`
3. `nums[i] == 2`：交换`nums[--right]`和`nums[i]`，**注意i不动**，因为换过来的元素还没判断过

**我的代码：**
```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        //分治，三指针，数组四段，left表示0最右边，right表示2最左边，i向后遍历
        int n = nums.size();
        int left = -1, right = n;
        for(int i = 0; i < right;)  // 注意：循环条件里没有i++
        {
            if(nums[i] == 0) swap(nums[++left], nums[i++]);
            else if(nums[i] == 1) i++;
            else swap(nums[--right], nums[i]);  // 这里i不能++
        }
    }
};
```

**提交结果：** ✅ AC
**耗时：** 10分钟（看视频15分钟 + 自己写代码10分钟）
**关键理解：**
1. **三指针维护四段区间**：
   - `[0, left]`：已确定的0
   - `[left+1, i-1]`：已确定的1
   - `[i, right-1]`：待处理
   - `[right, n-1]`：已确定的2

2. **为什么遇到0时i可以++，遇到2时不能++？**
   - 遇到0：`left+1`位置的元素要么是1（已经判断过），要么是i自己（也判断过了），交换后一定正确
   - 遇到2：`right-1`位置的元素是**未判断过的**，交换过来后必须重新判断，所以i不能动

3. **易错点**：
   - ❌ 在for循环里写`for(int i = 0; i < right; i++)`会导致错误
   - ✅ 应该写`for(int i = 0; i < right;)`，让每个分支自己控制i的移动
   - 原因：遇到2时i不该动，但循环末尾的i++会强制让它移动

4. **循环条件为什么是`i < right`？**
   - right表示2序列的左边界
   - 当i碰到right时，说明待处理区间`[i, right-1]`为空，所有元素都已处理完毕 

---

### 题目2：快速排序 (LeetCode 912)

**题目描述：**
给你一个整数数组 nums，请你将该数组升序排列。

**示例：**
- 输入：nums = [5,2,3,1]
- 输出：[1,2,3,5]

**我的思路：**
使用快速排序的分治思想：
1. **随机选择基准元素**：避免最坏情况（有序数组导致O(n²)）
2. **数组分三块**：利用荷兰国旗思想，将数组分为 < key、== key、> key 三部分
3. **递归排序**：对左右两部分递归排序，中间相等部分不需要再排

**我的代码：**
```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        srand(time(NULL));  // 种下一个随机数种子
        qsort(nums, 0, nums.size() - 1);
        return nums;
    }
    
    // 快排
    void qsort(vector<int>& nums, int l, int r) {
        if(l >= r) return;  // 递归出口
        
        // 数组分三块
        int key = getRandom(nums, l, r);
        int i = l, left = l - 1, right = r + 1;
        while(i < right) {
            if(nums[i] < key) swap(nums[++left], nums[i++]);
            else if(nums[i] == key) i++;
            else swap(nums[--right], nums[i]);
        }
        // [l, left], [left+1, right-1], [right, r]
        qsort(nums, l, left);      // 递归排序左边
        qsort(nums, right, r);     // 递归排序右边
    }
    
    int getRandom(vector<int>& nums, int left, int right) {
        int r = rand();
        return nums[r % (right - left + 1) + left];
    }
};
```

**提交结果：** ✅ AC
**耗时：** 约30分钟（看题解 + 理解 + 敲代码）

**关键理解：**

### 1. **srand(time(NULL)) 的作用**
```cpp
srand(time(NULL));  // 种下随机数种子
int r = rand();     // 生成随机数
```
- `srand()`：设置随机数种子（seed random）
- `time(NULL)`：获取当前时间戳（秒级）
- **为什么需要？** 如果不设置种子，`rand()` 每次运行程序都会生成相同的"随机数"序列
- **只需调用一次**：在主函数开始时调用即可，后续所有`rand()`都会基于这个种子

### 2. **随机选择基准元素**
```cpp
int getRandom(vector<int>& nums, int left, int right) {
    int r = rand();  // 生成随机数
    return nums[r % (right - left + 1) + left];  // 转换为区间内的随机下标
}
```
- `r % (right - left + 1)`：将随机数映射到 `[0, right-left]` 范围
- `+ left`：偏移到 `[left, right]` 范围
- **目的**：避免最坏情况，提高平均性能

### 3. **时间复杂度分析**

| 情况 | 时间复杂度 | 说明 |
|------|-----------|------|
| **平均情况** | **O(n log n)** | 每次划分较均匀，递归深度log n，每层O(n) |
| **最好情况** | **O(n log n)** | 每次恰好分成两半 |
| **最坏情况** | **O(n²)** | 每次只分出1个元素（如已排序数组且选首/尾为基准） |

**本题优化后的复杂度：**
- **随机选择基准**：使最坏情况概率极低，期望O(n log n)
- **数组分三块**：处理大量重复元素时效率更高（跳过中间相等部分）

### 4. **正常快排 vs 优化快排**

**传统快排（数组分两块）：**
```cpp
void qsort(vector<int>& nums, int l, int r) {
    if(l >= r) return;
    int key = nums[l];  // 固定选第一个元素
    int i = l, j = r;
    while(i < j) {
        while(i < j && nums[j] >= key) j--;
        nums[i] = nums[j];
        while(i < j && nums[i] <= key) i++;
        nums[j] = nums[i];
    }
    nums[i] = key;
    qsort(nums, l, i - 1);
    qsort(nums, i + 1, r);
}
```
- **问题1**：固定选第一个元素，遇到有序数组退化为O(n²)
- **问题2**：大量重复元素时，相等元素也要递归处理

**本题优化快排（数组分三块 + 随机基准）：**
```cpp
// 1. 随机选择基准：避免最坏情况
int key = getRandom(nums, l, r);

// 2. 数组分三块：[<key] [==key] [>key]
// 中间相等部分不需要递归！
qsort(nums, l, left);      // 只递归 < key 的部分
qsort(nums, right, r);     // 只递归 > key 的部分
```
- **优势1**：随机基准使最坏情况概率降到几乎为0
- **优势2**：大量重复元素时，跳过中间相等部分，效率大幅提升

### 5. **为什么LeetCode需要这些优化？**
- 测试用例包含**有序数组**和**大量重复元素**
- 传统快排会超时（Time Limit Exceeded）
- 官方题解的快排也可能超时（2022年数据）

### 6. **递归过程示例**
```
原数组: [5, 2, 3, 1, 5, 5, 4]
随机选key=5

第一次划分:
[2, 3, 1, 4] [5, 5, 5] [无]
   ↓递归      ↓跳过    ↓跳过

左边继续: [2, 3, 1, 4]，选key=3
[2, 1] [3] [4]
  ↓     ↓   ↓
继续递归...

最终: [1, 2, 3, 4, 5, 5, 5]
```

### 7. **空间复杂度**
- **O(log n)**：递归调用栈的深度（平均情况）
- **O(n)**：最坏情况（退化为链式递归） 

---

### 题目3：数组中的第K个最大元素 (LeetCode 215)

**题目描述：**
给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

**示例：**
- 输入: [3,2,1,5,6,4], k = 2
- 输出: 5（排序后[6,5,4,3,2,1]，第2大是5）

**我的思路：**
使用**快速选择算法**，基于快速排序的分三段思想：
1. 将数组分三块：`[<key]` `[==key]` `[>key]`
2. 根据每段元素个数判断第k大落在哪段
3. 只递归目标区间，不需要完全排序

**关键转换：**
- 从大到小看，右边区间c是最大的c个元素
- 如果 `c >= k`：第k大在右边
- 如果 `c < k` 但 `(b+c) >= k`：第k大就是key
- 否则：第k大在左边，需要找左边的第 `(k-b-c)` 大

**我的代码：**
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        //快速选择算法，基于快速排序分三段思想，去对应段递归，根据每段个数去判定落在哪段然后递归
        srand(time(NULL));
        return qsortselk(nums, 0, nums.size() - 1, k);
    }
    
    int qsortselk(vector<int>& nums, int l, int r, int k) {
        if(l >= r) return nums[l];  // 递归出口

        // 数组分三块（快排核心，不变）
        int key = getRandom(nums, l, r);
        int i = l, left = l - 1, right = r + 1;
        while(i < right) {
            if(nums[i] < key) swap(nums[++left], nums[i++]);
            else if(nums[i] == key) i++;
            else swap(nums[--right], nums[i]);
        }

        // 接下来进行第k大判断区间
        // 三个区间：[l, left], [left+1, right-1], [right, r]
        // 定义三个变量表示元素个数
        int a = left - l + 1;                    // 左边区间（小于key）
        int b = (right - 1) - (left + 1) + 1;    // 中间区间（等于key）
        int c = r - right + 1;                   // 右边区间（大于key）
        
        if(c >= k) return qsortselk(nums, right, r, k);           // 第k大在右边
        else if((b + c) >= k) return key;                         // 第k大就是key
        else return qsortselk(nums, l, left, k - b - c);         // 第k大在左边
    }
    
    int getRandom(vector<int>& nums, int left, int right) {
        int r = rand();
        return nums[r % (right - left + 1) + left];
    }
};
```

**提交结果：** ✅ AC
**耗时：** 约40分钟（理解算法 + 调试）

**关键理解：**

### 1. **快速选择 vs 快速排序**

| 算法 | 目的 | 递归次数 | 时间复杂度 |
|------|------|---------|-----------|
| **快速排序** | 完全排序 | 每次递归左右两边 | O(n log n) |
| **快速选择** | 找第k大 | 每次只递归一边 | **O(n)** |

快速选择的优势：**不需要完全排序，只找目标元素**

### 2. **三个区间的判断逻辑（从大到小角度）**

```
划分后：[小于key] [等于key] [大于key]
        ← a个 →  ← b个 →  ← c个 →

从大到小排列：
位置1~c：      右边区间（最大的c个元素）
位置c+1~c+b：  中间区间（key）
位置c+b+1~n：  左边区间（最小的a个元素）

判断第k大：
1. k <= c：         第k大在右边区间
2. c < k <= c+b：   第k大就是key
3. k > c+b：        第k大在左边，是左边的第(k-b-c)大
```

### 3. **具体示例**

```
数组: [3,2,1,5,6,4], k=2

第1轮：选key=4，划分
[3,2,1] [4] [5,6]
 a=3    b=1  c=2

判断：c=2 >= k=2? 是！
递归右边：qsortselk([5,6], 0, 1, k=2)

第2轮：选key=5，划分
[] [5] [6]
a=0 b=1 c=1

判断：c=1 >= k=2? 否
      (b+c)=2 >= k=2? 是！
返回：key=5 ✅

最终答案：5
```

### 4. **易错点总结**

**错误1：递归调用忘记return**
```cpp
if(c >= k) qsortselk(nums, right, r, k);  // ❌ 缺少return
if(c >= k) return qsortselk(nums, right, r, k);  // ✅ 正确
```

**错误2：函数参数不用引用**
```cpp
int qsortselk(vector<int> nums, ...)  // ❌ 每次递归都复制数组，超时
int qsortselk(vector<int>& nums, ...) // ✅ 引用传递，不复制
```

**错误3：右边区间个数计算错误**
```cpp
int c = (r - right + 1) + 1;  // ❌ 多加了一个+1
int c = r - right + 1;        // ✅ 正确
```

### 5. **时间复杂度分析**

```
第1次：处理n个元素，划分后只递归一边
第2次：处理n/2个元素
第3次：处理n/4个元素
...

总时间：n + n/2 + n/4 + n/8 + ... ≈ 2n = O(n)

对比完全排序O(n log n)，快速选择更优！
```

### 6. **空间复杂度**
- **O(log n)**：递归调用栈深度（平均情况）
- **O(n)**：最坏情况（每次只分出1个元素）

### 7. **为什么比堆排序快？**

| 方法 | 时间复杂度 | 原理 |
|------|-----------|------|
| 小根堆 | O(n log k) | 维护大小为k的堆 |
| 快速选择 | **O(n)** | 每次排除一半元素 |

当k较大时（如k=n/2），快速选择明显更快！ 

---

### 题目4：最小的K个数 (剑指Offer 40)

**题目描述：**
设计一个算法，找出数组中最小的k个数，以任意顺序返回这k个数均可。

**示例：**
- 输入：arr = [1,3,5,7,2,4,6,8], k = 4
- 输出：[1,2,3,4]（顺序可以不同）

**我的思路：**
使用**快速选择算法**，和上一题类似，但目标不同：
- 上一题：找**第K大**的元素（1个值）
- 这一题：找**最小的K个**数（K个值）

核心思想：
1. 用快排的partition将数组分三块
2. 判断第k小的元素在哪个区间
3. 递归调整，使得前k个位置是最小的k个数
4. 最后直接取前k个元素

**我的代码：**
```cpp
class Solution {
public:
    vector<int> smallestK(vector<int>& arr, int k) {
        if(k == 0) return {};  // 边界情况
        
        srand(time(NULL));
        quickSelect(arr, 0, arr.size() - 1, k);
        
        // 取前k个元素（已经是最小的k个了）
        vector<int> ret(arr.begin(), arr.begin() + k);
        return ret;
    }
    
    void quickSelect(vector<int>& arr, int l, int r, int k) {
        if(l >= r) return;
        
        // 数组分三块
        int key = arr[getRandom(arr, l, r)];
        int i = l, left = l - 1, right = r + 1;
        
        while(i < right) {
            if(arr[i] < key) swap(arr[++left], arr[i++]);
            else if(arr[i] == key) i++;
            else swap(arr[--right], arr[i]);
        }
        
        // 判断第k小在哪个区间
        // [l, left], [left+1, right-1], [right, r]
        int a = left - l + 1;      // 左边区间大小（小于key）
        int b = right - left - 1;  // 中间区间大小（等于key）
        
        if(k <= a) {
            // 第k小在左边
            quickSelect(arr, l, left, k);
        }
        else if(k <= a + b) {
            // 第k小在中间（就是key），前k个已经是最小的k个了
            return;
        }
        else {
            // 第k小在右边，是右边的第(k-a-b)小
            quickSelect(arr, right, r, k - a - b);
        }
    }
    
    int getRandom(vector<int>& arr, int left, int right) {
        int r = rand();
        return left + r % (right - left + 1);
    }
};
```

**提交结果：** ✅ AC
**耗时：** 约35分钟（理解题意 + 调试）

**关键理解：**

### 1. **与"第K大元素"的区别**

| 题目 | 目标 | 返回类型 | 递归函数返回 | 最后操作 |
|------|------|---------|-------------|---------|
| **第K大元素** | 找1个元素的值 | `int` | `return key;` | 直接返回值 |
| **最小K个数** | 找K个元素 | `vector<int>` | `return;` | 取前k个 |

### 2. **为什么递归函数是void？**

```cpp
// 上一题：需要返回具体的值
int qsortselk(...) {
    if(c >= k) return qsortselk(...);  // 返回递归结果
    else if((b+c) >= k) return key;    // 返回找到的值
    else return qsortselk(...);
}

// 这一题：只需要调整数组位置
void quickSelect(...) {
    if(k <= a) quickSelect(...);       // 只是递归调用
    else if(k <= a+b) return;          // 直接结束
    else quickSelect(...);
}
```

**原因：** 快速选择会**原地修改数组**，把最小的k个数移到前k个位置，不需要返回值。

### 3. **判断逻辑（从小到大角度）**

```
划分后：[小于key] [等于key] [大于key]
        ← a个 →  ← b个 →  ← c个 →

从小到大排列：
位置1~a：      左边区间（最小的a个元素）
位置a+1~a+b：  中间区间（key）
位置a+b+1~n：  右边区间（最大的c个元素）

判断第k小：
1. k <= a：         第k小在左边，递归左边
2. a < k <= a+b：   第k小是key，前k个已经是最小的k个
3. k > a+b：        第k小在右边，递归右边找第(k-a-b)小
```

### 4. **执行过程示例**

```
数组: [3,2,1,5,6,4], k=4

第1轮：选key=4，划分
[3,2,1] [4] [5,6]
 a=3    b=1  c=2

判断：k=4, a=3, a+b=4
      k <= a+b? 是！
      
数组状态：[3,2,1] [4] [5,6]
          ↑---------↑
          前4个就是最小的4个

return;  // 结束递归

主函数：取前4个 → [3,2,1,4] ✅
```

### 5. **三种解法对比**

| 方法 | 时间复杂度 | 空间复杂度 | 代码难度 |
|------|-----------|-----------|---------|
| 排序后取前k个 | O(n log n) | O(log n) | ⭐ |
| 大根堆 | O(n log k) | O(k) | ⭐⭐ |
| **快速选择** | **O(n)** | O(log n) | ⭐⭐⭐ |

快速选择是最优解！

### 6. **易错点**

**错误1：返回类型搞混**
```cpp
int quickSelect(...)  // ❌ 不需要返回int
void quickSelect(...) // ✅ 只修改数组，不返回值
```

**错误2：区间大小计算错误**
```cpp
int b = right - left - 1;  // ✅ 中间区间：[left+1, right-1]
int b = right - left;      // ❌ 多算了1个
```

**错误3：忘记边界情况**
```cpp
if(k == 0) return {};  // ✅ k=0时返回空数组
``` 

---

## 📊 今日总结

### ✅ 完成情况
- **题目数量：** 4题（全部AC）
- **总耗时：** 约140分钟
- **难度分布：** 
  - Medium: 4题（颜色分类、快速排序、第K大元素、最小K个数）

### 🎯 核心收获

**1. 掌握快速排序的核心思想**
- **三指针法（荷兰国旗）**：将数组分成 `[<key]` `[==key]` `[>key]` 三块
- **随机选择基准**：避免有序数组导致的O(n²)退化
- **递归结构**：分治思想的典型应用

**2. 理解快速选择算法**
- 不需要完全排序，只找目标元素
- 时间复杂度从O(n log n)优化到O(n)
- 每次只递归一边，而不是两边都递归

**3. 区分两类问题**
- **第K大元素**：返回1个值，递归函数返回`int`
- **最小K个数**：返回K个值，递归函数返回`void`（原地修改）

**4. 递归出口的重要性**
- `if(l >= r) return;` 处理单元素和空区间
- 理解为什么会出现`l > r`的情况（left初始化为l-1）

### 🤔 思考与疑问

**已解决的疑问：**
1. ✅ `srand(time(NULL))`的作用：设置随机数种子
2. ✅ 为什么循环条件不能写`i++`：遇到2时i不该移动
3. ✅ 递归出口为什么用`>=`而不是`==`：处理空区间
4. ✅ 为什么会出现`l=0, r=-1`：left初始化为l-1，可能保持不变
5. ✅ 快速选择为什么有的return值，有的return空：返回类型不同

**今日收获：**
- 分治算法的精髓：**分而治之，各个击破**
- 快排的优化技巧：随机基准 + 三块划分
- 算法优化思路：从O(n log n)到O(n)

### 📈 明日计划
继续分治专题的归并排序部分，或根据比特课程安排进入下一个专题。

---

**今日刷题完成时间：** 10月16日
**Git提交状态：** 待提交

