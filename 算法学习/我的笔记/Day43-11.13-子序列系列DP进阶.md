# Day43｜11.13｜子序列系列 DP 进阶

## 今日目标
- 掌握子序列 DP 的各种变体，从单序列扩展到双序列、计数、存在性问题
- 理解不同目标（最优值、计数、判断）对状态设计的影响
- 建立完整的子序列 DP 解题体系

## 题目规划
1. **LeetCode 1143. 最长公共子序列** - 双序列DP基础
2. **LeetCode 115. 不同的子序列** - 计数类子序列DP  
3. **LeetCode 392. 判断子序列** - 存在性子序列问题（可简化为双指针）
4. **LeetCode 516. 最长回文子序列** - 特殊条件子序列

## 子序列 DP 问题分类

### 按序列数量分类
- **单序列 DP**：在一个序列内找子序列（LIS、摆动序列）
- **双序列 DP**：两个序列之间的关系（LCS、不同子序列）

### 按求解目标分类  
- **最优值问题**：求最大/最小长度、价值等
- **计数问题**：统计满足条件的子序列数量
- **存在性问题**：判断某个子序列是否存在

### 按约束条件分类
- **无约束**：普通的子序列问题
- **特殊约束**：回文、递增、摆动等条件

---

## LeetCode 115. 不同的子序列 ⭐

### 题目小结
- 给定字符串 `s` 和 `t`，计算 `s` 的子序列中 `t` 出现的个数
- 子序列可以跳过字符，但顺序必须保持
- **计数类双序列DP** 的经典题目

### From 0 to 1 思考路径
1. **问题识别**：两个字符串 + 求个数 → 计数类双序列DP问题
2. **状态设计**：`dp[i][j] = 从s前i个字符中，能凑出t前j个字符的方法数`
3. **转移分析**：考虑 `s[i-1]` 和 `t[j-1]` 的关系
   - **相等**：两种选择累加
     - 用 `s[i-1]` 匹配 `t[j-1]` → `dp[i-1][j-1]` 种方法
     - 不用 `s[i-1]` → `dp[i-1][j]` 种方法
     - 总数：`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`
   - **不相等**：`s[i-1]` 肯定不能用 → `dp[i][j] = dp[i-1][j]`
4. **初始化**：
   - `dp[i][0] = 1`：任何s都有1种方法凑出空t（不选字符）
   - `dp[0][j] = 0`：空s凑不出非空t
5. **溢出处理**：方法数可能很大，用 `unsigned long long` 或取模

### 代码实现

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.size();
        int n = t.size();
        // 创建dp数组：m+1，n+1，处理空字符串
        // dp[i][j] = 从s的前i个字符中，能凑出t的前j个字符，有多少种方法
        unsigned long long dp[1001][1001] = {0};
        
        // 初始化：空字符串的情况
        // dp[i][0] = 1：任何s都有1种方法凑出空t（不选任何字符）
        for(int i = 0; i <= m; i++) {
            dp[i][0] = 1;
        }
        // dp[0][j] = 0：空s不可能凑出任何非空t（已经在初始化中为0）
        
        // 填表，索引注意：s[i-1]和t[j-1]对应dp[i][j]
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(s[i-1] == t[j-1]) {
                    // 字符相等：两种选择累加
                    // 1.用s[i-1]匹配t[j-1] → dp[i-1][j-1]
                    // 2.不用s[i-1] → dp[i-1][j]
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                } else {
                    // 字符不相等，s[i-1]肯定不能用
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[m][n];
    }
};
```

### 复盘 & 要点
- **计数vs最优值**：计数问题要累加所有可能，最优值问题取最大/最小
- **状态设计**：双序列DP的标准前缀定义，处理空字符串很重要
- **转移逻辑**：
  - 相等：`dp[i-1][j-1] + dp[i-1][j]`（用+不用）
  - 不相等：`dp[i-1][j]`（只能不用）
- **溢出意识**：组合数增长极快，需要用大数类型或取模
- **复杂度**：时间 O(m×n)，空间 O(m×n)
- **核心模板**：计数类DP的基础框架，累加思想是关键

---

## LeetCode 1218. 最长定差子序列 ⭐

### 题目小结
- 给定整数数组 `arr` 和整数 `difference`，求最长的等差子序列长度
- 等差子序列中相邻元素的差等于 `difference`
- **约束子序列DP** 的优化典型

### From 0 to 1 思考路径
1. **问题识别**：子序列 + 固定差值约束 → 约束子序列DP问题
2. **暴力思路**：套用LIS模板，`dp[i] = 以arr[i]结尾的最长定差子序列`
   - 转移：枚举所有j < i，检查 `arr[i] - arr[j] == difference`
   - 问题：O(n²)超时
3. **关键优化**：定差约束的特殊性
   - LIS需要检查所有满足 `nums[j] < nums[i]` 的j（很多个）
   - 定差只需要找到满足 `arr[j] = arr[i] - difference` 的j（最多1个）
4. **哈希表优化**：用数值作为key，直接定位前驱
   - `hash[x] = 以数值x结尾的最长定差子序列长度`
   - 转移：`hash[arr[i]] = hash[arr[i] - difference] + 1`
5. **复杂度优化**：从O(n²) → O(n)

### 代码实现

```cpp
class Solution {
public:
    int longestSubsequence(vector<int>& arr, int difference) {
        // 哈希表：key=数值，value=以该数值结尾的最长等差子序列长度
        unordered_map<int, int> hash;
        
        int result = 0;  // 记录全局最大长度
        
        // 遍历每个元素
        for(int i = 0; i < arr.size(); i++) {
            // 计算前驱数值
            int prev = arr[i] - difference;
            
            // 当前长度的计算
            int currLen;
            if(hash.count(prev)) {
                // 前驱存在，可以接在前驱后面：前驱长度 + 1
                currLen = hash[prev] + 1;
            } else {
                // 前驱不存在，只能自己开始：长度为1
                currLen = 1;
            }
            
            // 更新哈希表
            hash[arr[i]] = currLen;
            
            // 更新全局最大值
            result = max(result, currLen);
        }
        
        return result;
    }
};
```

### 复盘 & 要点
- **优化本质**：从"枚举查找" → "直接定位"，利用定差约束的唯一性
- **哈希表思维**：用数值作为dp索引，而不是位置索引
- **状态转移简化**：`dp[i] = max(dp[j] + 1)` → `hash[x] = hash[x-diff] + 1`
- **复杂度**：时间 O(n)，空间 O(n)
- **适用场景**：当约束条件能唯一确定前驱时，可以考虑哈希表优化

---

## LeetCode 1143. 最长公共子序列 ⭐

### 题目小结
- 给定两个字符串 `text1` 和 `text2`，求最长公共子序列长度
- 子序列允许跳过字符，不要求连续
- **双序列DP** 的经典入门题目

### From 0 to 1 思考路径
1. **问题识别**：两个字符串 + 公共子序列 → 双序列DP问题
2. **状态设计**：需要同时考虑两个字符串的信息，必须用二维DP
   - `dp[i][j] = text1前i个字符 vs text2前j个字符的最长公共子序列长度`
3. **转移分析**：考虑 `text1[i-1]` 和 `text2[j-1]` 的关系
   - **相等**：两个字符可以匹配 → `dp[i][j] = dp[i-1][j-1] + 1`
   - **不相等**：必须放弃一个字符 → `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
4. **初始化**：`dp[0][j] = 0`，`dp[i][0] = 0`（空字符串情况）
5. **答案获取**：`dp[m][n]` 就是最终结果

### 代码实现

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        // 创建dp数组，注意要(m+1),(n+1)因为要包含空字符串
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        
        // 填表：从1开始遍历
        // dp[i][j] = text1[i-1]和text2[j-1]的LCS长度
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                if(text1[i-1] == text2[j-1]) {
                    // 字符相等的情况：当前字符匹配 + 前面的LCS
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    // 字符不相等的情况：选择不用某个字符
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
};
```

### 复盘 & 要点
- **双序列DP本质**：状态需要包含两个序列的位置信息
- **索引对应关系**：`dp[i][j]` 对应 `text1[i-1]` 和 `text2[j-1]`，方便处理空字符串
- **转移逻辑**：
  - 相等：两个字符都参与，长度+1
  - 不相等：必须放弃一个，取两种放弃方式的最大值
- **复杂度**：时间 O(m×n)，空间 O(m×n)
- **核心模板**：双序列DP的基础框架，很多双序列问题都基于此扩展

---

## LeetCode 646. 最长数对链 ⭐

### 题目小结
- 给定数对数组 `pairs`，其中 `pairs[i] = [left_i, right_i]`
- 如果 `right_i < left_j`，则数对 `i` 可以接在数对 `j` 后面形成链
- 求最长数对链的长度

### From 0 to 1 思考路径
1. **问题转化**：这本质上是子序列问题！每个数对是一个"元素"，有约束条件的子序列
2. **排序预处理**：为了方便判断前后关系，先按左端点排序（或右端点）
3. **状态设计**：`dp[i] = 以 pairs[i] 结尾的最长数对链长度`
4. **转移推导**：
   - 遍历所有 `j < i`，如果 `pairs[j][1] < pairs[i][0]`（满足链的条件）
   - 可以把 `pairs[i]` 接在 `pairs[j]` 后面：`dp[i] = max(dp[i], dp[j] + 1)`
5. **初始化与答案**：
   - 每个数对自身构成长度为1的链：`dp[i] = 1`
   - 全局答案是 `max(dp[i])`

### 代码实现

```cpp
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        // dp[i]表示以i位置元素为结尾的所有数对链中，最长的那个数对链长度
        sort(pairs.begin(), pairs.end());
        int n = pairs.size();
        vector<int> dp(n, 1);
        int ret = 1;
        
        for(int i = 1; i < n; i++) {
            for(int j = 0; j < i; j++) {
                if(pairs[j][1] < pairs[i][0])
                    dp[i] = max(dp[j] + 1, dp[i]);
            }
            ret = max(dp[i], ret);
        }
        return ret;
    }
};
```

### 复盘 & 要点
- **子序列DP本质**：虽然是数对，但思路完全一致 - "以i结尾" + "枚举前驱j"
- **排序必要性**：排序后才能保证 `j < i` 的索引顺序与逻辑顺序一致
- **约束条件**：`pairs[j][1] < pairs[i][0]` 是本题的特殊约束，类似LIS中的 `nums[j] < nums[i]`
- **复杂度**：时间 O(n²)，空间 O(n)。还有 O(n log n) 的贪心解法作为进阶

---

## LeetCode 115. 不同的子序列

### 题目小结

### From 0 to 1 思考路径

### 代码实现

### 复盘 & 要点

---

## LeetCode 392. 判断子序列

### 题目小结

### From 0 to 1 思考路径

### 代码实现

### 复盘 & 要点

---

## LeetCode 516. 最长回文子序列

### 题目小结

### From 0 to 1 思考路径

### 代码实现

### 复盘 & 要点

---

## 今日总结
- 子序列 DP 的核心技巧总结
- 与子数组 DP 的对比分析
- 状态设计的通用思路

---

## 明日预告
- 背包问题专题入门
- 01背包、完全背包、多重背包的区分与解法
