# Day47-11.18-双数组DP收尾+背包问题入门

## 今日计划
- 完成双数组DP最后一题：48. Longest Repeating Subarray
- 开始背包问题专题：01背包、完全背包、多重背包基础模型
- 每题按标准模板记录：题目小结、思路框架、代码、复盘要点

---

## 48. 两个数组的 DP 问题：最长重复子数组

### 题目小结
- 输入：两个整数数组 `nums1`、`nums2`。
- 规则：找到在两个数组中都出现的**最长公共子数组**（子数组要求连续）。
- 输出：最长公共子数组的长度。

### 思路框架（双序列前缀 DP，最长值型）

#### 1. 状态定义
- `m = len(nums1)`, `n = len(nums2)`。
- `dp[i][j]`：以 `nums1[i-1]` 和 `nums2[j-1]` **结尾**的最长公共子数组的长度。
- 下标范围：`1 <= i <= m`, `1 <= j <= n`。
- 目标：`max(dp[i][j])` 对所有 `i, j`。

> 注意：这题的状态定义和前面的 LCS 不同，LCS 是前缀的最长公共子序列，这里是**以当前位置结尾**的最长公共子数组。

#### 2. 初始化
- `dp[0][*]` 和 `dp[*][0]` 不需要显式初始化，因为状态定义要求以 `i-1` 和 `j-1` 结尾。
- 所有元素初始化为 0。

#### 3. 状态转移
看 `nums1[i-1]` 和 `nums2[j-1]`：

1. **字符相等**：
   - 可以在前面基础上 +1：
   - `dp[i][j] = dp[i-1][j-1] + 1`。

2. **字符不等**：
   - 不能构成公共子数组，长度为 0：
   - `dp[i][j] = 0`。

#### 4. 遍历顺序
- 依赖 `dp[i-1][j-1]`，从上到下、从左到右填表即可。
- 需要维护全局最大值。

### 我的代码尝试（AC 版本 C++）

```cpp
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        // dp[i][j]：以nums1[i-1]和nums2[j-1]结尾的最长公共子数组长度
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        
        int result = 0;
        
        // 状态转移
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (nums1[i-1] == nums2[j-1]) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                    result = max(result, dp[i][j]);
                } else {
                    dp[i][j] = 0;
                }
            }
        }
        
        return result;
    }
};
```

### 复盘要点
- [ ] 能否区分「最长公共子序列」vs「最长公共子数组」：
  - 子序列：不连续，状态定义是前缀。
  - 子数组：连续，状态定义是以当前位置结尾。
- [ ] 状态定义是否清晰：`dp[i][j]` 是**以 i-1 和 j-1 结尾**的最长长度，不是前缀。
- [ ] 为什么不需要初始化第一行/第一列：
  - 因为状态定义要求以具体位置结尾，`dp[0][*]` 和 `dp[*][0]` 没有意义。
- [ ] 能否想到空间优化：
  - 只依赖 `dp[i-1][j-1]`，可以用滚动数组优化到 O(n) 空间。

---

## 核心对比：LCS vs 最长公共子数组

| 项目 | 最长公共子序列（LCS） | 最长公共子数组 |
|------|----------------------|----------------|
| **连续性要求** | 不要求连续 | 必须连续 |
| **状态定义** | `dp[i][j] = 前i个和前j个的最长长度` | `dp[i][j] = 以i-1和j-1结尾的最长长度` |
| **不相等时的转移** | `max(dp[i-1][j], dp[i][j-1])`（可以跳过） | `0`（直接断掉） |
| **答案获取** | `dp[m][n]`（前缀的最优解） | `max(dp[i][j])`（任意位置结尾的最优解） |
| **初始化** | 需要初始化第一行/第一列 | 全部初始化为0即可 |
| **物理意义** | "前缀对前缀"的最优匹配 | "以当前位置结尾"的匹配长度 |

### 代码对比

**LCS（不相等时可跳过）**：
```cpp
if (s1[i-1] == s2[j-1]) {
    dp[i][j] = dp[i-1][j-1] + 1;
} else {
    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);  // 可以跳过某个字符
}
```

**最长公共子数组（不相等时直接断掉）**：
```cpp
if (nums1[i-1] == nums2[j-1]) {
    dp[i][j] = dp[i-1][j-1] + 1;
} else {
    dp[i][j] = 0;  // 不连续就直接断掉
}
```

### 关键理解

1. **状态定义的根本差异**：
   - LCS：前缀对前缀的最优解，可以跳过不匹配的字符。
   - 子数组：以当前位置结尾的匹配长度，一旦不匹配就归零。

2. **为什么状态定义不同**：
   - 子序列的"不连续"特性允许我们跳过字符，所以用前缀状态。
   - 子数组的"连续"特性要求匹配必须连续，所以用结尾状态。

3. **答案获取方式**：
   - LCS：`dp[m][n]` 就是最终答案（前缀的最优解）。
   - 子数组：需要在整个过程中维护最大值，因为最优解可能在任意位置结束。

4. **空间优化**：
   - LCS：需要两行（`prev` 和 `curr`）。
   - 子数组：只需要一行，因为只依赖对角线 `dp[i-1][j-1]`。

---

## 背包问题入门

### 1. 01背包问题

#### 题目模型
- 有 `n` 个物品，第 `i` 个物品重量为 `w[i]`，价值为 `v[i]`。
- 背包容量为 `W`。
- 每个物品**只能选一次**（选或不选）。
- 求：背包能装物品的最大总价值。

#### 思路框架（背包DP）

##### 1. 状态定义
- `dp[i][j]`：前 `i` 个物品，背包容量为 `j` 时，能获得的最大价值。
- 下标范围：`0 <= i <= n`, `0 <= j <= W`。
- 目标：`dp[n][W]`。

##### 2. 初始化
- `dp[0][j] = 0`：没有物品，价值为 0。
- `dp[i][0] = 0`：背包容量为 0，价值为 0。

##### 3. 状态转移
对第 `i` 个物品：

1. **不选第 `i` 个物品**：
   - 价值等于前 `i-1` 个物品在相同容量下的价值：
   - `dp[i][j] = dp[i-1][j]`。

2. **选第 `i` 个物品**（前提：`j >= w[i]`）：
   - 价值等于 `v[i]` + 剩余容量下前 `i-1` 个物品的价值：
   - `dp[i][j] = dp[i-1][j-w[i]] + v[i]`。

取最大值：
```text
if (j < w[i]) dp[i][j] = dp[i-1][j];
else dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);
```

##### 4. 遍历顺序
- `dp[i][j]` 依赖 `dp[i-1][j]` 和 `dp[i-1][j-w[i]]`，从上到下、从左到右填表。

### 我的代码尝试（01背包模板）

```cpp
// 01背包基础模板
int knapsack01(vector<int>& w, vector<int>& v, int W) {
    int n = w.size();
    vector<vector<int>> dp(n + 1, vector<int>(W + 1, 0));
    
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= W; ++j) {
            if (j < w[i-1]) {
                dp[i][j] = dp[i-1][j];  // 不选
            } else {
                dp[i][j] = max(dp[i-1][j], 
                               dp[i-1][j-w[i-1]] + v[i-1]);  // 选或不选
            }
        }
    }
    
    return dp[n][W];
}
```

### 空间优化（滚动数组）
观察到 `dp[i][j]` 只依赖第 `i-1` 行，可以用一维数组优化：

```cpp
int knapsack01_optimized(vector<int>& w, vector<int>& v, int W) {
    int n = w.size();
    vector<int> dp(W + 1, 0);
    
    for (int i = 1; i <= n; ++i) {
        // 注意：容量必须倒序遍历，避免重复使用物品
        for (int j = W; j >= w[i-1]; --j) {
            dp[j] = max(dp[j], dp[j-w[i-1]] + v[i-1]);
        }
    }
    
    return dp[W];
}
```

### 我的代码尝试（二维版本）

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(int stone : stones) sum += stone;
        
        int target = sum/2;
        int n = stones.size();
        
        // dp[i][j]:从前i块石头中选，凑成重量j的最大重量
        vector<vector<int>> dp(n + 1, vector<int>(target + 1, 0));
        
        // 填表
        for(int i = 1; i <= n; i++) {
            for(int j = 0; j <= target; j++) {
                // 不选第i块石头
                dp[i][j] = dp[i-1][j];
                
                // 选第i块石头(如果容量足够)
                if(j >= stones[i-1]) {
                    dp[i][j] = max(dp[i][j], dp[i-1][j-stones[i-1]] + stones[i-1]);
                } 
            }
        }
        
        int group1 = dp[n][target];  // 一组的最大重量
        int group2 = sum - group1;   // 另一组的重量
        return group2 - group1;      // 差值
    }
};
```

### 我的代码尝试（一维版本）

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for(int stone : stones) sum += stone;
        
        int target = sum/2;
        
        // dp[j]：容量为j的背包能装的最大重量
        vector<int> dp(target + 1, 0);
        
        // 01背包：倒序遍历确保每个石头只用一次
        for(int stone : stones) {
            for(int j = target; j >= stone; --j) {
                dp[j] = max(dp[j], dp[j-stone] + stone);
            }
        }
        
        int group1 = dp[target];  // 一组的最大重量
        int group2 = sum - group1; // 另一组的重量
        return group2 - group1;    // 差值
    }
};
```

### 复盘要点
- [ ] 能否将"石头碰撞"转化为"分组差值"问题：
  - 碰撞等价于分成两组互相抵消，最后剩下 `|group1 - group2|`
  - 要让差值最小，需要让两组重量尽可能接近
- [ ] 能否识别这是01背包问题：
  - 每块石头只能选一次（要么在第一组，要么在第二组）
  - 目标是找到最接近 `sum/2` 的组合
- [ ] 二维到一维的优化理解：
  - 二维：`dp[i][j]` 依赖 `dp[i-1][j]` 和 `dp[i-1][j-stone]`
  - 一维：`dp[j]` 依赖更新前的 `dp[j]` 和 `dp[j-stone]`
  - 倒序确保 `dp[j-stone]` 是"上一行"的数据，避免重复使用
- [ ] 存在性DP vs 最优值DP的区别：
  - 416题：存在性（`bool` + `||`）
  - 1049题：最优值（`int` + `max` + 具体重量）

---

## 2. 完全背包问题

### 题目模型
- 有 `n` 种物品，第 `i` 种物品重量为 `w[i]`，价值为 `v[i]`
- 背包容量为 `W`
- 每种物品**可以选无限次**
- 求：背包能装物品的最大总价值

### 与01背包的核心区别

| 项目 | 01背包 | 完全背包 |
|------|--------|----------|
| **物品选择次数** | 每个物品最多选1次 | 每个物品可以选无限次 |
| **状态转移** | `dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])` | `dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])` |
| **关键差异** | 依赖 `dp[i-1][j-w[i]]`（上一行） | 依赖 `dp[i][j-w[i]]`（当前行） |
| **遍历顺序** | 倒序遍历 | 正序遍历 |

### DP框架

#### 1. 状态定义
- `dp[i][j]`：前 `i` 种物品，背包容量为 `j` 时的最大价值
- 注意：是"前 `i` 种物品"，不是"前 `i` 个物品"

#### 2. 状态转移
对第 `i` 种物品：
```text
if (j < w[i]) dp[i][j] = dp[i-1][j];
else dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]);  // 注意是dp[i][j-w[i]]
```

#### 3. 空间优化
由于 `dp[i][j]` 依赖 `dp[i][j-w[i]]`（当前行），**正序遍历**：
```cpp
vector<int> dp(W + 1, 0);

for (int i = 0; i < n; ++i) {
    for (int j = w[i]; j <= W; ++j) {  // 正序遍历！
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

### 经典题目：LeetCode 322. 零钱兑换

#### 题目描述
给定不同面额的硬币 `coins` 和一个总金额 `amount`。计算可以凑成总金额的**最少硬币数量**。

#### 转化为完全背包
- **物品**：硬币面额 `coins[i]`
- **重量**：硬币面额 `coins[i]`
- **价值**：1（每个硬币贡献1个数量）
- **目标**：凑成金额 `amount` 的最小价值

#### 代码实现
```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, amount + 1);  // 初始化为最大值+1
        dp[0] = 0;
        
        for (int coin : coins) {
            for (int j = coin; j <= amount; ++j) {  // 正序遍历（完全背包）
                dp[j] = min(dp[j], dp[j - coin] + 1);
            }
        }
        
        return dp[amount] > amount ? -1 : dp[amount];
    }
};
```

### 关键理解点
- [ ] 为什么完全背包要**正序遍历**：
  - 正序允许 `dp[j-coin]` 包含当前硬币，实现重复使用
  - 倒序会限制每个硬币只用一次，变成01背包
- [ ] 最小值问题的初始化：
  - 初始化为 `amount + 1`（比可能的最大值还大）
  - `dp[0] = 0`：凑成金额0需要0个硬币
- [ ] 状态转移的物理意义：
  - `dp[j]`：不选当前硬币
  - `dp[j-coin] + 1`：选当前硬币，在之前基础上加1个

---

## 4. 牛客完全背包模板题（双问题）

### 题目描述
有n种物品，每种物品有无限多个，第i种物品体积为vi，价值为wi。
1. 背包至多能装多大价值？（不一定装满）
2. 背包恰好装满时，至多能装多大价值？

### dp含义的深度理解

#### 问题1：至多价值（允许不装满）
```cpp
// dp[j] = 容量为j的背包能获得的最大价值
vector<int> dp(V + 1, 0);  // 初始化为0，表示"什么都不装"是合法选择

for (int i = 0; i < n; ++i) {
    for (int j = v[i]; j <= V; ++j) {
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
```

**物理意义**：
- `dp[j]`：不选当前物品，保持原状
- `dp[j-v[i]] + w[i]`：选当前物品，用剩余容量的最优解 + 当前物品价值
- **允许空着**：背包可以有空余空间

#### 问题2：恰好装满（必须装满）
```cpp
// dp[j] = 容量为j的背包恰好装满时能获得的最大价值
vector<int> dp(V + 1, -INF);  // 初始化为负无穷，表示初始状态不可达
dp[0] = 0;  // 只有空背包可达

for (int i = 0; i < n; ++i) {
    for (int j = v[i]; j <= V; ++j) {
        if (dp[j - v[i]] != -INF) {  // 前提：剩余容量必须能恰好装满
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        }
    }
}
```

**物理意义**：
- `dp[j] = -∞`：当前容量j无法恰好装满
- `dp[j-v[i]] != -∞`：只有当剩余容量能恰好装满时，才能考虑选当前物品
- **必须装满**：背包不能有空余空间

### 两种问题的本质区别

| 项目 | 至多价值 | 恰好装满 |
|------|----------|----------|
| **思考角度** | "容量j最多装多少价值？" | "容量j如果必须装满，最多装多少价值？" |
| **可行性要求** | 部分装填允许 | 必须完全装填 |
| **初始化策略** | `dp[0..V] = 0`（所有状态可达） | `dp[0] = 0, dp[1..V] = -∞`（只有空背包可达） |
| **转移条件** | 无条件转移 | 需要 `dp[j-v[i]] != -∞` 才能转移 |

### 我的代码尝试（ACM模式）

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>

using namespace std;

const int INF = 0x3f3f3f3f;

// 问题1：背包至多能装多大价值（不一定装满）
int solveMaxValue(vector<int>& v, vector<int>& w, int V) {
    int n = v.size();
    vector<int> dp(V + 1, 0);  // 初始化为0，表示不装任何东西价值为0
    
    for (int i = 0; i < n; ++i) {
        for (int j = v[i]; j <= V; ++j) {  // 正序遍历（完全背包）
            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        }
    }
    
    return dp[V];  // 最大价值
}

// 问题2：背包恰好装满时，至多能装多大价值
int solveExactFull(vector<int>& v, vector<int>& w, int V) {
    int n = v.size();
    vector<int> dp(V + 1, -INF);  // 初始化为负无穷，表示不可达
    dp[0] = 0;  // 容量为0时价值为0（恰好装满）
    
    for (int i = 0; i < n; ++i) {
        for (int j = v[i]; j <= V; ++j) {  // 正序遍历（完全背包）
            if (dp[j - v[i]] != -INF) {  // 只有前面的状态可达才能转移
                dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
            }
        }
    }
    
    return dp[V] == -INF ? 0 : dp[V];  // 如果不可达返回0
}

int main() {
    int n, V;
    
    // 输入
    cin >> n >> V;
    
    vector<int> v(n), w(n);
    for (int i = 0; i < n; ++i) {
        cin >> v[i] >> w[i];
    }
    
    // 计算两个问题的答案
    int ans1 = solveMaxValue(v, w, V);
    int ans2 = solveExactFull(v, w, V);
    
    // 输出
    cout << ans1 << endl;
    cout << ans2 << endl;
    
    return 0;
}
```

### 复盘要点
- [ ] 能否区分"至多价值"和"恰好装满"：
  - 至多价值：允许背包有空余，初始化为0
  - 恰好装满：必须完全装满，初始化为-∞
- [ ] 理解dp数组的不同含义：
  - 问题1：`dp[j]` 是"容量j的最大价值"
  - 问题2：`dp[j]` 是"容量j恰好装满时的最大价值"
- [ ] 掌握-∞初始化的作用：
  - 标记不可达状态，防止错误转移
  - 确保只有真正能恰好装满的状态才有值
- [ ] 转移条件的理解：
  - 问题1：无条件转移（任何状态都可达）
  - 问题2：有条件转移（只有前驱状态可达才能转移）

---

## 3. 多重背包问题

### 题目模型
- 有 `n` 种物品，第 `i` 种物品重量为 `w[i]`，价值为 `v[i]`，数量为 `cnt[i]`
- 背包容量为 `W`
- 每种物品**最多选 `cnt[i]` 次**
- 求：背包能装物品的最大总价值

### 解决方案：二进制拆分
将多重背包转化为01背包：
- 把 `cnt[i]` 个物品拆分成：1, 2, 4, 8, ..., 剩余
- 例如：7个 = 1个 + 2个 + 4个
- 例如：10个 = 1个 + 2个 + 4个 + 3个

### 代码框架
```cpp
int multipleKnapsack(vector<int>& w, vector<int>& v, vector<int>& cnt, int W) {
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < w.size(); ++i) {
        int k = 1;
        while (k <= cnt[i]) {
            int weight = k * w[i];
            int value = k * v[i];
            
            // 用01背包处理拆分后的物品
            for (int j = W; j >= weight; --j) {
                dp[j] = max(dp[j], dp[j-weight] + value);
            }
            
            cnt[i] -= k;
            k *= 2;
        }
        
        // 处理剩余部分
        if (cnt[i] > 0) {
            for (int j = W; j >= cnt[i] * w[i]; --j) {
                dp[j] = max(dp[j], dp[j-cnt[i]*w[i]] + cnt[i]*v[i]);
            }
        }
    }
    
    return dp[W];
}
```

---

## 5. LeetCode 518. 零钱兑换 II（组合数问题）

### 题目描述
给定不同面额的硬币和一个总金额。计算可以凑成总金额的**硬币组合数**。

### 问题分析
- **物品**：硬币面额 `coins[i]`
- **重量**：硬币面额 `coins[i]`  
- **价值**：1（每个硬币贡献1种组合方式）
- **目标**：凑成金额 `amount` 的总组合数
- **关键**：完全背包 + 计数问题

### DP框架
```cpp
// dp[j] = 凑成金额j的组合数
vector<int> dp(amount + 1, 0);
dp[0] = 1;  // 凑成金额0有1种方式（空集）

// 组合数：外层遍历硬币，内层遍历金额
for (int coin : coins) {
    for (int j = coin; j <= amount; ++j) {
        dp[j] += dp[j - coin];
    }
}
```

### 关键理解：组合数 vs 排列数
- **组合数**：外层遍历硬币，内层遍历金额 → `1+2` 和 `2+1` 算同一种
- **排列数**：外层遍历金额，内层遍历硬币 → `1+2` 和 `2+1` 算不同种

### 为什么不需要检查可达性？
```cpp
dp[j] = dp[j] + dp[j - coin];
```
- 如果 `dp[j-coin] = 0`（不可达），则 `dp[j] = dp[j] + 0 = dp[j]`
- `0 + 0 = 0`，不会产生虚假计数
- 计数问题自动处理不可达状态

### 整数溢出处理
```cpp
// 防溢出版本（某些平台需要）
for (int coin : coins) {
    for (int j = coin; j <= amount; ++j) {
        if (dp[j] > INT_MAX - dp[j - coin]) continue;  // 防止溢出
        dp[j] += dp[j - coin];
    }
}
```

### 我的代码尝试（防溢出版本）

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;  // 凑成金额0有1种方式（空集）
        
        // 组合数：外层遍历硬币，内层遍历金额
        for (int coin : coins) {
            for (int j = coin; j <= amount; ++j) {
                // 防止整数溢出（某些平台严格检查）
                if (dp[j] > INT_MAX - dp[j - coin]) continue;
                dp[j] += dp[j - coin];
            }
        }
        
        return dp[amount];
    }
};
```

### 复盘要点
- [ ] 能否识别这是计数问题：
  - 求"组合数"不是"最值"，用加法不是max/min
  - 初始化 `dp[0] = 1`（空集是一种有效组合）
- [ ] 理解组合数的遍历顺序：
  - 外层硬币，内层金额 → 确保组合不重复
  - 避免了 `1+2` 和 `2+1` 的重复计算
- [ ] 掌握计数问题的可达性处理：
  - 无需检查可达性，`0 + 0 = 0` 不产生虚假计数
  - 与最大值问题的 `-∞` 处理形成对比
- [ ] 整数溢出的防范：
  - 某些平台对溢出检查严格，需要预先判断
  - 题目保证结果在int范围内，但中间过程可能溢出
