# Day46-11.17-两个数组DP进阶

## 44. 两个数组的 DP 问题：通配符匹配

### 题目小结
- 输入：字符串 `s`（文本）、`p`（模式，包含普通字符、`?`、`*`）。
- 规则：
  - `?` 可以匹配任意单个字符。
  - `*` 可以匹配任意长度的字符串（包含空串）。
- 输出：模式 `p` 是否能**完整匹配**整个 `s`（返回 true/false）。

### 思路框架（前缀匹配 DP）

#### 1. 状态定义
- `m = s.length()`, `n = p.length()`。
- `dp[i][j]` 表示：`p` 的前 `j` 个字符，是否能匹配上 `s` 的前 `i` 个字符。
- 下标范围：`0 <= i <= m`, `0 <= j <= n`，带空前缀。
- 目标：`dp[m][n]`。

#### 2. 初始化
- `dp[0][0] = true`：空模式匹配空串。
- `dp[i][0] = false` 对 `i > 0`：空模式无法匹配非空文本。
- `dp[0][j]`（非空模式匹配空串）：
  - 只能依靠 `*`，因为 `*` 可以匹配空串：
  - 若 `p[j-1] == '*'`，则 `dp[0][j] = dp[0][j-1]`；否则 `dp[0][j] = false`。

#### 3. 状态转移

- 情况一：`p[j-1]` 是普通字符或 `?`
  - 条件：`p[j-1] == s[i-1]` 或 `p[j-1] == '?'`。
  - 要求「当前字符能对上」且「前面的前缀已经匹配」：
    - `dp[i][j] = dp[i-1][j-1]`。

- 情况二：`p[j-1] == '*'`
  - `*` 可以匹配任意长度（含 0）：
  - 1）`*` 匹配空串：相当于“不用这个 `*`”：
    - `dp[i][j-1]`
  - 2）`*` 匹配至少一个字符：让 `*` 吃掉 `s[i-1]`，模式仍停在当前 `*`，文本往前挪：
    - `dp[i-1][j]`
  - 综合：`dp[i][j] = dp[i][j-1] || dp[i-1][j]`。

#### 4. 遍历顺序
- 依赖关系：`dp[i][j]` 依赖 `dp[i-1][j-1]`、`dp[i][j-1]`、`dp[i-1][j]`。
- 遍历：
  - 先处理 `dp[0][j]`（j 从 1 到 n）。
  - 再对 `i = 1..m`、`j = 1..n` 双重循环填表。

### 我的代码尝试（AC 版本）
```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        // dp[i][j]：p 的前 j 个字符能否匹配 s 的前 i 个字符
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));

        // 初始化
        dp[0][0] = true;
        for (int i = 1; i <= m; i++) {
            dp[i][0] = false;
        }
        for (int j = 1; j <= n; j++) {
            if (p[j - 1] == '*') {           // 非空模式匹配空串只能靠连续的 *
                dp[0][j] = dp[0][j - 1];
            } else {
                dp[0][j] = false;
            }
        }

        // 状态转移填表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p[j - 1] != '*' && (p[j - 1] == s[i - 1] || p[j - 1] == '?')) {
                    // 情况1：普通字符或 '?'
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (p[j - 1] == '*') {
                    // 情况2：'*' 可以匹配空串或若干字符
                    // 1. 匹配空串：dp[i][j-1]
                    // 2. 匹配至少一个字符：dp[i-1][j]
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                } else {
                    dp[i][j] = false;
                }
            }
        }
        return dp[m][n];
    }
};
```

### 复盘要点
- [ ] 能否熟练写出 `dp[i][j]` 的语义：**模式前缀 vs 文本前缀的匹配关系**？
- [ ] 空串匹配的初始化是否记牢：
  - `dp[0][0] = true`，`dp[i>0][0] = false`，`dp[0][j]` 只在前缀全为 `*` 时可能为 true。
- [ ] `*` 的两种用法是否清晰：
  - 匹配空串 → `dp[i][j-1]`。
  - 匹配若干字符 → `dp[i-1][j]`。
- [ ] 这类「匹配型 DP」和 LCS / 不同的子序列的区别：
  - 这里 `dp` 存的是 **布尔匹配结果**，不是长度或方案数。

---

## 45. 两个数组的 DP 问题：正则表达式匹配

### 题目小结
- 输入：字符串 `s`（文本）、`p`（模式，包含普通字符、`.`、`*`）。
- 规则：
  - `.` 匹配任意单个字符。
  - `*` 匹配**前一个字符**的任意次重复（可以 0 次）。
- 输出：`p` 是否能**完整匹配**整个 `s`（返回 true/false）。

### 思路框架（匹配型双序列前缀 DP）

#### 1. 状态定义
- `m = len(s)`, `n = len(p)`。
- `dp[i][j]`：`p` 的前 `j` 个字符，是否能匹配 `s` 的前 `i` 个字符。
- 下标范围：`0 <= i <= m`, `0 <= j <= n`。
- 目标：`dp[m][n]`。

和 44 题一样，本质是「模式前缀 vs 文本前缀」的布尔 DP，只是 `*` 的语义变成了「重复前一个字符」。

#### 2. 初始化
- `dp[0][0] = true`：空模式匹配空串。
- `dp[i>0][0] = false`：空模式无法匹配非空文本。
- `dp[0][j]`：非空模式匹配空串——只能依靠若干个 `x*` 组合成的模式，例如 `a*b*c*`：
  - 当 `p[j-1] == '*'` 时：
    - 可以把这一对 `x*` 当成空串：`dp[0][j] = dp[0][j-2]`。
  - 否则为 `false`。

#### 3. 状态转移

按最后一个模式字符分类：

1. `p[j-1] != '*'`（普通字符或 `.`）：
   - 当前字符能匹配：`p[j-1] == s[i-1]` 或 `p[j-1] == '.'`。
   - 则要求前缀也匹配：`dp[i][j] = dp[i-1][j-1]`。
   - 否则 `dp[i][j] = false`。

2. `p[j-1] == '*'`（和前一个字符 `p[j-2]` 绑定成一对 `x*`）：
   - **用 0 次**：整个 `x*` 当成没出现过，模式向左跳过 2 个字符：
     - `dp[i][j] |= dp[i][j-2]`。
   - **用 ≥ 1 次**：让 `x*` 吃掉一个 `s[i-1]`，模式保持在这对 `x*`，文本向前挪：
     - 前提：`p[j-2]` 能和 `s[i-1]` 匹配（`p[j-2] == s[i-1]` 或 `p[j-2] == '.'`）。
     - 若能匹配：`dp[i][j] |= dp[i-1][j]`。

两个分支本质是：
- 「不用这个模块」 vs 「继续用这个模块吃字符」，对应存在性 DP 中典型的 `||` 转移。

#### 4. 遍历顺序
- 先初始化第一行 `dp[0][j]`。
- 再对 `i = 1..m`、`j = 1..n` 双重循环填表。

### 我的代码尝试（AC 版本 C++）

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        // dp[i][j]：p 的前 j 个字符能否匹配 s 的前 i 个字符
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));

        // 1. 空串 vs 空模式
        dp[0][0] = true;

        // 2. 初始化第一行：s 为空串，p 非空
        // 只有由若干个 x* 组成的前缀，才可能匹配空串
        for (int j = 2; j <= n; ++j) {
            if (p[j - 1] == '*') {
                dp[0][j] = dp[0][j - 2];
            }
        }

        // 3. 状态转移
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j - 1] != '*') {
                    // 当前是普通字符或 '.'，只能匹配一个字符
                    if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {
                        dp[i][j] = dp[i - 1][j - 1];
                    } else {
                        dp[i][j] = false;
                    }
                } else {
                    // 当前是 '*'，与前一个字符 p[j-2] 绑定成一对 x*
                    // 1）x* 用 0 次：整体删掉这一对
                    dp[i][j] = dp[i][j - 2];

                    // 2）x* 用 ≥ 1 次：多吃一个 s[i-1]
                    if (p[j - 2] == s[i - 1] || p[j - 2] == '.') {
                        dp[i][j] = dp[i][j] || dp[i - 1][j];
                    }
                }
            }
        }

        return dp[m][n];
    }
};
```

### 复盘要点
- [ ] 牢牢记住本题和 44 题的区别：
  - 44：`*` 是独立通配符，直接 `dp[i][j] = dp[i][j-1] || dp[i-1][j]`。
  - 45：`*` 是重复前一个字符的操作符，必须和 `p[j-2]` 绑成 `x*`，转移为 `dp[i][j-2]` 和 `dp[i-1][j]`。
- [ ] 能否用「最后一步怎么用这个模块」来推导：
  - 不用 x*（0 次） → 删掉模块。
  - 用 x*（≥1 次） → 吃字符、停在原位继续用。
- [ ] 空串匹配的条件是否清楚：只能由若干个 `x*` 块组成的前缀（`a*b*c*`）才能匹配空串。
- [ ] 是否能在脑中把 44 / 45 两题的 `*` 语义和转移公式一一对应记住？

---

## 46. 两个数组的 DP 问题：交错字符串

### 题目小结
- 输入：三个字符串 `s1`, `s2`, `s3`。
- 规则：判断 `s3` 是否能由 `s1` 和 `s2` **交错**组成，即保持 `s1` 和 `s2` 各自内部的字符相对顺序，但可以互相穿插。
- 输出：`true` / `false`。

### 思路框架（匹配型双序列前缀 DP）

#### 1. 状态定义
- `m = len(s1)`, `n = len(s2)`。
- `dp[i][j]`：用 `s1` 的前 `i` 个字符 + `s2` 的前 `j` 个字符，能否交错组成 `s3` 的前 `i + j` 个字符。
- 下标范围：`0 <= i <= m`, `0 <= j <= n`。
- 目标：`dp[m][n]`。

#### 2. 初始化
- `dp[0][0] = true`：两个空串能组成空串。
- **第一行**（`i = 0`）：只用 `s2` 的前 `j` 个字符组成 `s3` 的前 `j` 个字符。
  - 需要 `s2[0..j-1]` 和 `s3[0..j-1]` 逐个字符相等。
  - 转移：`dp[0][j] = dp[0][j-1] && s2[j-1] == s3[j-1]`。
- **第一列**（`j = 0`）：只用 `s1` 的前 `i` 个字符组成 `s3` 的前 `i` 个字符。
  - 需要 `s1[0..i-1]` 和 `s3[0..i-1]` 逐个字符相等。
  - 转移：`dp[i][0] = dp[i-1][0] && s1[i-1] == s3[i-1]`。

#### 3. 状态转移
核心问题：`s3` 的第 `i + j` 个字符，是来自 `s1` 的第 `i` 个字符，还是 `s2` 的第 `j` 个字符？

- **来自 `s1`**：  
  如果 `s1[i-1] == s3[i+j-1]` 并且 `dp[i-1][j]` 为 true，则 `dp[i][j] = true`。
- **来自 `s2`**：  
  如果 `s2[j-1] == s3[i+j-1]` 并且 `dp[i][j-1]` 为 true，则 `dp[i][j] = true`。

只要有一条可行，`dp[i][j]` 就是 true：

```text
dp[i][j] = (s1[i-1] == s3[i+j-1] && dp[i-1][j]) 
        || (s2[j-1] == s3[i+j-1] && dp[i][j-1])
```

#### 4. 遍历顺序
- `dp[i][j]` 依赖 `dp[i-1][j]` 和 `dp[i][j-1]`，所以从左到右、从上到下填表即可。

### 我的代码尝试（AC 版本 C++）

```cpp
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        int m = s1.size(), n = s2.size();
        if (m + n != s3.size()) return false;  // 长度必须相等

        // dp[i][j]：s1前i个 + s2前j个 能否组成 s3前 i+j 个
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));

        // 1. 初始化
        dp[0][0] = true;
        // 第一行：只用 s2
        for (int j = 1; j <= n; ++j) {
            dp[0][j] = dp[0][j-1] && (s2[j-1] == s3[j-1]);
        }
        // 第一列：只用 s1
        for (int i = 1; i <= m; ++i) {
            dp[i][0] = dp[i-1][0] && (s1[i-1] == s3[i-1]);
        }

        // 2. 状态转移填表
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                dp[i][j] = (s1[i-1] == s3[i+j-1] && dp[i-1][j]) 
                        || (s2[j-1] == s3[i+j-1] && dp[i][j-1]);
            }
        }

        return dp[m][n];
    }
};
```

### 复盘要点
- [ ] 能否熟练写出 `dp[i][j]` 的语义：**s1前i个 + s2前j个 → s3前i+j个**？
- [ ] 初始化是否清楚：
  - `dp[0][0] = true`，第一行/第一列必须逐个字符匹配。
- [ ] 转移公式的两种来源是否理解：
  - 来自 `s1`：`s1[i-1] == s3[i+j-1] && dp[i-1][j]`。
  - 来自 `s2`：`s2[j-1] == s3[i+j-1] && dp[i][j-1]`。
- [ ] 是否能看出这题和 44/45 的共性：
  - 都是「前缀匹配 DP」，只是这里有两个源串和一个目标串。
  - 都是布尔型 DP，用 `||` 合并多条路径。

---

## 47. 两个数组的 DP 问题：最小 ASCII 删除和

### 题目小结
- 输入：两个字符串 `s1`、`s2`。
- 操作：可以删除任意一个串中的任意字符，代价为该字符的 ASCII 值。
- 目标：通过若干次删除，使两个字符串相等，**总删除代价最小**，返回这个最小代价。

可以理解为在两个串上做“删字符”的最小代价 DP，也可以理解为：

> 保留一个公共子序列，其余字符全部删掉，使删除的 ASCII 总和最小。

### 思路框架（前缀双序列 DP，最优值型）

#### 1. 状态定义
- `m = len(s1)`, `n = len(s2)`。
- `dp[i][j]`：让 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符变得相等所需的**最小删除代价和**。
- 下标范围：`0 <= i <= m`, `0 <= j <= n`。
- 目标：`dp[m][n]`。

#### 2. 初始化
- `dp[0][0] = 0`：两个空串已经相等，不需要删除。
- 第一列 `dp[i][0]`：`s2` 为空串，只能把 `s1` 的前 `i` 个全部删掉：
  - `dp[i][0] = dp[i-1][0] + s1[i-1]`.
- 第一行 `dp[0][j]`：`s1` 为空串，只能把 `s2` 的前 `j` 个全部删掉：
  - `dp[0][j] = dp[0][j-1] + s2[j-1]`.

#### 3. 状态转移

看 `s1[i-1]` 和 `s2[j-1]`：

1. 字符相等：
   - 不需要删除这两个字符，继承前缀代价：
   - `dp[i][j] = dp[i-1][j-1]`.

2. 字符不等：必须删掉其中一个：
   - 删 `s1[i-1]`：代价 = `dp[i-1][j] + s1[i-1]`.
   - 删 `s2[j-1]`：代价 = `dp[i][j-1] + s2[j-1]`.
   - 取较小者：

   ```text
   dp[i][j] = min(dp[i-1][j] + s1[i-1],
                  dp[i][j-1] + s2[j-1])
   ```

#### 4. 遍历顺序
- 依赖 `dp[i-1][j-1]`、`dp[i-1][j]`、`dp[i][j-1]`，从上到下、从左到右填表即可。

### 我的代码尝试（AC 版本 C++）

```cpp
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int m = s1.size(), n = s2.size();
        // dp[i][j]：s1前i个 和 s2前j个 相等的最小删除代价
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        // 1. 初始化
        dp[0][0] = 0;
        // 第一列：s2 为空，只能删 s1
        for (int i = 1; i <= m; ++i) {
            dp[i][0] = dp[i-1][0] + s1[i-1];
        }
        // 第一行：s1 为空，只能删 s2
        for (int j = 1; j <= n; ++j) {
            dp[0][j] = dp[0][j-1] + s2[j-1];
        }

        // 2. 状态转移
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (s1[i-1] == s2[j-1]) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = min(dp[i-1][j] + s1[i-1],
                                   dp[i][j-1] + s2[j-1]);
                }
            }
        }

        return dp[m][n];
    }
};
```

### 复盘要点
- [ ] 能否熟练写出 `dp[i][j]` 的语义：**让 s1 前 i 个、s2 前 j 个相等的最小删除代价**？
- [ ] 初始化是否清楚：
  - 第一列 = 删光 `s1[0..i-1]` 的 ASCII 和；第一行 = 删光 `s2[0..j-1]` 的 ASCII 和。
- [ ] 转移是否理解：
  - 相等就继承 `dp[i-1][j-1]`，不等就「删左边」vs「删上边」取较小。
- [ ] 能否把本题和 LCS 联系起来：
  - 也可以先求「公共子序列的最大 ASCII 和」，答案 = 总和 - 2 * 公共部分的 ASCII 和.
