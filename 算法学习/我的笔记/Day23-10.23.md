# Day23 - 递归专题 (10.23)

## 今日目标
掌握递归的三要素：递归出口、子问题划分、结果组合

## 题目列表
1. 面试题 08.06 - 汉诺塔 (easy)
2. LeetCode 21 - 合并两个有序链表 (easy)
3. LeetCode 206 - 反转链表 (easy)
4. LeetCode 50 - Pow(x, n) - 快速幂 (medium)
5. LeetCode 129 - 求根节点到叶节点数字之和 (medium)

---

## 1. 面试题 08.06 - 汉诺塔

### 题目描述
在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
- (1) 每次只能移动一个盘子;
- (2) 盘子只能从柱子顶端滑出移到下一根柱子;
- (3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

**示例1:**
```
输入：A = [2, 1, 0], B = [], C = []
输出：C = [2, 1, 0]
```

**示例2:**
```
输入：A = [1, 0], B = [], C = []
输出：C = [1, 0]
```

### 解题思路
**递归三要素分析**：
1. **递归函数含义**：将A柱顶部的n个盘子移动到C柱（可以借助B柱）
2. **递归出口**：当n=1时，直接把盘子从A移到C
3. **子问题划分**：
   - 把A顶部的n-1个盘子移到B（借助C）
   - 把A最大的盘子移到C
   - 把B的n-1个盘子移到C（借助A）

**关键理解**：
- 移动n个盘子 = 移动n-1个小盘子 + 移动1个大盘子 + 移动n-1个小盘子
- 递归函数的参数顺序很重要：dfs(起点, 辅助, 终点, 数量)

### 初始代码/错误代码

**错误1：移动盘子后没有从原柱子删除**
```cpp
class Solution {
public:
    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        dfs(A, B, C, A.size());
    }
    
    void dfs(vector<int>& A, vector<int>& B, vector<int>& C, int n) {
        if(n == 1) C.push_back(A.back());  // 只放入C，没有从A删除
        
        dfs(A, C, B, n-1);
        C.push_back(A.back());  // 只放入C，没有从A删除
        dfs(B, A, C, n-1);
    }
};
```

**错误2：递归出口没有return**
```cpp
class Solution {
public:
    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        dfs(A, B, C, A.size());
    }
    
    void dfs(vector<int>& A, vector<int>& B, vector<int>& C, int n) {
        if(n == 1) 
        {
            C.push_back(A.back());
            A.pop_back();
            // 缺少 return，会继续执行后面的代码！
        }
        
        dfs(A, C, B, n-1);  // n-1 = 0，访问空容器
        C.push_back(A.back());
        A.pop_back();
        dfs(B, A, C, n-1);
    }
};
```

### 错误分析

**错误1**：移动盘子只 `push_back` 没有 `pop_back`
- **现象**：盘子被"复制"了，原柱子还保留着
- **原因**：移动 = 从起点删除 + 放入终点，两步缺一不可
- **修复**：加上 `A.pop_back()`

**错误2**：递归出口没有 `return`
- **现象**：运行时错误，访问空容器
- **原因**：执行完 `if(n == 1)` 后继续执行后面的递归调用 `dfs(..., 0)`，当n=0时访问 `A.back()` 出错
- **修复**：在递归出口加 `return`

**核心教训**：
1. 操作数据结构要"成对"：`push_back` 配 `pop_back`
2. 递归出口处理完后一定要 `return`，否则会继续执行后面的代码

### 正确代码
```cpp
class Solution {
public:
    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        dfs(A, B, C, A.size());
    }
    
    void dfs(vector<int>& A, vector<int>& B, vector<int>& C, int n) {
        // 递归出口：只有1个盘子，直接移动
        if(n == 1) 
        {
            C.push_back(A.back());
            A.pop_back();
            return;  // 关键：必须return
        }
        
        // 1. 把A顶部的n-1个盘子移到B（借助C）
        dfs(A, C, B, n - 1);
        
        // 2. 把A最大的盘子移到C
        C.push_back(A.back());
        A.pop_back();
        
        // 3. 把B的n-1个盘子移到C（借助A）
        dfs(B, A, C, n - 1);
    }
};
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：0 ms
- 内存消耗：符合预期

---

## 2. LeetCode 21 - 合并两个有序链表

### 题目描述
将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例 1：**
```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

**示例 2：**
```
输入：l1 = [], l2 = []
输出：[]
```

**示例 3：**
```
输入：l1 = [], l2 = [0]
输出：[0]
```

### 解题思路
**递归三要素分析**：
1. **递归函数含义**：合并两个有序链表，返回合并后的头节点
2. **递归出口**：
   - 如果 list1 为空，返回 list2
   - 如果 list2 为空，返回 list1
3. **子问题划分**：
   - 比较两个链表的头节点，选择较小的作为合并后的头节点
   - 将选中节点的 next 指向剩余链表的合并结果（递归调用）

**关键理解**：
- 每次选择较小的头节点
- 剩下的部分交给递归处理
- 递归自动完成链表的拼接

### 初始代码/错误代码

**错误代码：两处致命bug**
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        return dfs(list1, list2);
    }
    
    ListNode* dfs(ListNode* list1, ListNode* list2) {
        if(list2 == nullptr) return list1;
        if(list1 == nullptr) return list2;

        if(list1->val <= list2->val) 
        {
            list1->next == dfs(list1->next, list2);  // Bug1: == 应该是 =
            return list1;
        }
        else 
        {
            list2->next == dfs(list2->next, list2);  // Bug1: == 应该是 =
                                                      // Bug2: 参数错误
            return list2;
        }
    }
};
```

### 错误分析

**错误1**：使用了比较运算符 `==` 而不是赋值运算符 `=`
- **现象**：超出时间限制，无限递归
- **原因**：
  - `list1->next == dfs(...)` 是**比较运算**，不会修改 `list1->next`
  - 链表结构没有改变，下次递归还是相同的节点
  - 导致无限递归，超时
- **修复**：`==` 改为 `=`

**错误2**：递归参数错误
- **代码**：`dfs(list2->next, list2)`
- **问题**：选择了 list2 作为头节点后
  - list2 已经被使用，应该传 `list2->next`（✓）
  - list1 还没使用，应该传 `list1`（✗ 写成了 list2）
- **修复**：`dfs(list2->next, list2)` → `dfs(list1, list2->next)`

**核心教训**：
1. **赋值 vs 比较**：`=` 是赋值，`==` 是比较，容易混淆
2. **递归参数**：选中哪个节点，就把它的 next 传入递归，另一个保持不变
3. **对称性**：if 和 else 分支的逻辑要对称

### 正确代码
```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        return dfs(list1, list2);
    }
    
    ListNode* dfs(ListNode* list1, ListNode* list2) {
        // 递归出口：某个链表为空
        if(list2 == nullptr) return list1;
        if(list1 == nullptr) return list2;

        // 选择较小的节点作为头节点
        if(list1->val <= list2->val) 
        {
            list1->next = dfs(list1->next, list2);  // 关键：= 不是 ==
            return list1;
        }
        else 
        {
            list2->next = dfs(list1, list2->next);  // 关键：参数顺序
            return list2;
        }
    }
};
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：递归调用栈深度 O(m+n)

---

## 3. LeetCode 206 - 反转链表

### 题目描述
给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**
```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

**示例 2：**
```
输入：head = [1,2]
输出：[2,1]
```

**示例 3：**
```
输入：head = []
输出：[]
```

### 解题思路

**方法对比**：
- **方法1**：递归 + 头插法（使用虚拟头节点）
- **方法2**：标准递归（推荐，面试常考）

**标准递归思路**：
1. **递归函数含义**：反转以head为头的链表，返回反转后的头节点
2. **递归出口**：head为空或只有一个节点，直接返回head
3. **递归子问题**：
   - 假设head.next后面的链表已经反转完成
   - 得到新头节点newHead
   - 反转head和head.next的指针
   - 返回newHead

**核心操作**：
```
原链表：1 → 2 → 3 → 4 → null
假设2→3→4已反转：1 → 2 ← 3 ← 4

反转1和2的指针：
  head.next.next = head  // 2.next = 1
  head.next = null       // 1.next = null
  
结果：4 → 3 → 2 → 1 → null
```

**关键理解**：
- 递归从后往前处理，每层反转当前节点和下一个节点的指针
- 新头节点在最底层确定后，一直向上传递
- 每层都返回同一个newHead（与合并链表不同！）

### 正确代码

**方法2：标准递归（推荐）**
```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        // 递归出口
        if(head == nullptr || head->next == nullptr) 
            return head;
        
        // 递归反转后面的链表，得到新头节点
        ListNode* newHead = reverseList(head->next);
        
        // 反转当前节点和下一个节点的指针
        head->next->next = head;
        head->next = nullptr;
        
        return newHead;  // 返回新头节点（不是head！）
    }
};
```

### 核心知识点

**递归返回值传递机制**：
- 合并链表：每层返回**当前选中的节点**（不同），逐层构建
- 反转链表：每层返回**新头节点**（相同），传递引用

**为什么返回newHead而不是head？**
```
处理节点1时：
- head = 1（当前节点）
- newHead = 4（反转后的头节点，从递归返回）
- 我们要的是反转后的头节点4，不是当前节点1
```

**递归回溯过程**：
```
1 → 2 → 3 → 4
递归调用到底：
  reverseList(4) 返回 4
回溯处理3：
  3.next.next = 3 → 4.next = 3
  3.next = null
  返回 4
回溯处理2：
  2.next.next = 2 → 3.next = 2
  2.next = null
  返回 4
回溯处理1：
  1.next.next = 1 → 2.next = 1
  1.next = null
  返回 4
最终：4 → 3 → 2 → 1 → null
```

### 提交结果
- 提交时间：AC ✅
- 执行用时：符合预期
- 内存消耗：O(n) 递归栈

---

## 4. LeetCode 50 - Pow(x, n) - 快速幂

### 题目描述
实现 `pow(x, n)` ，即计算 `x` 的整数 `n` 次幂函数（即，x^n）。

**示例 1：**
```
输入：x = 2.00000, n = 10
输出：1024.00000
```

**示例 2：**
```
输入：x = 2.10000, n = 3
输出：9.26100
```

**示例 3：**
```
输入：x = 2.00000, n = -2
输出：0.25000
解释：2^-2 = 1/2^2 = 1/4 = 0.25
```

### 解题思路

**初始思路（暴力递归）**：
```cpp
x^n = x * x^(n-1)  // 递归n次，时间复杂度O(n)
```
- 问题：当n很大（如2^31）时会超时

**优化思路（快速幂）**：
```
利用分治思想减少乘法次数

如果n是偶数：x^n = (x^(n/2))^2
如果n是奇数：x^n = x * (x^(n/2))^2

示例：2^10
  2^10 = (2^5)^2
  2^5 = 2 * (2^2)^2
  2^2 = (2^1)^2
  2^1 = 2 * (2^0)^2
  2^0 = 1

递归深度：log₂(10) ≈ 4层（而不是10层）
时间复杂度：O(log n)
```

**处理负数指数**：
- 如果n<0，计算x^(-n)，然后返回1.0/result
- 注意：abs(INT_MIN)会溢出，要用long long

### 初始代码/错误代码

**错误1：暴力递归，超时**
```cpp
double dfs(double x, int n)
{
    if(n == 0) return 1;
    return x * dfs(x, n-1);  // O(n) 会超时
}
```

**错误2：abs溢出**
```cpp
int n = -2147483648;  // INT_MIN
n = abs(n);  // 溢出！因为INT_MAX = 2147483647
```

**错误3：重复计算**
```cpp
double result1 = dfs(x, n);
double result2 = 1.0 / dfs(x, n);  // 计算了两次
```

### 错误分析

**时间复杂度问题**：
- 暴力：`x^1000000000` 需要10亿次递归 ❌
- 快速幂：只需要30次递归 ✅

**溢出问题**：
- `int` 范围：-2147483648 ~ 2147483647
- `abs(-2147483648) = 2147483648` 超出范围
- 解决：用 `long long`

**核心优化**：
- 每次递归减半 → O(log n)
- 先算一半，再平方组合

### 正确代码
```cpp
class Solution {
public:
    double myPow(double x, int n) {
        long long N = n;  // 避免abs溢出
        
        if(N >= 0) 
            return dfs(x, N);
        else 
            return 1.0 / dfs(x, -N);
    }
    
    double dfs(double x, long long n)
    {
        // 递归出口
        if(n == 0) return 1;
        
        // 快速幂：先算一半
        double half = dfs(x, n / 2);
        
        // 根据奇偶性组合结果
        if(n % 2 == 0)  // 偶数
            return half * half;
        else            // 奇数
            return x * half * half;
    }
};
```

### 核心知识点

**快速幂原理**：
```
2^10 的计算过程：

暴力：2*2*2*2*2*2*2*2*2*2 (9次乘法)

快速幂：
  half = 2^5
  return half * half

  half = 2^2 (2^5是奇数，额外乘一个2)
  return 2 * half * half

  half = 2^1
  return half * half

  half = 2^0 = 1
  return 2 * half * half = 2

回溯：
  2^2 = 2*2 = 4
  2^5 = 2*4*4 = 32
  2^10 = 32*32 = 1024

只用了4次乘法！
```

**分治思想**：
- 将大问题分解成规模减半的子问题
- 递归深度：log₂(n)
- 与二分查找类似

### 提交结果
- 提交时间：AC ✅
- 执行用时：0 ms
- 内存消耗：O(log n) 递归栈

---

## 5. LeetCode 129 - 求根节点到叶节点数字之和

### 题目描述
给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：
- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的所有数字之和。

叶节点是指没有子节点的节点。

**示例 1：**
```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

**示例 2：**
```
输入：root = [4,9,0,5,1]
输出：1026
解释：
从根到叶子节点路径 4->9->5 代表数字 495
从根到叶子节点路径 4->9->1 代表数字 491
从根到叶子节点路径 4->0 代表数字 40
因此，数字总和 = 495 + 491 + 40 = 1026
```

### 解题思路

**核心理解**：
- 路径 `1→2→5` 不是 `1+2+5=8`
- 而是数字 `125`（一百二十五）

**数字构造方法**：
```
从根到当前节点的数字构造：
初始：num = 0
到节点1：num = 0*10 + 1 = 1
到节点2：num = 1*10 + 2 = 12
到节点5：num = 12*10 + 5 = 125
```

**递归设计**：
1. **递归函数**：`int dfs(TreeNode* root, int num)`
   - `root`：当前节点
   - `num`：从根到父节点的数字
   - 返回：以root为根的子树所有路径数字之和

2. **递归出口**：
   - 空节点：返回0
   - 叶子节点：返回当前路径的完整数字

3. **递归逻辑**：
   - 计算当前数字：`current = num*10 + root->val`
   - 如果是叶子节点：返回current
   - 否则：返回左右子树的和

### 初始代码/错误代码

**错误理解：把路径当成加法**
```cpp
class Solution {
public:
    int Num = 0;
    int sumNumbers(TreeNode* root) {
        if(root->left == nullptr && root->right == nullptr) 
            return root->val;
        
        Num += root->val;  // ❌ 错误：直接相加节点值
        if(root->left) Num += sumNumbers(root->left);
        if(root->right) Num += sumNumbers(root->right);
        return Num;
    }
};
```

**问题分析**：
```
对于树：  1
         / \
        2   3

错误代码计算：1 + 2 + 3 = 6
正确答案：12 + 13 = 25

路径1→2不是"1+2=3"，而是数字"12"！
```

### 错误分析

**错误点**：
1. 没有理解"路径代表数字"的含义
2. 没有使用 `num*10 + val` 构造数字
3. 没有传递父节点的数字信息

**正确思路**：
- 需要一个参数传递"从根到父节点的数字"
- 每到一个新节点，数字要"进位"：`num*10 + current`

### 正确代码
```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }
    
    int dfs(TreeNode* root, int num)
    {
        // 递归出口1：空节点
        if(root == nullptr) return 0;
        
        // 计算从根到当前节点的数字
        int current = num * 10 + root->val;
        
        // 递归出口2：叶子节点
        if(root->left == nullptr && root->right == nullptr) 
            return current;
        
        // 非叶子节点：递归左右子树，返回和
        int leftSum = dfs(root->left, current);
        int rightSum = dfs(root->right, current);
        
        return leftSum + rightSum;
    }
};
```

### 核心知识点

**递归参数传递信息**：
```
       1 (num=0)
      / \
     2   3
    /
   5

dfs(1, 0):
  current = 0*10 + 1 = 1
  left = dfs(2, 1)
    current = 1*10 + 2 = 12
    left = dfs(5, 12)
      current = 12*10 + 5 = 125
      是叶子，返回 125
    right = dfs(null, 12) = 0
    返回 125 + 0 = 125
  right = dfs(3, 1)
    current = 1*10 + 3 = 13
    是叶子，返回 13
  返回 125 + 13 = 138
```

**数学构造技巧**：
- 十进制数字构造：`num = num*10 + digit`
- 类似题目：二进制数字构造：`num = num*2 + digit`

**递归传参的作用**：
- 向下传递"父节点的累积信息"
- 每层基于父节点信息计算当前层
- 这是树递归中常用的技巧

### 提交结果
- 提交时间：AC ✅
- 执行用时：0 ms
- 内存消耗：O(h) 递归栈，h为树高

---

## 今日总结

### 完成情况
✅ **5道题全部AC！**
1. 面试题 08.06 - 汉诺塔 (easy) ✅
2. LeetCode 21 - 合并两个有序链表 (easy) ✅
3. LeetCode 206 - 反转链表 (easy) ✅
4. LeetCode 50 - Pow(x, n) (medium) ✅
5. LeetCode 129 - 求根节点到叶节点数字之和 (medium) ✅

### 核心知识点

#### 1. 递归三要素（每题必问自己）
- **递归函数含义**：明确返回值、参数、功能
- **递归出口**：什么情况下直接返回，不再递归
- **递归逻辑**：如何利用子问题的结果解决当前问题

#### 2. 递归设计模式

**模式1：直接递归（汉诺塔）**
```cpp
void dfs(参数) {
    if(递归出口) return;
    处理当前层;
    dfs(子问题);
}
```

**模式2：返回值递归（合并链表）**
```cpp
Node* dfs(参数) {
    if(递归出口) return 结果;
    Node* result = dfs(子问题);
    当前节点连接result;
    return 当前节点;  // 每层返回不同
}
```

**模式3：传递新头节点（反转链表）**
```cpp
Node* dfs(参数) {
    if(递归出口) return head;
    Node* newHead = dfs(子问题);
    处理当前层;
    return newHead;  // 每层返回相同
}
```

**模式4：分治优化（快速幂）**
```cpp
int dfs(n) {
    if(n == 0) return 1;
    int half = dfs(n/2);  // 减半
    return 组合(half);
}
```

**模式5：向下传递信息（树路径数字）**
```cpp
int dfs(root, num) {  // num是累积信息
    int current = 基于num计算;
    return dfs(子节点, current);
}
```

#### 3. 递归返回值的区别

| 题目 | 返回值特点 | 原因 |
|------|-----------|------|
| 汉诺塔 | void（无返回值） | 直接修改全局状态 |
| 合并链表 | 每层返回不同节点 | 逐层构建链表 |
| 反转链表 | 每层返回相同节点 | 传递新头节点 |
| 快速幂 | 返回计算结果 | 分治组合 |
| 树路径和 | 返回子树的和 | 累加所有路径 |

### 易错点总结

#### 1. 递归出口忘记return
```cpp
// ❌ 错误
if(n == 1) {
    处理;
    // 忘记return，继续执行后面的代码
}

// ✅ 正确
if(n == 1) {
    处理;
    return;  // 必须return
}
```

#### 2. 赋值和比较运算符混淆
```cpp
// ❌ 错误
list1->next == dfs(...);  // ==是比较，不是赋值

// ✅ 正确
list1->next = dfs(...);   // =是赋值
```

#### 3. abs溢出
```cpp
// ❌ 错误
int n = -2147483648;
n = abs(n);  // 溢出！

// ✅ 正确
long long n = -2147483648;
n = -n;  // 或者用-n代替abs
```

#### 4. 误解题意
```cpp
// 树路径数字问题
// ❌ 错误理解：1→2→5 = 1+2+5 = 8
// ✅ 正确理解：1→2→5 = 125（数字一百二十五）
```

#### 5. 递归参数理解错误
```cpp
// 反转链表
// ❌ 错误
dfs(list2->next, list2)  // 参数顺序错了

// ✅ 正确
dfs(list1, list2->next)  // 未使用的在前
```

### 收获与反思

#### 今天的进步
1. ✅ **理解了递归的本质**：信任递归，假设子问题已解决
2. ✅ **掌握了递归返回值**：不同题目返回值的传递机制不同
3. ✅ **学会了画图模拟**：手动模拟递归过程帮助理解
4. ✅ **分治思想入门**：快速幂从O(n)优化到O(log n)
5. ✅ **树递归传参**：向下传递累积信息的技巧

#### 递归思维的关键
1. **不要展开递归**：相信递归函数能完成它的任务
2. **关注当前层**：只关心当前层做什么，子问题交给递归
3. **明确递归含义**：清楚函数的输入、输出、功能
4. **注意递归出口**：边界条件要处理完整，且要return

#### 后续学习方向
- 继续练习树的递归（DFS）
- 学习回溯算法（递归的高级应用）
- 学习动态规划（递归的优化方向）

### 学习方法总结
今天的引导式学习非常有效：
1. **先思考后编码**：理解题意和递归逻辑再动手
2. **手动模拟调试**：纸上画图，模拟递归过程
3. **记录错误过程**：从错误中学习更深刻
4. **对比不同解法**：理解为什么某种方法更优

**明天继续加油！🚀**

