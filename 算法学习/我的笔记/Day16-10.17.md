# Day16 学习笔记 - 分治算法（归并排序）

**日期：** 2024年10月17日  
**主题：** 分治算法 - 归并排序专题  
**课程来源：** 比特算法精品课2

---

## 今日目标

- [x] 排序数组（归并排序） - LeetCode 912 ✅
- [x] 计算右侧小于当前元素的个数 - LeetCode 315 ✅
- [x] 翻转对 - LeetCode 493 ✅
- [x] 数组中的逆序对 - 剑指Offer 51 ✅

**全部完成！** 🎉

---

## 1. 排序数组（归并排序）- LeetCode 912

**题目链接：** https://leetcode.cn/problems/sort-an-array/

### 题目描述

给你一个整数数组 nums，请你将该数组升序排列。

**示例1：**
```
输入：nums = [5,2,3,1]
输出：[1,2,3,5]
```

**示例2：**
```
输入：nums = [5,1,1,2,0,0]
输出：[0,0,1,1,2,5]
```

### 解题过程

#### 初始思路

归并排序的核心思想：分治 + 合并
1. **分（Divide）：** 把数组从中间分成两半
2. **治（Conquer）：** 递归排序左右两部分
3. **合（Combine）：** 合并两个有序数组

#### 代码框架

已经完成了前两步，卡在了第三步"合并两个有序数组"：

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size() - 1);
        return nums;
    }

    void mergeSort(vector<int>& nums, int left, int right) {
        if(left >= right) return;  // 递归出口
        
        // 1. 选择中间点划分区间
        int mid = (left + right) >> 1;
        // [left, mid], [mid+1, right]
        
        // 2. 把左右区间排序
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        
        // 3. 合并两个有序数组
        // TODO: 如何合并？
    }
};
```

#### 疑问与思考

**问题：** 如何合并两个有序数组？

需要思考的点：
1. 两个有序数组在哪里？它们的范围是什么？
   - 答：`nums[left...mid]` 和 `nums[mid+1...right]`
2. 用什么数据结构来辅助合并？
   - 答：临时数组 `tmp`
3. 合并的具体步骤是什么？
   - 答：双指针比较，谁小放谁，最后处理剩余元素
4. 如何把合并后的结果写回原数组？
   - 答：遍历拷贝 `nums[i] = tmp[i]`

#### AC代码（版本1：局部tmp - 904ms）

```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        mergeSort(nums, 0, nums.size() - 1);
        return nums;
    }

    void mergeSort(vector<int>& nums, int left, int right) {
        if(left >= right) return;
        
        // 1. 分：找中点
        int mid = (left + right) >> 1;
        
        // 2. 治：递归排序左右
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        
        // 3. 合：合并两个有序数组
        vector<int> tmp;  // 每次递归都创建新数组
        int cur1 = left, cur2 = mid + 1;
        
        // 比较并放入较小的
        while(cur1 <= mid && cur2 <= right) {
            if(nums[cur1] <= nums[cur2]) {
                tmp.push_back(nums[cur1++]);
            } else {
                tmp.push_back(nums[cur2++]);
            }
        }
        
        // 处理左边剩余
        while(cur1 <= mid) {
            tmp.push_back(nums[cur1++]);
        }
        
        // 处理右边剩余
        while(cur2 <= right) {
            tmp.push_back(nums[cur2++]);
        }
        
        // 拷贝回原数组
        for(int i = left, j = 0; i <= right; i++, j++) {
            nums[i] = tmp[j];
        }
    }
};
```

**性能问题：** 每次递归都创建新的临时数组，导致频繁的内存分配和释放。

#### AC代码（版本2：全局tmp - 60ms）⭐

```cpp
class Solution {
public:
    vector<int> tmp;  // 全局临时数组，所有递归共用
    
    vector<int> sortArray(vector<int>& nums) {
        tmp.resize(nums.size());  // 预先分配空间，只分配一次
        mergeSort(nums, 0, nums.size() - 1);
        return nums;
    }

    void mergeSort(vector<int>& nums, int left, int right) {
        if(left >= right) return;
        
        int mid = (left + right) >> 1;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);
        
        // 合并到全局tmp
        int cur1 = left, cur2 = mid + 1;
        int k = left;  // tmp的索引也从left开始
        
        while(cur1 <= mid && cur2 <= right) {
            if(nums[cur1] <= nums[cur2]) {
                tmp[k++] = nums[cur1++];
            } else {
                tmp[k++] = nums[cur2++];
            }
        }
        
        while(cur1 <= mid) tmp[k++] = nums[cur1++];
        while(cur2 <= right) tmp[k++] = nums[cur2++];
        
        // 拷贝回原数组（索引对应）
        for(int i = left; i <= right; i++) {
            nums[i] = tmp[i];
        }
    }
};
```

**性能优化：** 从 904ms 优化到 60ms，**快了15倍**！

### 核心理解

#### 1. 归并排序的三步骤

```
1. 分（Divide）：  找中点，将数组分成两半
2. 治（Conquer）： 递归排序左右两部分
3. 合（Combine）： 合并两个有序数组
```

#### 2. 递归出口

```cpp
if(left >= right) return;
```
- `left == right`：区间只有1个元素，已有序
- `left > right`：理论上不会出现，但写 `>=` 更安全

#### 3. 合并两个有序数组的核心

**双指针 + 三个while循环：**
```cpp
// 第1个循环：两边都有元素，比较并放入较小的
while(cur1 <= mid && cur2 <= right) { ... }

// 第2个循环：处理左边剩余
while(cur1 <= mid) { ... }

// 第3个循环：处理右边剩余
while(cur2 <= right) { ... }
```

**注意：** 后两个循环只有一个会执行！

#### 4. 稳定性保证

```cpp
if(nums[cur1] <= nums[cur2])  // 用 <=，不是 <
```

**为什么用 `<=`？**
- 保证稳定性：相同元素的相对位置不变
- 如果用 `<`，相同元素会优先取右边的，破坏稳定性

#### 5. 性能优化关键

**局部tmp vs 全局tmp：**

| 方法 | 空间分配次数 | 时间 | 关键点 |
|------|-------------|------|--------|
| 局部tmp | O(n log n) 次 | 904ms | 每次递归都创建新数组 |
| 全局tmp | 1次 | 60ms | 所有递归共用一个数组 |

**全局tmp的关键：**
```cpp
vector<int> tmp;
tmp.resize(nums.size());  // 只分配一次

// tmp的索引从left开始，不是从0
int k = left;
tmp[k++] = nums[cur1++];

// 拷贝时索引对应
nums[i] = tmp[i];  // 不是 nums[i] = tmp[i-left]
```

#### 6. resize 详解

**`resize(n)` 的作用：**
- 把 `vector` 的大小调整为 n
- 分配好内存空间
- 所有元素初始化为 0
- 可以直接用下标访问

**对比：**
```cpp
// resize：分配空间并创建元素
vector<int> v;
v.resize(5);   // v = [0, 0, 0, 0, 0], size=5
v[2] = 10;     // ✅ OK

// reserve：只预留空间，不创建元素
vector<int> v;
v.reserve(5);  // size=0, capacity=5
v[2] = 10;     // ❌ 越界！

// push_back：动态添加
vector<int> v;
v.push_back(10);  // ✅ OK, v = [10]
```

**在归并排序中为什么用 `resize`？**
- 因为后面要用下标访问：`tmp[k++] = nums[cur1++]`
- 如果用 `reserve`，size还是0，下标访问会越界

#### 7. 完整执行过程图解

**示例数组：[3, 1, 2, 4]**

**递归分解过程：**
```
         [3, 1, 2, 4]
         /          \
     [3, 1]        [2, 4]
     /   \         /   \
   [3]   [1]     [2]   [4]
   单个元素，已有序
```

**递归合并过程（从下往上）：**

##### 🔵 第1次合并：[3] 和 [1]

```
nums = [3, 1, 2, 4]
        ↑  ↑
      left=0, mid=0, right=1

当前要合并：nums[0...0] 和 nums[1...1] → [3] 和 [1]

--- 开始合并 ---
cur1 = 0, cur2 = 1, k = 0  // k从left开始

while(cur1 <= 0 && cur2 <= 1):
  nums[0]=3, nums[1]=1
  1 < 3 → tmp[0] = 1, cur2++
  
while(cur1 <= 0):  // 处理左边剩余
  tmp[1] = 3, cur1++

tmp = [1, 3, ?, ?]

--- 拷贝回原数组 ---
for(i = 0; i <= 1; i++)
  nums[0] = tmp[0] = 1
  nums[1] = tmp[1] = 3

结果：nums = [1, 3, 2, 4]
           ↑  ↑ 已排序
```

##### 🔵 第2次合并：[2] 和 [4]

```
nums = [1, 3, 2, 4]
              ↑  ↑
            left=2, mid=2, right=3

当前要合并：nums[2...2] 和 nums[3...3] → [2] 和 [4]

--- 开始合并 ---
cur1 = 2, cur2 = 3, k = 2  // 注意：k从2开始！

while(cur1 <= 2 && cur2 <= 3):
  nums[2]=2, nums[3]=4
  2 < 4 → tmp[2] = 2, cur1++
  
while(cur2 <= 3):  // 处理右边剩余
  tmp[3] = 4, cur2++

tmp = [1, 3, 2, 4]

--- 拷贝回原数组 ---
for(i = 2; i <= 3; i++)
  nums[2] = tmp[2] = 2
  nums[3] = tmp[3] = 4

结果：nums = [1, 3, 2, 4]
                 ↑  ↑ 已排序
```

##### 🔵 第3次合并：[1,3] 和 [2,4]（最终合并）

```
nums = [1, 3, 2, 4]
        ↑     ↑   ↑
      left=0, mid=1, right=3

当前要合并：nums[0...1] 和 nums[2...3] → [1,3] 和 [2,4]

--- 开始合并 ---
cur1 = 0, cur2 = 2, k = 0

while(cur1 <= 1 && cur2 <= 3):
  第1轮：nums[0]=1, nums[2]=2
        1 < 2 → tmp[0] = 1, cur1++
        
  第2轮：nums[1]=3, nums[2]=2
        2 < 3 → tmp[1] = 2, cur2++
        
  第3轮：nums[1]=3, nums[3]=4
        3 < 4 → tmp[2] = 3, cur1++

while(cur2 <= 3):  // 处理右边剩余
  tmp[3] = 4, cur2++

tmp = [1, 2, 3, 4]

--- 拷贝回原数组 ---
for(i = 0; i <= 3; i++)
  nums[0] = tmp[0] = 1
  nums[1] = tmp[1] = 2
  nums[2] = tmp[2] = 3
  nums[3] = tmp[3] = 4

最终结果：nums = [1, 2, 3, 4] ✅
```

**完整流程图：**
```
原数组: [3, 1, 2, 4]

分解：
         [3, 1, 2, 4]
         /          \
     [3, 1]        [2, 4]
     /   \         /   \
   [3]   [1]     [2]   [4]

合并（从下往上）：
   [3]   [1]     [2]   [4]
     \   /         \   /
   [1, 3]         [2, 4]   ← 每次合并都拷贝回nums
       \          /
       [1, 2, 3, 4]        ← 最终结果

每次合并后nums的状态变化：
初始          → [3, 1, 2, 4]
合并[3][1]    → [1, 3, 2, 4]
合并[2][4]    → [1, 3, 2, 4]
合并[1,3][2,4] → [1, 2, 3, 4]
```

**关键理解点：**

1. **k 为什么从 left 开始？**
   - tmp是全局数组，每次递归只用 `[left, right]` 这部分
   - 第1次合并用 `tmp[0], tmp[1]`
   - 第2次合并用 `tmp[2], tmp[3]`
   - 第3次合并用 `tmp[0], tmp[1], tmp[2], tmp[3]`

2. **为什么拷贝时用 `nums[i] = tmp[i]`？**
   - 因为k从left开始，tmp的索引和nums的索引是对应的
   - `tmp[0]` 对应 `nums[0]`，`tmp[1]` 对应 `nums[1]`...

3. **每次合并都要拷贝吗？**
   - 是的！每次合并完都要拷贝回原数组
   - 因为上层递归需要看到已排序的结果
   - 例如：合并 `[3]` 和 `[1]` 后，`nums[0]=1, nums[1]=3`，上层才能正确合并 `[1,3]` 和 `[2,4]`

### 复杂度分析

**时间复杂度：** O(n log n)
- 递归深度：O(log n)
- 每层合并：O(n)
- 总时间：O(n log n)

**空间复杂度：** O(n)
- 临时数组：O(n)
- 递归栈：O(log n)
- 总空间：O(n)

**归并排序 vs 快速排序：**

| 算法 | 平均时间 | 最坏时间 | 空间 | 稳定性 |
|------|---------|---------|------|--------|
| 归并排序 | O(n log n) | O(n log n) | O(n) | ✅ 稳定 |
| 快速排序 | O(n log n) | O(n²) | O(log n) | ❌ 不稳定 |

**归并排序的优势：**
- 时间复杂度稳定，最坏情况也是 O(n log n)
- 是稳定排序
- 适合外部排序（处理大文件）

**归并排序的劣势：**
- 需要额外的 O(n) 空间
- 常数因子较大，实际运行可能慢于快排

---

## 2. 数组中的逆序对 - 剑指Offer 51

**题目链接：** https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/

### 题目描述

在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 record，返回其中存在的「交易逆序对」总数。

**示例1：**
```
输入：record = [9, 7, 5, 4, 6]
输出：8
解释：交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)
```

**提示：**
- `0 <= record.length <= 50000`

### 解题思路

#### 🤔 问题1：什么是逆序对？

**定义：** 如果 `i < j` 且 `record[i] > record[j]`，则 `(record[i], record[j])` 是一个逆序对。

**手动找逆序对：**
```
record = [9, 7, 5, 4, 6]
         ↑
9 和后面所有比它小的：(9,7), (9,5), (9,4), (9,6) → 4个

record = [9, 7, 5, 4, 6]
            ↑
7 和后面所有比它小的：(7,5), (7,4), (7,6) → 3个

record = [9, 7, 5, 4, 6]
               ↑
5 和后面所有比它小的：(5,4) → 1个

record = [9, 7, 5, 4, 6]
                  ↑
4 和后面所有比它小的：无 → 0个

record = [9, 7, 5, 4, 6]
                     ↑
6 后面没有元素 → 0个

总共：4 + 3 + 1 + 0 + 0 = 8 ✅
```

#### 🤔 问题2：暴力解法为什么超时？

**暴力代码：**
```cpp
int count = 0;
for(int i = 0; i < n; i++) {
    for(int j = i + 1; j < n; j++) {
        if(nums[i] > nums[j]) {
            count++;  // 找到一个逆序对
        }
    }
}
```

**时间复杂度：** O(n²)

**示例：** `n = 50000`（题目最大数据）
- 需要比较：50000 × 50000 / 2 = 1,250,000,000 次（**12.5亿次**）
- 如果每次比较需要 2ns，总共需要：2.5秒
- LeetCode 时间限制通常是 1-2 秒 → **超时！** ❌

#### 🤔 问题3：如何想到归并排序？

**思维链条：**

1️⃣ **暴力 O(n²) 超时 → 需要优化**

2️⃣ **能否利用某种性质加速？**
```
如果数组有序，统计会很简单吗？

有序数组：[1, 2, 3, 4, 5]
逆序对：0个

逆序数组：[5, 4, 3, 2, 1]
逆序对：4+3+2+1 = 10个

嗯，有序性能帮助统计！但排序后信息不就丢了？
```

3️⃣ **在排序中统计 → 哪种排序能利用有序性？**
```
冒泡排序？每次交换就是一个逆序对？
→ 还是O(n²)，没用

快速排序？分治思想？
→ 每次分区没法批量统计

归并排序？合并两个有序数组时...
→ 有序性 + 批量统计！🎯
```

4️⃣ **归并排序的关键洞察**

```
合并两个有序数组时：
左边：[7, 9]（已排序）
右边：[4, 5, 6]（已排序）

当比较 7 和 4：
7 > 4 → 发现逆序对 (7, 4)

关键：因为左边有序，9 > 7 > 4
所以 9 和 4 也构成逆序对！

批量统计：从7到9的所有元素（mid - cur1 + 1 个）
都能和4构成逆序对！
```

**核心：** 归并排序在合并时，可以**利用有序性批量统计逆序对**，避免一个一个比较！

---

#### 🤔 问题4：为什么排序了还能统计正确？

**关键理解：** 我们是**先统计，再排序**！

**完整例子追踪：**

```
原数组：[7, 9, 4, 5, 6]

逆序对分布在三个位置：
1️⃣ 左半部分内部：[7, 9] 内部 → 0个
2️⃣ 右半部分内部：[4, 5, 6] 内部 → 0个
3️⃣ 跨越左右：(7,4), (7,5), (7,6), (9,4), (9,5), (9,6) → 6个

递归处理：
- mergeSort(左) → 返回左半部分内部的逆序对数
- mergeSort(右) → 返回右半部分内部的逆序对数
- 合并时 → 统计跨区间的逆序对数

总数 = 左 + 右 + 跨区间
```

**合并过程详解：**

```
左：[7, 9]  位置：left=0, mid=1
右：[4, 5, 6]  位置：mid+1=2, right=4

初始：count = 0, cur1 = 0, cur2 = 2

步骤1：
  nums[0]=7, nums[2]=4
  7 > 4 → 取4，count += (1 - 0 + 1) = 2
  （发现逆序对：(7,4), (9,4)）
  
步骤2：
  nums[0]=7, nums[3]=5
  7 > 5 → 取5，count += (1 - 0 + 1) = 2
  （发现逆序对：(7,5), (9,5)）
  count = 4

步骤3：
  nums[0]=7, nums[4]=6
  7 > 6 → 取6，count += (1 - 0 + 1) = 2
  （发现逆序对：(7,6), (9,6)）
  count = 6

步骤4：
  cur2 > right，右边遍历完
  取左边剩余：7, 9

合并后：[4, 5, 6, 7, 9]（已排序）
返回：count = 6 ✅
```

**关键机制：**
- 每次比较时，**发现逆序对就立即统计**
- 统计完后才排序（把元素放到正确位置）
- count 变量已经保存了逆序对信息
- 排序只是"消灭"逆序对，但我们已经记录过了

---

#### 🤔 问题5：为什么要递归？

**逆序对的三种情况：**

```
[left ... mid ... right]
 └─左半部分─┘ └─右半部分─┘

1️⃣ 左半部分内部的逆序对
   例如：[7, 9, 4] 中，(7,4), (9,4) ← 都在左边

2️⃣ 右半部分内部的逆序对
   例如：[5, 4] 中，(5,4) ← 都在右边

3️⃣ 跨越左右的逆序对
   例如：左边的7 和 右边的5 → (7,5)
```

**递归的作用：**
```cpp
int count = mergeSort(nums, left, mid)      // 处理情况1️⃣
          + mergeSort(nums, mid + 1, right) // 处理情况2️⃣
          + 合并时统计;                      // 处理情况3️⃣
```

**不递归行吗？**
```
如果不递归，只在最外层合并：
[7, 9, 4, 5, 6]
 ↑  ↑
无序！无法利用"有序性"批量统计！

递归的目的：
让左右两边各自有序 → 才能在合并时批量统计跨区间逆序对
```

---

### 我的代码

#### 初始错误版本

```cpp
class Solution {
public:
    vector<int> tmp = vector<int>(50010, 0);
    
    int reversePairs(vector<int>& nums) {
        return mergeSort(nums, 0, nums.size() - 1); 
    }
    
    int mergeSort(vector<int>& nums, int left, int right)
    {
        if(left >= right) return 0;
        
        int mid = (left + right) >> 1;
        int count = 0;
        
        count += mergeSort(nums, left, mid)
                + mergeSort(nums, mid + 1, right);
        
        int cur1 = left, cur2 = right;  // ❌ 错误：cur2应该是 mid+1
        int k = left;
        
        while(cur1 <= mid && cur2 <= right)
        {
            if(nums[cur1] <= nums[cur2])
            {
                tmp[k++] = nums[cur1++];
            }
            else 
            {
                tmp[k++] = nums[cur2++];
                count += mid - cur1 + 1;
            }
        }
        
        while(cur1 <= mid) tmp[k++] = nums[cur1++];
        while(cur2 <= right) tmp[k++] = nums[cur2++];
        
        for(int i = left; i <= right; i++)
        {
            nums[i] = tmp[i];
        }
        
        return count;  // ❌ 初始版本还忘了这一行
    }
};
```

**错误分析：**

1. **`cur2 = right` 错误：**
   ```
   左边区间：[left, mid]      → cur1 从 left 开始 ✅
   右边区间：[mid+1, right]   → cur2 从 mid+1 开始 ✅
   
   写成 cur2 = right 会跳过中间元素！
   
   例如：left=0, mid=0, right=2
   左边：[7]  位置 [0]
   右边：[5,6] 位置 [1,2]
   
   cur2 = right = 2 → 直接指向6，跳过了5！❌
   cur2 = mid+1 = 1 → 正确指向5 ✅
   ```

2. **缺少 `return count;`**
   - `mergeSort` 返回类型是 `int`，必须返回值
   - 否则编译错误："non-void function does not return a value"

**测试用例失败：**
```
输入：record = [7, 5, 6, 4]
输出：3
预期：5

正确的逆序对：(7,5), (7,6), (7,4), (5,4), (6,4) = 5个
跳过元素导致漏统计！
```

---

#### AC代码 ⭐

```cpp
class Solution {
public:
    vector<int> tmp = vector<int>(50010, 0);
    
    int reversePairs(vector<int>& nums) {
        // 分治，归并排序，暴力是n²级别超时，有序时逆序对可优化加速统计
        /*遇到逆序对问题，如何想到归并排序？
        暴力解法 O(n²) → 数据量大会超时
        需要优化 → 能否利用某种性质加速？
        有序性 → 如果数组有序，统计会很简单
        在排序中统计 → 哪种排序能利用有序性？
        归并排序 → 合并两个有序数组时，批量统计！
        
        归并排序统计逆序对的核心：
        当 nums[cur1] > nums[cur2] 时，
        左边从 cur1 到 mid 的所有元素都大于 nums[cur2]，
        一次性产生 (mid - cur1 + 1) 个逆序对！
        */
        return mergeSort(nums, 0, nums.size() - 1); 
    }
    
    int mergeSort(vector<int>& nums, int left, int right)
    {
        if(left >= right) return 0;
        
        int mid = (left + right) >> 1;
        int count = 0;  // 记录逆序对数量
        
        // [left, mid], [mid + 1, right]
        // 分：统计左半部分和右半部分内部的逆序对
        count += mergeSort(nums, left, mid)
                + mergeSort(nums, mid + 1, right);
        
        // 合并：统计跨越两区间的逆序对，批量统计，优化核心
        int cur1 = left, cur2 = mid + 1;  // ✅ cur2 从 mid+1 开始
        int k = left;  // tmp的索引也从left开始
        
        while(cur1 <= mid && cur2 <= right)
        {
            if(nums[cur1] <= nums[cur2])
            {
                tmp[k++] = nums[cur1++];
            }
            else 
            {
                // 发现逆序对！批量统计
                tmp[k++] = nums[cur2++];
                count += mid - cur1 + 1;  // 🎯 关键：批量统计
            }
        }
        
        // 处理剩余元素
        while(cur1 <= mid) tmp[k++] = nums[cur1++];
        while(cur2 <= right) tmp[k++] = nums[cur2++];
        
        // 拷贝回原数组
        for(int i = left; i <= right; i++)
        {
            nums[i] = tmp[i];
        }
        
        return count;  // ✅ 返回逆序对总数
    }
};
```

**时间：** 约 300ms（具体取决于测试数据）  
**击败：** 约 70% 用户

---

### 核心理解

#### 1. 逆序对统计公式

```cpp
when nums[cur1] > nums[cur2]:
    count += (mid - cur1 + 1)
```

**推导过程：**

```
左边（有序）：[7, 9]
              ↑  ↑
            cur1=0, mid=1
            
右边（有序）：[4, 5, 6]
              ↑
            cur2=2

比较：nums[0]=7, nums[2]=4
     7 > 4 → 发现逆序对！

问题1：只有 (7,4) 这一个逆序对吗？
答：不！因为左边有序，9 > 7 > 4
   所以 (9,4) 也是逆序对！

问题2：从下标0到下标1，有多少个元素？
答：mid - cur1 + 1 = 1 - 0 + 1 = 2

所以：一次性产生 2 个逆序对！
```

**为什么这样统计是对的？**

```
左边有序的性质：
nums[cur1] < nums[cur1+1] < ... < nums[mid]

当 nums[cur1] > nums[cur2] 时：
→ nums[cur1+1] > nums[cur1] > nums[cur2]
→ nums[cur1+2] > nums[cur1] > nums[cur2]
→ ...
→ nums[mid] > nums[cur1] > nums[cur2]

所以从 cur1 到 mid 的所有元素都大于 nums[cur2]
都能和 nums[cur2] 构成逆序对！

批量统计：mid - cur1 + 1 个逆序对
```

#### 2. 只在 else 分支统计

```cpp
if(nums[cur1] <= nums[cur2]) {
    // 左边小，不产生逆序对 ❌
    tmp[k++] = nums[cur1++];
} else {
    // 左边大，产生逆序对！✅
    tmp[k++] = nums[cur2++];
    count += mid - cur1 + 1;  // 统计
}
```

**为什么只在 else 统计？**

| 情况 | 是否逆序对 | 操作 |
|------|-----------|------|
| 左 ≤ 右 | ❌ 不是 | 取左边，不统计 |
| 左 > 右 | ✅ 是！ | 取右边，**批量统计** |

#### 3. 归并排序 vs 暴力解法

| 方法 | 时间复杂度 | 核心思想 |
|------|-----------|---------|
| 暴力 | O(n²) | 双重循环，一个一个比较 |
| 归并 | O(n log n) | 利用有序性，批量统计 |

**优化关键：**
```
暴力：每次只能统计 1 个逆序对
归并：每次可以统计 (mid - cur1 + 1) 个逆序对

例如：
左边有 1000 个元素，cur1=0
当发现 nums[0] > nums[cur2] 时
暴力需要比较 1000 次
归并只需要加一次：count += 1000
```

#### 4. 正确性保证：分层统计

```
逆序对总数 = 左半部分内部 + 右半部分内部 + 跨区间

代码体现：
int count = mergeSort(左)      // 左内部
          + mergeSort(右)      // 右内部
          + 合并时统计的count; // 跨区间
```

**每层递归只负责本层的逆序对，递归返回值累加所有子问题的结果。**

#### 5. 易错点总结

| 易错点 | 错误写法 | 正确写法 | 原因 |
|--------|---------|---------|------|
| cur2初始化 | `cur2 = right` | `cur2 = mid + 1` | 右半部分从mid+1开始 |
| 缺少返回值 | 无 `return` | `return count;` | int函数必须返回值 |
| 统计位置 | 在if分支统计 | 在else分支统计 | 只有左>右才是逆序对 |
| 统计公式 | `count++` | `count += (mid - cur1 + 1)` | 批量统计，不是单个 |

---

### 复杂度分析

**时间复杂度：** O(n log n)
- 归并排序的时间复杂度：O(n log n)
- 统计逆序对：在合并过程中顺便完成，不增加额外时间
- 总时间：O(n log n)

**空间复杂度：** O(n)
- 临时数组 tmp：O(n)
- 递归栈：O(log n)
- 总空间：O(n)

**对比暴力解法：**
```
n = 50000（题目最大数据）

暴力 O(n²)：
50000 × 50000 / 2 = 1,250,000,000 次比较
→ 超时 ❌

归并 O(n log n)：
50000 × log₂(50000) ≈ 50000 × 16 = 800,000 次操作
→ 约 300ms ✅

优化效果：快了 1000+ 倍！
```

---

## 3. 计算右侧小于当前元素的个数 - LeetCode 315

**题目链接：** https://leetcode.cn/problems/count-of-smaller-numbers-after-self/

### 题目描述

给你一个整数数组 `nums`，按要求返回一个新数组 `counts`。数组 `counts` 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。

**示例1：**
```
输入：nums = [5, 2, 6, 1]
输出：[2, 1, 1, 0]
解释：
5 的右侧有 2 个更小的元素 (2 和 1)
2 的右侧有 1 个更小的元素 (1)
6 的右侧有 1 个更小的元素 (1)
1 的右侧有 0 个更小的元素
```

**示例2：**
```
输入：nums = [-1]
输出：[0]
```

**示例3：**
```
输入：nums = [-1, -1]
输出：[0, 0]
```

**提示：**
- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

---

### 解题思路

#### 🤔 问题1：这道题和逆序对有什么区别？

**对比分析：**

| 题目 | 统计什么 | 返回什么 | 核心难点 |
|------|---------|---------|---------|
| **逆序对** | 整个数组的逆序对总数 | 一个整数 `int` | 统计总数 |
| **右侧更小元素** | **每个元素**右侧更小的个数 | 一个数组 `vector<int>` | 追踪每个元素的统计结果 |

**核心区别：**
- 逆序对：只需要一个 `int count` 变量记录总数
- 右侧更小：需要一个 `vector<int> count` 数组，记录每个位置的统计结果

---

#### 🤔 问题2：归并排序会带来什么问题？

**问题场景：**

```
原数组：[5, 2, 6, 1]
       ↑  ↑  ↑  ↑
     下标0 1  2  3

我们想要的结果：
result[0] = ?  ← 元素5（原来下标0）右侧有多少个更小的？
result[1] = ?  ← 元素2（原来下标1）右侧有多少个更小的？
result[2] = ?  ← 元素6（原来下标2）右侧有多少个更小的？
result[3] = ?  ← 元素1（原来下标3）右侧有多少个更小的？
```

**归并排序后：**

```
排序前：[5, 2, 6, 1]
       ↑
     下标0的元素是5

排序后：[1, 2, 5, 6]
          ↑
     下标0的元素变成1了！

问题：排序后，我们还能知道原来下标0的元素（5）在哪吗？❌
```

**关键问题：** 归并排序会改变元素位置，我们无法追踪"原来下标0的元素"统计了多少个！

---

#### 💡 解决方案：索引数组

**核心思想：** 不直接排序 `nums`，而是排序**索引数组**！

**什么是索引数组？**

```
原数组：nums = [5, 2, 6, 1]
              ↑  ↑  ↑  ↑
            下标0 1  2  3

索引数组：index = [0, 1, 2, 3]

index[0] = 0  → 指向 nums[0] = 5
index[1] = 1  → 指向 nums[1] = 2
index[2] = 2  → 指向 nums[2] = 6
index[3] = 3  → 指向 nums[3] = 1
```

**排序索引数组：**

```
我们不是按 index[i] 的值排序
而是按 nums[index[i]] 的值排序！

初始：
index = [0, 1, 2, 3]
        ↓  ↓  ↓  ↓
nums  = [5, 2, 6, 1]

排序后：
index = [3, 1, 0, 2]
        ↓  ↓  ↓  ↓
nums  = [1, 2, 5, 6]  ← 通过 index 看到的有序序列

关键：index[2] = 0 仍然记录着"元素5的原始位置是0"！
```

**优势：**
- `nums` 本身不动
- `index` 排序后，`index[i]` 仍然记录着原始位置
- 我们能追踪到每个元素的统计结果

---

#### 🤔 问题3：什么时候统计？怎么统计？

**归并排序的合并过程：**

```
左边：[2, 5]  (已排序，通过 index 看到的)
      ↑
    cur1

右边：[1, 6]  (已排序，通过 index 看到的)
      ↑
    cur2

比较：nums[index[cur1]] vs nums[index[cur2]]
     即 2 vs 1
```

**关键洞察：**

在归并排序中，**右边区间**的元素都在原数组中位于**左边元素的右侧**！

```
原数组：[5, 2, 6, 1]
        ↑     ↑  ↑
      左边  右边区间
      
5 的右侧：[2, 6, 1]
右边区间：[6, 1]
```

**统计时机：**

当我们取左边的元素时（`nums[index[cur1]] <= nums[index[cur2]]`）：
- 此时右边有一些元素已经被取走了（放进 `tmp` 了）
- 这些元素一定比左边当前元素小（因为先被取走）
- 而且它们在原数组中位于左边元素的右侧

**所以：右边已经被取走的元素个数 = 左边当前元素右侧更小的个数！**

---

**"已被取走"的个数如何计算？**

```
右边区间初始位置：mid + 1
右边当前位置：cur2

例子：
初始：cur2 = mid + 1 = 3
现在：cur2 = 5

说明：下标3, 4的元素已经被取走了 → 2个

公式：cur2 - (mid + 1) = 5 - 3 = 2
化简：cur2 - mid - 1
```

---

**边界情况：左边剩余**

```
左边：[5, 7, 9]
            ↑ ↑
          cur1还剩这些

右边：[1, 2, 6]
               ↑
             cur2 > right (右边遍历完了)

问：此时左边剩余的元素（7, 9）右侧有多少个更小的？
答：右边所有元素都被取走了，总共 right - mid 个
```

---

### 我的代码

#### 初始思路

一开始不知道怎么处理返回值和统计问题：

```cpp
class Solution {
public:
    vector<int> tmp;
    vector<int> countSmaller(vector<int>& nums) {
        // 由大到小排？利用分治，排序时顺便统计个数，多传一个值的参数？
        tmp.resize(nums.size());
        return mergeSort(nums, 0, nums.size() - 1);
    }
    vector<int> mergeSort(vector<int>& nums, int left, int right) {
        vector<int> ret{};  // 先统计个数，最后压进去？优化统计方式？
        if(left >= right) return ;
        int mid = (left + right) >> 1;
        // ...
    }
};
```

**困惑点：**
1. 返回值怎么处理？
2. 如何记录每个元素的统计结果？
3. 统计公式是 `mid - cur1 + 1` 吗？但怎么和数组关联？

---

#### 理解过程（苏格拉底式引导）

**第1步：** 认识到核心区别
- 逆序对：统计整体总数 → 返回 `int`
- 这道题：统计每个元素 → 返回 `vector<int>`，需要追踪

**第2步：** 理解归并排序的问题
- 排序后元素位置变了
- 无法追踪"原来下标0的元素"

**第3步：** 引入索引数组
- 创建 `index = [0, 1, 2, 3, ...]`
- 排序 `index`，但比较 `nums[index[i]]`
- `index` 记录原始位置

**第4步：** 理解统计时机
- 当取左边元素时，统计右边已取走的个数
- 公式：`cur2 - mid - 1`

**第5步：** 处理边界
- 左边剩余：统计 `right - mid`
- 右边剩余：不需要统计

**第6步：** 数据结构设计
- 成员变量：`tmp`（临时数组）、`count`（结果数组）、`nums`（原数组）
- 函数签名：`void mergeSort(vector<int>& index, int left, int right)`

---

#### AC代码 ⭐

```cpp
class Solution {
public:
    vector<int> tmp;     // 临时数组（存索引）
    vector<int> count;   // 结果数组（存统计结果）
    vector<int> nums;    // 原数组（用来比较）
    
    vector<int> countSmaller(vector<int>& nums) {
        int n = nums.size();
        
        // 保存原数组到成员变量
        this->nums = nums;
        
        // 创建索引数组
        vector<int> index(n);
        for(int i = 0; i < n; i++) {
            index[i] = i;  // [0, 1, 2, 3, ...]
        }
        
        // 初始化 count 和 tmp
        count.resize(n, 0);
        tmp.resize(n);
        
        // 归并排序索引数组
        mergeSort(index, 0, n - 1);
        
        return count;
    }
    
    void mergeSort(vector<int>& index, int left, int right) {
        if(left >= right) return;
        
        int mid = (left + right) >> 1;
        
        // 递归排序 index 的左右两部分
        mergeSort(index, left, mid);
        mergeSort(index, mid + 1, right);
        
        // 合并
        int cur1 = left, cur2 = mid + 1;
        int k = left;
        
        while(cur1 <= mid && cur2 <= right) {
            // 比较 nums[index[cur1]] 和 nums[index[cur2]]
            if(nums[index[cur1]] <= nums[index[cur2]]) {
                // 左边小，统计右边已取走的个数
                count[index[cur1]] += (cur2 - mid - 1);
                tmp[k++] = index[cur1++];
            } else {
                // 右边小，取右边
                tmp[k++] = index[cur2++];
            }
        }
        
        // 处理左边剩余
        while(cur1 <= mid) {
            // 右边全部取完了，统计右边总个数
            count[index[cur1]] += (right - mid);
            tmp[k++] = index[cur1++];
        }
        
        // 处理右边剩余（不需要统计）
        while(cur2 <= right) {
            tmp[k++] = index[cur2++];
        }
        
        // 拷贝回 index
        for(int i = left; i <= right; i++) {
            index[i] = tmp[i];
        }
    }
};
```

**时间：** 约 400ms  
**击败：** 约 60% 用户

---

### 核心理解

#### 1. 索引数组的作用

**为什么需要索引数组？**

```
问题：归并排序会改变元素位置
解决：排序索引，而不是元素本身

index 数组的含义：
index[i] 记录的是"第i个位置上元素的原始下标"

排序后：
index = [3, 1, 0, 2]
       ↓  ↓  ↓  ↓
     原始下标，永远不变！
```

**关键操作：**
- 比较：`nums[index[cur1]]` vs `nums[index[cur2]]`
- 交换：交换 `index` 里的值，不是 `nums`
- 统计：`count[index[cur1]] += ...`（用原始下标更新结果）

---

#### 2. 统计公式推导

**情况1：左边元素被取走时**

```cpp
if(nums[index[cur1]] <= nums[index[cur2]]) {
    count[index[cur1]] += (cur2 - mid - 1);
    tmp[k++] = index[cur1++];
}
```

**为什么是 `cur2 - mid - 1`？**

```
右边区间：[mid+1, ..., cur2-1, cur2, ..., right]
         ↑                 ↑
       开始位置          当前位置
       
已经被取走的：从 mid+1 到 cur2-1
个数：(cur2 - 1) - (mid + 1) + 1 = cur2 - mid - 1
```

**例子验证：**
```
mid = 4, cur2 = 7

已取走：下标 5, 6 → 2个
公式：7 - 4 - 1 = 2 ✅
```

---

**情况2：左边剩余时**

```cpp
while(cur1 <= mid) {
    count[index[cur1]] += (right - mid);
    tmp[k++] = index[cur1++];
}
```

**为什么是 `right - mid`？**

```
右边区间：[mid+1, mid+2, ..., right]

从 mid+1 到 right，共多少个？
right - (mid + 1) + 1 = right - mid
```

---

#### 3. 数据结构设计

**成员变量：**

| 变量 | 类型 | 作用 |
|------|------|------|
| `nums` | `vector<int>` | 保存原数组，用来比较 `nums[index[i]]` |
| `index` | `vector<int>` | 局部变量，记录元素的原始下标 |
| `tmp` | `vector<int>` | 临时数组，存放排序中的 `index` |
| `count` | `vector<int>` | 结果数组，`count[i]` = 原始下标i的统计结果 |

**函数签名：**

```cpp
void mergeSort(vector<int>& index, int left, int right)
```

- 只传 `index`，因为其他都是成员变量
- 不返回值（`void`），统计结果保存在 `count` 中

---

#### 4. 和逆序对的对比

| 对比项 | 逆序对 | 右侧更小元素 |
|--------|--------|-------------|
| **统计对象** | 整个数组的总数 | 每个元素各自的个数 |
| **返回值** | `int` | `vector<int>` |
| **排序对象** | 直接排序 `nums` | 排序索引数组 `index` |
| **比较依据** | `nums[cur1]` vs `nums[cur2]` | `nums[index[cur1]]` vs `nums[index[cur2]]` |
| **统计时机** | `else` 分支（右边小） | `if` 分支（左边小） |
| **统计公式** | `count += (mid - cur1 + 1)` | `count[index[cur1]] += (cur2 - mid - 1)` |
| **数据结构** | `int count` | `vector<int> count` + 索引数组 |

**核心区别：**
- 逆序对：统计"左边>右边"的情况
- 这道题：统计"左边元素右侧有多少个更小的"，当左边被取走时统计

---

#### 5. 易错点总结

| 易错点 | 错误写法 | 正确写法 | 原因 |
|--------|---------|---------|------|
| 排序对象 | `mergeSort(nums, ...)` | `mergeSort(index, ...)` | 要排序索引，不是元素 |
| 比较依据 | `if(index[cur1] <= index[cur2])` | `if(nums[index[cur1]] <= nums[index[cur2]])` | 比较的是元素值，不是下标 |
| 统计公式 | `count[cur1] += ...` | `count[index[cur1]] += ...` | 用原始下标更新结果 |
| 统计时机 | `else` 分支统计 | `if` 分支统计（左边小时） | 和逆序对相反 |
| 边界处理 | 忘记处理左边剩余 | `count[index[cur1]] += (right - mid)` | 右边全部取完要统计 |

---

### 复杂度分析

**时间复杂度：** O(n log n)
- 归并排序的时间复杂度：O(n log n)
- 统计操作：在合并过程中顺便完成，不增加额外时间
- 总时间：O(n log n)

**空间复杂度：** O(n)
- 索引数组 `index`：O(n)
- 临时数组 `tmp`：O(n)
- 结果数组 `count`：O(n)
- 递归栈：O(log n)
- 总空间：O(n)

**对比暴力解法：**
```
暴力解法：
for(int i = 0; i < n; i++) {
    for(int j = i + 1; j < n; j++) {
        if(nums[j] < nums[i]) count[i]++;
    }
}

时间复杂度：O(n²)
n = 10^5 时：10^10 次操作 → 超时 ❌

归并排序：O(n log n)
n = 10^5 时：约 10^5 × 17 = 1.7 × 10^6 次操作 → AC ✅

优化效果：快了 5000+ 倍！
```

---

### 学习收获

#### 1. 索引数组技巧

这是一个非常强大的技巧，适用于：
- 需要在排序的同时追踪元素原始位置
- 需要对每个元素单独统计结果
- 不能直接修改原数组

**模板：**
```cpp
// 创建索引数组
vector<int> index(n);
for(int i = 0; i < n; i++) index[i] = i;

// 排序索引，比较元素
sort(index.begin(), index.end(), [&](int i, int j) {
    return nums[i] < nums[j];
});
```

#### 2. 归并排序的灵活应用

归并排序不仅仅是排序，还可以：
- 统计逆序对（题2）
- 统计右侧更小元素（题3）
- 统计翻转对（题4，明天做）

**核心：** 在合并两个有序区间时，利用有序性批量统计信息

#### 3. 学习方法的反思

**今天这道题的学习过程：**
- 耗时：约 1 小时 40 分钟
- 方法：苏格拉底式引导，一步步推导
- 结果：完全理解，代码一次AC

**收获：**
- 比直接看题解的理解更深刻
- 掌握了索引数组这个通用技巧
- 培养了从问题出发推导解法的能力

**感悟：**
> 慢就是快。花时间深度理解一道题，胜过快速刷十道题。
> 今天学的索引数组技巧，明天就能直接用到翻转对问题上。
> 这就是深度学习的复利效应。

---

## 4. 翻转对 - LeetCode 493

**题目链接：** https://leetcode.cn/problems/reverse-pairs/

### 题目描述

给定一个数组 `nums`，如果 `i < j` 且 `nums[i] > 2 * nums[j]`，我们就将 `(i, j)` 称作一个**重要翻转对**。

你需要返回给定数组中的重要翻转对的数量。

**示例1：**
```
输入：nums = [1, 3, 2, 3, 1]
输出：2
```

**示例2：**
```
输入：nums = [2, 4, 3, 5, 1]
输出：3
```

**提示：**
- `1 <= nums.length <= 5 * 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

---

### 解题思路

#### 🤔 问题1：这道题和逆序对有什么区别？

**对比分析：**

| 题目 | 条件 | 能否在归并时统计？ |
|------|------|------------------|
| **逆序对** | `nums[i] > nums[j]` | ✅ 可以 |
| **翻转对** | `nums[i] > 2 * nums[j]` | ❌ 不行 |

**核心区别：**
- 逆序对：统计条件 = 归并排序的比较条件
- 翻转对：统计条件 ≠ 归并排序的比较条件

---

#### 🤔 问题2：为什么不能在归并时一起统计？

**逆序对（可以一起）：**

```cpp
while(cur1 <= mid && cur2 <= right) {
    if(nums[cur1] <= nums[cur2]) {
        // 归并条件：左边 ≤ 右边
        tmp[k++] = nums[cur1++];
    } else {
        // 统计条件：左边 > 右边（和归并条件互补）
        tmp[k++] = nums[cur2++];
        count += (mid - cur1 + 1);  // 可以在这里统计
    }
}
```

**翻转对（不能一起）：**

```
归并条件：nums[cur1] <= nums[cur2]  ← 决定取谁
统计条件：nums[cur1] > 2 * nums[cur2]  ← 判断是否是翻转对

这两个条件不一样！不能用统计条件来决定取谁！
```

**举例说明：**

```
左边：[10]
右边：[5, 8]

归并排序：
10 vs 5 → 5小，取5
10 vs 8 → 8小，取8
取10
结果：[5, 8, 10]

翻转对统计：
10 > 2*5 (10)? ❌ → 不是翻转对
10 > 2*8 (16)? ❌ → 不是翻转对

如果用 nums[cur1] > 2 * nums[cur2] 来决定取谁：
10 vs 5 → 10 > 10? ❌ → 取10？
这就乱套了！归并排序会错！
```

---

#### 💡 正确思路：分两步

**Step 1：先统计跨区间的翻转对**

```cpp
// 在合并之前，先统计翻转对
int cur1 = left, cur2 = mid + 1;
while(cur1 <= mid) {
    // 对于左边的每个元素，找右边有多少个满足条件
    while(cur2 <= right && nums[cur1] > 2LL * nums[cur2]) {
        cur2++;
    }
    count += (cur2 - mid - 1);
    cur1++;
}
```

**Step 2：再正常归并排序**

```cpp
// 重置指针，正常合并两个有序数组
cur1 = left;
cur2 = mid + 1;
int k = left;

while(cur1 <= mid && cur2 <= right) {
    if(nums[cur1] <= nums[cur2]) {
        tmp[k++] = nums[cur1++];
    } else {
        tmp[k++] = nums[cur2++];
    }
}
```

---

### 我的代码

#### 初始错误版本

```cpp
class Solution {
public:
    vector<int> tmp;
    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        tmp.resize(n);
        return mergeSort(nums, 0, n-1);
    }
    
    int mergeSort(vector<int>& nums, int left, int right) {
        if(left >= right) return 0;

        int mid = left + (right - left) / 2;
        int count = 0;

        count += mergeSort(nums, left, mid) + mergeSort(nums, mid+1, right);
        
        // 合并，统计跨越两区的翻转对
        int cur1 = left, cur2 = mid + 1;
        int k = left;

        while(cur1 <= mid && cur2 <= right) {
            if(nums[cur1] <= 2*nums[cur2]) {  // ❌ 错误1：条件反了
                tmp[k++] = nums[cur1++];
            } else {
                tmp[k++] = nums[cur2++];
                count += mid - cur1 + 1;
            }
        }
        while(cur1 <= mid) tmp[k++] = nums[cur2++];  // ❌ 错误2：应该是cur1++
        while(cur2 <= right) tmp[k++] = nums[cur2++];
        
        for(int i = left; i <= right; i++) {
            nums[i] = tmp[i];
        }
        return count;
    }
};
```

**错误分析：**

1. **错误1：把统计条件当成归并条件**
   - 用 `nums[cur1] <= 2*nums[cur2]` 来决定取谁
   - 这会导致归并排序错误！
   - 应该分两步：先统计，再归并

2. **错误2：处理剩余元素时写错**
   - `while(cur1 <= mid) tmp[k++] = nums[cur2++];`
   - 应该是 `nums[cur1++]`，不是 `nums[cur2++]`

3. **错误3：可能整数溢出**
   - `2*nums[cur2]` 可能溢出
   - 应该用 `2LL * nums[cur2]`

**运行错误：** heap-buffer-overflow（数组越界）

---

#### 理解过程（苏格拉底式引导）

**第1步：** 认识到核心问题
- 逆序对的条件和归并条件是互补的
- 翻转对的条件和归并条件不一样
- 不能混在一起

**第2步：** 理解为什么要分两步
- 统计翻转对：用翻转对的条件
- 归并排序：用归并的条件
- 两个过程独立进行

**第3步：** 理解统计翻转对的逻辑
- 对于左边的每个元素，找右边有多少个满足条件
- `cur2` 不需要每次重置，因为左右都有序
- `cur2` 只会往右移

**第4步：** 理解整数溢出问题
- `2 * nums[cur2]` 可能溢出 `int` 范围
- 用 `2LL` 强制转成 `long long`
- `LL` = Long Long（64位）

---

#### AC代码 ⭐

```cpp
class Solution {
public:
    vector<int> tmp;
    
    int reversePairs(vector<int>& nums) {
        int n = nums.size();
        tmp.resize(n);
        return mergeSort(nums, 0, n - 1);
    }
    
    int mergeSort(vector<int>& nums, int left, int right) {
        if(left >= right) return 0;
        
        int mid = left + (right - left) / 2;
        
        // 递归统计左右两边内部的翻转对
        int count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right);
        
        // === Step 1: 统计跨区间的翻转对 ===
        int cur1 = left, cur2 = mid + 1;
        while(cur1 <= mid) {
            // 对于左边的每个元素，找右边有多少个满足条件
            while(cur2 <= right && nums[cur1] > 2LL * nums[cur2]) {
                cur2++;
            }
            count += (cur2 - mid - 1);
            cur1++;
        }
        
        // === Step 2: 正常归并排序 ===
        cur1 = left;
        cur2 = mid + 1;
        int k = left;
        
        while(cur1 <= mid && cur2 <= right) {
            if(nums[cur1] <= nums[cur2]) {
                tmp[k++] = nums[cur1++];
            } else {
                tmp[k++] = nums[cur2++];
            }
        }
        
        while(cur1 <= mid) tmp[k++] = nums[cur1++];
        while(cur2 <= right) tmp[k++] = nums[cur2++];
        
        // 拷贝回原数组
        for(int i = left; i <= right; i++) {
            nums[i] = tmp[i];
        }
        
        return count;
    }
};
```

**时间：** 约 400ms  
**击败：** 约 50% 用户

---

### 核心理解

#### 1. 为什么要分两步？

**核心原因：** 统计条件 ≠ 归并条件

| 操作 | 条件 | 作用 |
|------|------|------|
| 统计翻转对 | `nums[cur1] > 2 * nums[cur2]` | 判断是否是翻转对 |
| 归并排序 | `nums[cur1] <= nums[cur2]` | 决定取哪边的元素 |

**如果混在一起：**
- 用统计条件来决定取谁 → 归并排序会错
- 用归并条件来统计 → 统计结果会错

**所以必须分两步！**

---

#### 2. 统计翻转对的逻辑

**代码：**
```cpp
int cur1 = left, cur2 = mid + 1;
while(cur1 <= mid) {
    while(cur2 <= right && nums[cur1] > 2LL * nums[cur2]) {
        cur2++;
    }
    count += (cur2 - mid - 1);
    cur1++;
}
```

**执行过程（以 `[4, 10]` 和 `[1, 3, 5]` 为例）：**

```
左边：[4, 10]  left=0, mid=1
右边：[1, 3, 5]  mid+1=2, right=4

cur1 = 0（指向4），cur2 = 2（指向1）：
  while(cur2 <= 4 && 4 > 2LL * nums[cur2]):
    4 > 2*1 (2)? ✅ → cur2 = 3
    4 > 2*3 (6)? ❌ → 退出
  
  count += (3 - 2 - 1) = 0  ← 没有满足的
  cur1 = 1

cur1 = 1（指向10），cur2 = 3（从上次继续）：
  while(cur2 <= 4 && 10 > 2LL * nums[cur2]):
    10 > 2*3 (6)? ✅ → cur2 = 4
    10 > 2*5 (10)? ❌ → 退出
  
  count += (4 - 2 - 1) = 1  ← 有1个满足的（3）
  cur1 = 2 > mid，退出

总计：count = 0 + 1 = 1

等等，应该有2个翻转对 (10,1) 和 (10,3)？
```

**我算错了！重新理解：**

```
count += (cur2 - mid - 1) 的含义：

从 mid+1 到 cur2-1 的元素个数

例子：
cur2 = 4（第一次循环后）
count += (4 - 2 - 1) = 1

但是 cur2 是在第二轮 cur1=1 时才移到4的！
第一轮 cur1=0 时，cur2 就已经移到3了！

让我重新追踪...
```

**正确追踪：**

```
初始：cur1 = 0, cur2 = 2

第1轮（cur1=0，指向4）：
  内层while：
    cur2=2: 4 > 2*1? ✅ → cur2=3
    cur2=3: 4 > 2*3? ❌ → 退出内层
  count += (3-2-1) = 0 ❌

不对，4 > 2*1 是成立的啊！
应该统计到 (4,1) 这个翻转对！

哦！我明白了！
count += (cur2 - mid - 1)
= (3 - 2 - 1) = 0

这表示从 mid+1=2 到 cur2-1=2，有0个元素
但 cur2=3 时，说明 nums[2]=1 已经不满足了
所以应该是从 mid+1=2 到 cur2-1=2，就是下标2的元素（1）

等等，cur2-1 = 3-1 = 2
mid+1 = 2
从2到2，是1个元素！

所以应该是 count += (cur2-1) - (mid+1) + 1
             = cur2 - mid - 1

但这样 (3-2-1) = 0 啊！

我理解错了...让我重新看代码含义...
```

**重新理解公式：**

实际上这个公式有问题！应该是：

```cpp
count += (cur2 - (mid + 1));
// 简化：count += (cur2 - mid - 1);
```

但这不对啊...

让我看看正确的理解应该是什么...实际上代码可能需要调整统计方式。

算了，先记录下来，核心理解已经清楚了：**分两步，避免混淆**。

---

#### 3. 整数溢出问题

**为什么用 `2LL`？**

```cpp
2 * nums[cur2]      // ❌ 可能溢出
2LL * nums[cur2]    // ✅ 不会溢出
```

**原因：**
- `int` 最大值：约 21亿（2^31 - 1）
- `nums[cur2]` 可能很大（10亿）
- `2 * 10亿 = 20亿`，接近 `int` 上限
- 如果 `nums[cur2]` 更大，会溢出

**`2LL` 的作用：**
- `LL` = Long Long（64位）
- `2LL` 是 `long long` 类型
- `nums[cur2]` 会自动提升为 `long long`
- 结果不会溢出

---

#### 4. 和逆序对的对比

| 对比项 | 逆序对 | 翻转对 |
|--------|--------|--------|
| **统计条件** | `nums[i] > nums[j]` | `nums[i] > 2 * nums[j]` |
| **归并条件** | `nums[cur1] <= nums[cur2]` | `nums[cur1] <= nums[cur2]` |
| **条件关系** | 互补（if-else） | 不互补 |
| **统计时机** | 归并时（else分支） | 归并前（单独循环） |
| **代码步骤** | 1步（合并+统计） | 2步（先统计，再合并） |

---

### 复杂度分析

**时间复杂度：** O(n log n)
- 归并排序：O(n log n)
- 统计翻转对：O(n)（每个元素最多访问一次）
- 总时间：O(n log n)

**空间复杂度：** O(n)
- 临时数组 `tmp`：O(n)
- 递归栈：O(log n)
- 总空间：O(n)

---

### 易错点总结

| 易错点 | 错误写法 | 正确写法 | 原因 |
|--------|---------|---------|------|
| 混淆统计和归并 | 在归并时统计翻转对 | 分两步：先统计，再归并 | 条件不一样 |
| 整数溢出 | `2 * nums[cur2]` | `2LL * nums[cur2]` | `int` 可能溢出 |
| 处理剩余元素 | `tmp[k++] = nums[cur2++]` | `tmp[k++] = nums[cur1++]` | 应该取左边剩余 |
| 统计条件用于归并 | `if(nums[cur1] <= 2*nums[cur2])` | 分开处理 | 会导致归并错误 |

---

### 学习收获

#### 1. 归并排序的灵活应用

归并排序不仅仅是排序，可以在合并过程中统计信息：
- 逆序对：统计条件 = 归并条件 → 可以一起
- 翻转对：统计条件 ≠ 归并条件 → 必须分开

**关键判断：** 看统计条件和归并条件是否一致！

#### 2. 整数溢出的警惕

涉及乘法时，要考虑是否会溢出：
- 用 `LL` 强制转成 `long long`
- 或者改写条件：`nums[i]/2 > nums[j]`（但要注意除法的坑）

#### 3. 问题分解的思维

复杂问题要分解成独立的步骤：
- Step 1：统计翻转对
- Step 2：归并排序
- 不要试图一步完成所有事情

---

## 今日总结

### 完成情况

✅ **完成题目：** 4/4 全部完成！🎉
- ✅ 排序数组（归并排序） - LeetCode 912
- ✅ 数组中的逆序对 - 剑指Offer 51
- ✅ 计算右侧小于当前元素的个数 - LeetCode 315
- ✅ 翻转对 - LeetCode 493

⏰ **用时：**
- 第1题：约40分钟（包含苏格拉底式引导、优化、理解）
- 第2题：约50分钟（包含深度理解、调试、AC）
- 第3题：约100分钟（包含苏格拉底式引导、索引数组理解、AC）
- 第4题：约40分钟（理解分两步的原因、整数溢出、AC）

### 核心收获

#### 1. 归并排序的完整掌握

**三步骤框架：**
```cpp
void mergeSort(nums, left, right) {
    if(left >= right) return;  // 递归出口
    
    int mid = (left + right) >> 1;
    
    // 1. 分：划分区间
    // 2. 治：递归排序
    mergeSort(nums, left, mid);
    mergeSort(nums, mid+1, right);
    
    // 3. 合：合并两个有序数组
    // 双指针 + 临时数组 + 拷贝回原数组
}
```

**性能优化关键：**
- 局部 `tmp` → 全局 `tmp`：性能提升 **15倍**（904ms → 60ms）
- 用 `resize` 预分配空间，避免频繁内存分配

#### 2. 逆序对问题的思维升华

**从暴力到优化的思维链：**
```
暴力 O(n²) 
  ↓
需要利用某种性质加速
  ↓
有序性可以帮助统计
  ↓
在排序中统计
  ↓
归并排序：合并时利用有序性批量统计
  ↓
O(n log n) ✅
```

**核心公式：**
```cpp
when nums[cur1] > nums[cur2]:
    count += (mid - cur1 + 1)  // 批量统计逆序对
```

**为什么这样统计是对的？**
- 左边有序：`nums[cur1] < nums[cur1+1] < ... < nums[mid]`
- 当 `nums[cur1] > nums[cur2]` 时，后面所有元素也都大于 `nums[cur2]`
- 利用传递性，批量统计，避免一个一个比较

#### 3. 递归的深度理解

**递归的正确性保证：**
```
逆序对总数 = 左半部分内部 + 右半部分内部 + 跨区间

代码体现：
int count = mergeSort(左)      // 递归统计左内部
          + mergeSort(右)      // 递归统计右内部
          + 合并时统计;        // 批量统计跨区间
```

**为什么排序了还能统计正确？**
- **先统计，再排序**：发现逆序对时立即累加到 `count`
- 排序只是副作用，不影响已经记录的计数
- 每层递归只负责本层的逆序对，递归返回值累加所有结果

#### 4. 分治思想的本质

**归并排序统计逆序对的本质：**
```
在"分治排序"的过程中，顺便把逆序对统计了
- 分治：把大问题拆成小问题（左内部、右内部、跨区间）
- 排序：让子区间有序，方便批量统计
- 统计：在合并时，利用有序性高效计数

时间复杂度：O(n log n)
不增加额外复杂度，在排序过程中顺便完成统计
```

#### 5. 索引数组技巧的掌握

**什么时候用索引数组？**
- 需要在排序的同时追踪元素原始位置
- 需要对每个元素单独统计结果
- 不能直接修改原数组

**核心操作：**
```cpp
// 创建索引数组
vector<int> index(n);
for(int i = 0; i < n; i++) index[i] = i;

// 排序索引，比较元素
比较：nums[index[cur1]] vs nums[index[cur2]]
交换：交换 index 里的值
统计：count[index[cur1]] += ...
```

**适用场景：**
- 计算右侧小于当前元素的个数
- 翻转对
- 区间和的个数
- 任何需要"追踪原始位置"的归并排序问题

#### 6. 归并排序统计问题的分类

今天4道题让我理解了归并排序统计的核心规律：

| 题目 | 统计条件 | 归并条件 | 能否合并？ | 策略 |
|------|---------|---------|----------|------|
| 逆序对 | `nums[i] > nums[j]` | `nums[cur1] <= nums[cur2]` | ✅ 可以 | 1步（归并时统计） |
| 翻转对 | `nums[i] > 2*nums[j]` | `nums[cur1] <= nums[cur2]` | ❌ 不行 | 2步（先统计，再归并） |
| 右侧更小 | 每个元素各自统计 | `nums[cur1] <= nums[cur2]` | ❌ 不行 | 需要索引数组追踪 |

**判断标准：**
- 统计条件 = 归并条件的互补 → 可以在归并时统计
- 统计条件 ≠ 归并条件的互补 → 必须分开处理

**核心技巧：**
- 统计总数 → 用 `int count`
- 统计每个元素 → 用索引数组 + `vector<int> count`
- 条件不同 → 分两步（先统计，再归并）

### 易错点总结

| 易错点 | 错误写法 | 正确写法 | 影响 |
|--------|---------|---------|------|
| 临时数组创建 | 每次递归创建局部 `tmp` | 全局 `tmp` + `resize` | 性能差 15 倍 |
| tmp 索引起点 | `k = 0` | `k = left` | 索引错位 |
| cur2 初始化 | `cur2 = right` | `cur2 = mid + 1` | 跳过元素，漏统计 |
| 缺少返回值 | 无 `return` | `return count;` | 编译错误 |
| 逆序对统计位置 | 在 `if` 分支统计 | 在 `else` 分支统计 | 逻辑错误 |
| 逆序对统计公式 | `count++` | `count += (mid - cur1 + 1)` | 漏统计 |
| 索引数组比较 | `if(index[cur1] <= index[cur2])` | `if(nums[index[cur1]] <= nums[index[cur2]])` | 比较错误 |
| 索引数组统计 | `count[cur1] += ...` | `count[index[cur1]] += ...` | 统计错误 |
| 右侧更小统计时机 | `else` 分支统计 | `if` 分支统计（左边小时） | 和逆序对相反 |

### 学习方法的收获

1. **苏格拉底式引导的威力：**
   - 通过一步步提问，自己推导出公式
   - 比直接给答案的理解更深刻
   - 从"知其然"到"知其所以然"

2. **图解的重要性：**
   - ASCII 图解帮助理解整个递归过程
   - 手动追踪一遍，比看 10 遍代码都有效
   - 复杂算法必须要"看到"执行过程

3. **错误即学习：**
   - `cur2 = right` 的错误让我深刻理解了区间划分
   - 编译错误、测试失败都是理解的机会
   - 改对比一次AC更有价值

### 明天计划

根据比特课程精品课2，明天应该继续归并排序的应用：
- 计算右侧小于当前元素的个数 - LeetCode 315
- 翻转对 - LeetCode 493

这两题都是逆序对的变形，核心思想一样，只是统计条件不同。

---

**今日状态：** ⭐⭐⭐⭐⭐  
**学习时长：** 约 3.5-4 小时（深度学习+4道题）  
**掌握程度：** 
- 归并排序：98%
- 逆序对问题：95%
- 索引数组技巧：90%
- 右侧更小元素：90%
- 翻转对问题：85%
- 归并排序统计分类：90%

**今日最大收获：** 
1. 掌握了索引数组这个高级技巧，可以在排序的同时追踪元素原始位置
2. 理解了归并排序统计问题的分类规律：统计条件和归并条件是否一致
3. 学会了判断什么时候需要分两步（翻转对），什么时候可以一步完成（逆序对）
4. 理解了整数溢出问题，学会用 `LL` 强制类型转换

**今日进步：**
- Day16完成4道题，Day15完成4道题，归并排序系列全部掌握！
- 从基础归并排序到高级应用（逆序对、索引数组、翻转对），形成完整知识体系
- 苏格拉底式学习法效果显著，虽然慢但理解深刻

---


