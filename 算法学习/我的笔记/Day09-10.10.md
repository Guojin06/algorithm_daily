# Day09 - 10月10日学习笔记

**开始时间：** 2025年10月10日  
**今日专题：** 继续二分查找 + 完成二维前缀和

## 📝 快速回顾 Day08 关键点（5分钟）

### 昨天完成情况：
- ✅ 前缀和专题全部完成（5/5题）
- ✅ 二分查找模板题（LeetCode 704）- 学会了边界条件 `left <= right`
- ✅ 查找第一个和最后一个位置（LeetCode 34）- 写了代码，待提交测试
- ⏸️ 搜索插入位置（LeetCode 35）- 未开始

### 二分查找核心模板：
```cpp
// 模板1：标准二分查找
int left = 0, right = n - 1;
while(left <= right) {  // 注意：<=
    int mid = left + (right - left) / 2;
    if(nums[mid] < target) left = mid + 1;
    else if(nums[mid] > target) right = mid - 1;
    else return mid;
}

// 模板2：左边界（第一个 >= target）
while(left < right) {
    int mid = left + (right - left) / 2;
    if(nums[mid] < target) left = mid + 1;
    else right = mid;  // 注意：不是mid-1
}

// 模板3：右边界（最后一个 <= target）
while(left < right) {
    int mid = left + (right - left + 1) / 2;  // 注意：+1
    if(nums[mid] <= target) left = mid;
    else right = mid - 1;
}
```

**关键区别：**
- 标准查找：`left <= right`，找到就返回
- 左右边界：`left < right`，最后 `left == right` 就是答案

---

## 🎯 今日任务

### 上午任务（8:30-10:30，2小时）

#### ✅ 第一件事：测试昨天第3题的代码（15分钟）

**第3题：在排序数组中查找第一个和最后一个位置（LeetCode 34）**

你昨天写的代码：
```cpp
// 昨天的代码已写好，需要提交测试
// 可能有个小bug：rightval = right 应该是 rightval = left
```

**任务：**
1. 提交代码测试
2. 如果有错误，调试修正
3. AC后记录到笔记

---

#### 第1题：搜索插入位置（LeetCode 35）

**题目描述：**
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例：**
```
输入: nums = [1,3,5,6], target = 5
输出: 2

输入: nums = [1,3,5,6], target = 2
输出: 1

输入: nums = [1,3,5,6], target = 7
输出: 4
```

**题目链接：** https://leetcode.cn/problems/search-insert-position/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第19题

**思路提示：**
- 就是找**左边界**！第一个 `>= target` 的位置
- 和昨天第3题的左边界代码几乎一样！

---

**我的思路：**
使用二分查找的左边界模板：
- 找第一个 `>= target` 的位置
- 如果target存在，返回它的位置
- 如果target不存在，返回它应该插入的位置
- 就是找左边界！

---

**我的代码（第一次WA）：**
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[left] < target) left = mid + 1;  // ❌ 错了！
            else right = mid;   
        }
        if(nums[left] < target) return left + 1;
        return left;
    }
};
```

**第一次提交结果：**
❌ WA (47/66)
- 错误用例：`nums = [1,3,5,6], target = 2`
- 我的输出：`2`
- 正确输出：`1`

---

**我的错误分析：**

**错在哪：** 判断条件写成了 `nums[left]`，应该是 `nums[mid]`！

**为什么错：**
```
nums = [1,3,5,6], target = 2

第1轮：
left = 0, right = 3
mid = 1
nums[mid] = 3

错误判断：if(nums[left] < target)
          if(nums[0] < 2)
          if(1 < 2) → true ❌
          
本应该判断：if(nums[mid] < target)
            if(3 < 2) → false
            right = mid = 1

因为判断错了，导致left错误移动到2，
最后返回2，但正确答案是1
```

**核心错误：** 搞混了 `left` 和 `mid`！
- `left`, `right` 是边界
- `mid` 是中间位置
- **二分查找判断的永远是 `nums[mid]`！**

---

**正确代码：**
```cpp
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left < right) {
            int mid = left + (right - left) / 2;
            
            // ✅ 关键：判断 nums[mid]
            if(nums[mid] < target) left = mid + 1;
            else right = mid;   
        }
        
        // 最后判断left位置
        if(nums[left] < target) return left + 1;
        return left;
    }
};
```

**第二次提交结果：** ✅ AC

---

**复杂度分析：**
- **时间复杂度：** O(log n)
- **空间复杂度：** O(1)

---

**我的收获：**
1. **搜索插入位置 = 左边界**：找第一个 `>= target` 的位置
2. **二分查找核心：** 判断的永远是 `nums[mid]`，不是 `nums[left]` 或 `nums[right]`
3. **又一个低级错误：** 之前是 `left` vs `right` 混淆，这次是 `left` vs `mid` 混淆
4. **左边界模板：**
   ```cpp
   while(left < right) {
       int mid = left + (right - left) / 2;
       if(nums[mid] < target) left = mid + 1;
       else right = mid;  // 不是mid-1
   }
   ```
5. **更简洁的写法：** `right = nums.size()`（不是size()-1），最后直接返回left




---

#### 第2题：x的平方根（LeetCode 69）

**题目描述：**
给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去** 。

**注意：** 不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

**示例：**
```
输入：x = 4
输出：2

输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

**提示：**
- `0 <= x <= 2^31 - 1`

**题目链接：** https://leetcode.cn/problems/sqrtx/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第20题

**思路提示：**
- 在 `[0, x]` 范围内二分查找
- 找最后一个满足 `mid * mid <= x` 的数（右边界）

---

**我的思路：**
使用二分查找的右边界模板：
1. 在 `[0, x]` 范围内查找
2. 找最后一个满足 `mid * mid <= x` 的数
3. 使用右边界模板：`mid = left + (right - left + 1) / 2`

---

**我的代码（第一次WA）：**
```cpp
class Solution {
public:
    int mySqrt(int x) {
        int left = 0, right = x;
        if(x < 1) return 0;
        while(left < right)
        {
            long long mid = left + (right - left + 1)/2;  // ❌ 这里有问题
            if(mid*mid <= x) left = mid;
            else right = mid - 1; 
        }
        return left;
    }
};
```

**第一次提交结果：**
❌ Runtime Error
```
Line 8: Char 50: runtime error: signed integer overflow: 
2147483647 + 1 cannot be represented in type 'int'
```

---

**我的错误分析：**

**错在哪：** 整数溢出！

**为什么溢出：**
```
测试用例：x = 2147483647 (INT_MAX)

初始化：
left = 0 (int)
right = 2147483647 (int)

计算 mid：
right - left + 1 = 2147483647 - 0 + 1 = 2147483648

问题：虽然声明了 long long mid，
但右边的 (right - left + 1) 计算还是在 int 范围内进行的！
2147483648 超过了 INT_MAX(2147483647)，溢出了！
溢出后才转成 long long，已经错了。
```

**关键理解：**
```cpp
long long mid = left + (right - left + 1) / 2;
//              ^^^^^^^^^^^^^^^^^^^^^^^^
//              这部分计算还是 int 类型！

// 需要提前转换：
long long mid = left + ((long long)right - left + 1) / 2;
//                      ^^^^^^^^^^^^^
//                      提前转成 long long
```

---

**正确代码：**
```cpp
class Solution {
public:
    int mySqrt(int x) {
        if(x < 1) return 0;
        
        int left = 0, right = x;
        while(left < right) {
            // ✅ 关键：提前转换成 long long
            long long mid = left + ((long long)right - left + 1) / 2;
            
            if(mid * mid <= x) left = mid;
            else right = mid - 1; 
        }
        return left;
    }
};
```

**第二次提交结果：** ✅ AC

---

**复杂度分析：**
- **时间复杂度：** O(log x)
- **空间复杂度：** O(1)

---

**我的收获：**
1. **类型转换陷阱：** 即使声明了 `long long mid`，如果右边的计算是 int，还是会溢出
2. **解决方案：** 提前转换 `(long long)right`，让整个表达式在 long long 范围内计算
3. **右边界模板：** `mid = left + (right - left + 1) / 2` 要加1，防止死循环
4. **二分查找的本质：** 找最后一个满足条件的数（右边界）
5. **其他解决方法：**
   - 方法2：用 `mid <= x / mid` 代替 `mid * mid <= x`（避免乘法溢出）
   - 方法3：限制 `right = min(x, 46340)`（因为 46340² < INT_MAX）




---

### 下午任务（如果时间够，可选）

#### 第3题：二维前缀和模板（可选）

**题目：** 【模板】二维前缀和

**说明：** 这是比特课程的模板题，理解概念即可，可以直接看讲解

---

#### 第4题：矩阵区域和（LeetCode 1314）⭐

**题目描述：**
给你一个 `m x n` 的矩阵 `mat` 和一个整数 `k` ，请你返回一个矩阵 `answer` ，其中每个 `answer[i][j]` 是所有满足下述条件的元素 `mat[r][c]` 的和： 
- `i - k <= r <= i + k`
- `j - k <= c <= j + k`
- `(r, c)` 在矩阵内。

**提示：**
- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n, k <= 100`

**题目链接：** https://leetcode.cn/problems/matrix-block-sum/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第32题

**思路提示：**
- 二维前缀和的应用
- 先预处理前缀和矩阵
- 然后用公式快速求区域和

---

**我的思路：**




---

**我的代码：**
```cpp

```

**提交结果：**



---

**我的收获：**




---

## 💡 今日总结

**今天完成题数：** 2/4 (搜索插入位置 + x的平方根)

**累计完成：** 26题 → 28题

**用时：** 约2小时

**今天的关键收获：**
1. **类型转换陷阱（重要！）：**
   - `long long mid = left + (right - left + 1) / 2` ❌ 右边计算还是int
   - `long long mid = left + ((long long)right - left + 1) / 2` ✅ 提前转换
   - 即使声明了long long，如果右边表达式是int，还是会溢出
   
2. **二分查找的核心：判断永远是 `nums[mid]`**
   - 不是 `nums[left]`，不是 `nums[right]`
   - `left`、`right` 是边界，`mid` 是中间位置
   - 又一次搞混了变量（之前是left vs right，这次是left vs mid）
   
3. **二分查找三大模板巩固：**
   - 标准查找：`while(left <= right)`，找到就返回
   - 左边界：`while(left < right)`，`right = mid`
   - 右边界：`while(left < right)`，`mid = left + (right - left + 1) / 2`，`left = mid`

**我遇到的问题：**
1. **整数溢出（x的平方根）：** 虽然声明了long long，但计算过程还是int，导致溢出
2. **变量混淆（搜索插入位置）：** 判断条件写成了`nums[left]`，应该是`nums[mid]`
3. **都是低级错误，但都是有价值的错误！** 调试过程中学到了本质

**明天的目标：**
- 测试昨天第3题（查找第一个和最后一个位置）
- 完成二维前缀和2题（26、32题）
- 如果有时间，继续二分查找剩余题目（山峰数组、寻找峰值等）

**今天的反思：**
- 虽然只做了2题，但每题都先WA再AC
- 通过调试，深刻理解了**类型转换**和**二分查找的核心**
- **质量 > 数量**，理解错误比盲目刷题更重要！

---

**学习进度：** Day09/150 ✅

