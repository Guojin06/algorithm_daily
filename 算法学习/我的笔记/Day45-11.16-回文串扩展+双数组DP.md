# Day45-11.16-回文串扩展 + 双数组DP专题

## 今日目标
- 回文串相关 2 题
  - 39. 回文串问题：最长回文子序列
  - 40. 回文串问题：让字符串成为回文字符串的最小插入次数
- 两个数组的 DP 问题 3 题
  - 41. 两个数组的 DP 问题：最长公共子序列
  - 42. 两个数组的 DP 问题：不相交的线
  - 43. 两个数组的 DP 问题：不同的子序列

> 今天的节奏：
> 1. 每题先搭「题目小结 + 思路框架」，我先讲解，你先自己写代码。
> 2. 你写完再对答案、补充细节和踩坑点。

---

## 39. 回文串问题：最长回文子序列

### 题目小结
- 输入：一个字符串 `s`
- 输出：`s` 中 **最长回文子序列** 的长度
- 典型对比：和「最长回文子串」（LeetCode 5）不同，这里只要求是子序列，可以不连续。

### 思路框架
- **模型类型**：区间 DP / 子序列 DP
- **状态定义**：`dp[i][j]` 表示子串 `s[i..j]` 中最长回文子序列的长度
  - 区间下标：`0 <= i <= j < n`
- **状态转移**：
  - 若 `s[i] == s[j]`：两端字符可以成对加入回文序列
    - `dp[i][j] = dp[i+1][j-1] + 2`
  - 若 `s[i] != s[j]`：两端不能同时作为回文两端，只能丢掉一个，取更优：
    - `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`
- **初始化**：
  - 单个字符本身是长度为 1 的回文子序列：`dp[i][i] = 1`
  - 其他位置默认初始化为 0，可以视作「无效区间」或长度为 0 的回文子序列。
- **遍历顺序（关键）**：
  - 外层 `i`：从右往左枚举：`for (int i = n-1; i >= 0; i--)`
  - 内层 `j`：从 `i+1` 向右枚举：`for (int j = i+1; j < n; j++)`
  - 这样能保证：
    - `dp[i+1][j-1]`、`dp[i+1][j]`：在更大的 `i` 已经计算完
    - `dp[i][j-1]`：在当前行更左边已经计算完
- **答案位置**：`dp[0][n-1]`，表示整个串的最长回文子序列长度。

### 与 LeetCode 5「最长回文子串」的对比
- 5 题关注的是 **子串是否回文**：
  - 使用 `bool dp[i][j]` 或 `isPal[i][j]` 表示 `s[i..j]` 是不是回文
  - 核心是「合法性判断」：满足条件就 `true`
- 本题关注的是 **区间内能取出的最长回文子序列长度**：
  - 使用 `int dp[i][j]` 表示「最优值」
  - 核心是「最优子结构」：两端相等就包起来，否则丢一端取最大
- 二者关系：
  - **子串版**：更偏「区间是否满足条件」，常用于计数、枚举、预处理回文区间
  - **子序列版**：是典型的「区间最优值 DP」，在子序列专题里和 LCS 有强对应（`LPS(s) = LCS(s, reverse(s))`）。

### 我的代码尝试（AC 版本）
```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0)); // 无效区间视为 0

        // 对角线初始化：单个字符是长度为 1 的回文子序列
        for (int i = 0; i < n; i++) {
            dp[i][i] = 1;
        }

        // 区间 DP：i 从右往左，j 从左往右
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
};
```

### 复盘要点
- [ ] 区间 DP 的遍历顺序是否记住？为什么 `i` 要从右到左、`j` 要从左到右？
- [ ] 和「最长回文子串」的区别：`bool isPal`（合法性） vs `int dp`（最优值）。
- [ ] 和后面 40 题「最小插入次数」的联系：
  - 设 `LPS = longestPalindromeSubseq(s)`，`n = s.length()`，则最少插入次数 = `n - LPS`。

---

## 40. 回文串问题：让字符串成为回文串的最小插入次数

### 题目小结
- 输入：一个字符串 `s`
- 操作：可以在任意位置插入任意字符
- 目标：让 `s` 变成回文串，求 **最少插入次数**

### 思路框架（解法一：区间 DP）

#### 1. 模型选择
- 本质是一个「区间内最少修改成本」的问题，目标只与区间 `s[i..j]` 相关 → 自然想到 **区间 DP**。

#### 2. 状态定义
- `dp[i][j]`：把子串 `s[i..j]` 变成回文串所需的**最少插入次数**。
- 区间范围：`0 <= i <= j < n`。
- 最终答案：`dp[0][n-1]`。

#### 3. 状态转移（从两端讨论）
- 看区间两端字符 `s[i]` 和 `s[j]`：
- **情况 1：`s[i] == s[j]`**
  - 两端已经相等，不需要为它们额外插入字符，只需要让「内部」变成回文：
  - `dp[i][j] = dp[i+1][j-1]`。
- **情况 2：`s[i] != s[j]`**
  - 两端不等，最终如果要变成回文，`s[i]` 和 `s[j]` 不能同时成为回文两端，需要通过插入字符来“配对”：
  - 选择一：在左边插入一个 `s[j]`，让左端和右端配对，内部区间是 `s[i+1..j]` → 成本 `dp[i+1][j] + 1`
  - 选择二：在右边插入一个 `s[i]`，内部区间是 `s[i..j-1]` → 成本 `dp[i][j-1] + 1`
  - 取更优：`dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1`。

#### 4. 初始化与遍历顺序
- 单个字符本身是回文：`dp[i][i] = 0`（不需要插入）。
- 不会访问 `i > j` 的区间，默认忽略即可。
- 依赖关系：`dp[i][j]` 依赖 `dp[i+1][j-1]`、`dp[i+1][j]`、`dp[i][j-1]`，所以：
  - 外层 `i` 从右往左：`for (int i = n-1; i >= 0; i--)`
  - 内层 `j` 从左往右：`for (int j = i+1; j < n; j++)`

### 我的代码尝试（AC 版本）
```cpp
class Solution {
public:
    int minInsertions(string s) {
        int n = s.size();
        // 状态定义：dp[i][j] 把子串 s[i..j] 变成回文串的最小插入次数
        vector<vector<int>> dp(n, vector<int>(n, 0));

        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
                }
            }
        }
        return dp[0][n - 1];
    }
};
```

### 复盘要点（如何想到这个状态？）
- [ ] **先想“能不能只看一个位置”**：
  - 本题问的是「整个串最少插入次数」，如果只看前缀 `s[0..i]` 很难表达「两端配对」的行为 → 倾向于用区间。
- [ ] **两端对称的题，优先考虑 `s[i]` 和 `s[j]`**：
  - 回文的定义就是「两端相等」，所以自然去讨论 `s[i] == s[j]` / `s[i] != s[j]`。
  - 一旦从两端讨论，`dp[i][j]` 这种区间状态几乎是“顺着题意长出来的”。
- [ ] **从“最后一步”去想转移**：
  - 把 `s[i..j]` 变成回文，最后一步一定是「两端已经配好对」。
  - 若两端本来就相等 → 只需要让中间变回文 → `dp[i+1][j-1]`。
  - 若两端不等 → 只能多插一个字符，让某一端和另一端配对，所以是 `min(dp[i+1][j], dp[i][j-1]) + 1`。
- [ ] **与 39 题 / LPS 的关系**：
  - 39 题求的是「最多能保留多少个字符构成回文」；
  - 本题是「最少要补多少个字符让它变回文」；
  - 通过「能保留的最多 + 必须补的最少 = 总长度」可以得到第二种做法：最少插入次数 = `n - LPS`。

### 解法二：LPS = LCS(s, reverse(s))
#### 思路
- 先求出字符串 `s` 的**最长回文子序列长度** `LPS`：
  - 方法：把 `t = reverse(s)`，然后做一遍 LCS：`LPS(s) = LCS(s, t)`。
- 再根据结论：最少插入次数 = `n - LPS`。

#### 代码实现（LCS 写法）
```cpp
class Solution {
public:
    int minInsertions(string s) {
        int n = s.size();
        string t = s;
        reverse(t.begin(), t.end()); // t = reverse(s)

        // dp[i][j] = s 前 i 个字符 与 t 前 j 个字符 的 LCS 长度
        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (s[i - 1] == t[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        int LPS = dp[n][n];
        return n - LPS;
    }
};

#### 解法一 vs 解法二
- 解法一：直接在区间 `s[i..j]` 上做「最少插入次数」的区间 DP。
- 解法二：先用双序列 DP（LCS）求出 `LPS`，再由 `n - LPS` 反推最少插入次数。
- 模型视角：
  - 区间 DP 视角：`dp[i][j]` = 区间最小代价（解法一）。
  - 双序列 DP 视角：`LPS(s) = LCS(s, reverse(s))`（解法二），和后面的 LCS 专题衔接。

---

## 41. 两个数组的 DP 问题：最长公共子序列

### 题目小结
- 经典 LCS 问题
- 输入：两个字符串 / 数组
- 输出：最长公共子序列长度

### 思路框架（待后面填）
- 状态：`dp[i][j]` = 前 `i` 与前 `j` 的 LCS 长度
- 维度：`0..m, 0..n` 带「空前缀」
- 转移：讨论 `A[i-1]` 与 `B[j-1]` 是否相等

### 我的代码尝试
```cpp
// 在这里先自己尝试写代码
```

### 复盘要点
- [ ] 和最长回文子序列有什么对应关系？

---

## 42. 两个数组的 DP 问题：不相交的线

### 题目小结
- 输入：两个数组 `nums1`, `nums2`
- 操作：在两数组中连线，相等的数字可以连线，但线之间不能相交
- 输出：最多能连多少条线

### 思路框架（待后面填）
- 本质：**还是 LCS**，只是题面换了个说法

### 我的代码尝试
```cpp
// 在这里先自己尝试写代码
```

### 复盘要点
- [ ] 能否一眼看出是 LCS 模型？

---

## 43. 两个数组的 DP 问题：不同的子序列

### 题目小结
- 输入：`s`, `t`
- 输出：`s` 中有多少个子序列等于 `t`

### 思路框架（待后面填）
- 状态：`dp[i][j]` = `s` 前 `i` 个字符中，形成 `t` 前 `j` 个字符的方案数
- 注意：计数型 DP，容易溢出 / 下标错

### 我的代码尝试
```cpp
// 在这里先自己尝试写代码
```

### 复盘要点
- [ ] 初始化：`dp[i][0]` 为什么是 1？
- [ ] 遍历顺序 + 溢出风险

---

## 今日总结（留空，晚上写完统一补）

