# Day13 - 10月14日 位运算进阶专题

## 今日学习目标
- 完成位运算进阶5题
- 深入理解位运算的高级应用场景
- 掌握位运算在算法优化中的作用

## 学习计划
根据比特课程安排，今天继续位运算专题的进阶内容。昨天已经完成了5道基础位运算题目：
- ✅ LeetCode 191 - 位1的个数
- ✅ LeetCode 338 - 比特位计数  
- ✅ LeetCode 461 - 汉明距离
- ✅ LeetCode 136 - 只出现一次的数字
- ✅ LeetCode 260 - 只出现一次的数字III

今天需要观看课程视频，确定后续5道位运算进阶题目，继续深化学习。

## 位运算核心概念回顾
从昨天的学习中掌握了以下关键技巧：

### 1. 基本位操作
- **左移 (`<<`)**: 相当于乘以2的幂次，`n << k = n * 2^k`
- **右移 (`>>`)**: 相当于除以2的幂次，`n >> k = n / 2^k`
- **按位与 (`&`)**: 
  - `n & 1` 检查最低位是否为1
  - `n & (n-1)` 清除最低位的1（经典技巧）
  - `n & (-n)` 获取最低位的1
- **按位或 (`|`)**: 设置特定位为1
- **按位异或 (`^`)**: 
  - `a ^ a = 0`, `a ^ 0 = a` (消消乐性质)
  - 用于找唯一元素、分组等

### 2. 经典应用模式
- **计数模式**: 统计二进制中1的个数
- **消除模式**: 利用XOR的性质消除重复元素
- **分组模式**: 根据某一位的不同进行分组
- **DP优化**: `ans[i] = ans[i>>1] + (i&1)` 利用位运算优化状态转移

## 今日题目计划
根据比特课程精品课2，位运算进阶专题（第33-37题）：

### 第33题：面试题01.01 - 判定字符是否唯一 ⭐ (Easy)
- **核心技巧**: 位图思想，用int的32位表示字符
- **应用场景**: 字符唯一性检测，空间优化

### 第34题：LeetCode 268 - 丢失的数字 ⭐ (Easy) 
- **核心技巧**: 异或性质 `a ^ a = 0`, `a ^ 0 = a`
- **应用场景**: 数组中缺失元素的查找

### 第35题：LeetCode 371 - 两整数之和 ⭐⭐ (Medium)
- **核心技巧**: 异或实现无进位加法，与运算实现进位
- **应用场景**: 不使用+/-实现加法运算

### 第36题：LeetCode 137 - 只出现一次的数字II ⭐⭐⭐ (Medium)
- **核心技巧**: 位计数法，统计每位出现次数
- **应用场景**: 处理出现3次vs1次的元素查找

### 第37题：面试题17.19 - 消失的两个数字 ⭐⭐⭐ (Hard)
- **核心技巧**: 综合应用268题+260题的位运算技巧
- **应用场景**: 复杂的缺失元素查找问题

---

## 第33题：面试题01.01 - 判定字符是否唯一 ⭐ (Easy)

### 题目描述
实现一个算法，确定一个字符串 s 的所有字符是否全都不同。

**示例 1：**
```
输入: s = "leetcode"
输出: false
```

**示例 2：**
```  
输入: s = "abc"
输出: true
```

**限制：**
- 0 <= len(s) <= 100
- s[i]仅包含小写字母
- 如果你不使用额外的数据结构，会很加分。

### 解题思路提示
💡 **位图思想**: 
- 考虑用一个int的32位来表示26个小写字母
- 每一位代表一个字符是否出现过
- 0表示未出现，1表示已出现
- 可以把整数当作"哈希表"使用

💡 **关键操作**:
- 如何检查某一位是否为1？
- 如何将某一位设为1？
- 可以用鸽巢原理做什么优化？

💡 **位运算基本操作复习**:
- 右移 `>>`: 检查特定位
- 左移 `<<`: 设置特定位
- 按位与 `&`: 用于检查
- 按位或 `|`: 用于设置

### 我的代码

**法一：哈希表方法**
```cpp
class Solution {
public:
    bool isUnique(string astr) {
        int hash[26] = {};
        int n = astr.size();
        for(int i = 0 ; i < n ; i++)
        {
            if(hash[astr[i] - 'a'] > 0 ) return false; 
            else  hash[astr[i] - 'a']++;
        }
        return true;
    }
};
```

### 运行结果

**哈希表方法：✅ AC**

### 错误分析

**第一次尝试错误**：
- 问题：`hash[astr[i]]++` 使用了字符的ASCII值（如'l'=108）作为索引
- 修正：改为 `hash[astr[i] - 'a']`，将字符转换为0-25的索引

**关键知识点**：
- 字符索引转换：`ch - 'a'` 可以将 'a'-'z' 映射到 0-25
- 数组初始化：`int hash[26] = {}` 可以将所有元素初始化为0

---

**法二：位图方法**

第一次尝试：
```cpp
class Solution {
public:
    bool isUnique(string astr) {
        //利用位图思想，
        if(astr.size() > 26) return false;//鸽巢原理，先优化一下
        int bitMap = 0;
        for(int i : bitMap)  //❌ 错误1
        {
            if((bitMap >>i & 1) == 1) return false;//说明出现过
            else bitMap |= (i << 1);//❌ 错误2
        }
        return true;
    }
};
```

**编译错误**：
```
Line 7: Char 19: error: invalid range expression of type 'int'; no viable 'begin' function available
    7 |         for(int i : bitMap)
```

**错误分析**：
1. **`for(int i : bitMap)` 错误**：
   - bitMap 是 `int` 类型，不是容器，不能用范围for循环
   - 应该遍历**字符串** `astr`，而不是遍历 bitMap
   - 正确：`for(auto ch : astr)` 或 `for(int i = 0; i < n; i++)`

2. **`bitMap |= (i << 1)` 错误**：
   - 应该是 `1 << i`（1左移i位），而不是 `i << 1`（i左移1位）
   - 比如要设置第5位：应该是 `1 << 5 = 32`，而不是 `5 << 1 = 10`

3. **缺少字符索引转换**：
   - 需要将字符转换为位索引：`int i = ch - 'a'`

**修正提示**：
- 遍历字符串 `astr`
- 对每个字符 `ch`，计算 `i = ch - 'a'`
- 检查和设置位图时使用这个 `i`

---

第二次尝试（还是编译错误）：
```cpp
class Solution {
public:
    bool isUnique(string astr) {
        if(astr.size() > 26) return false;
        int bitMap = 0;
        for(auto ch : bitMap)  //❌ 还是错了！
        {
            int i = ch -'a';
            if((bitMap >>i & 1) == 1) return false;
            else bitMap |= (i << 1);  //❌ 还有这里也错了
        }
        return true;
    }
};
```

**你还是犯了同样的错误！**
- ❌ `for(auto ch : bitMap)` —— **bitMap 是 int，不能遍历！**
- ✅ `for(auto ch : astr)` —— **应该遍历字符串 astr！**

**再强调一遍**：
1. `bitMap` 只是一个整数变量，用来存储26个字母的状态
2. 你需要遍历的是**字符串** `astr`，获取每个字符 `ch`
3. 然后把字符 `ch` 转换成位索引 `i = ch - 'a'`
4. 设置位时是 `1 << i`，不是 `i << 1`

**正确的循环应该是**：
```cpp
for(auto ch : astr) {  // 遍历字符串！
    int i = ch - 'a';
    if(((bitMap >> i) & 1) == 1) return false;
    else bitMap |= (1 << i);  // 是 1 << i，不是 i << 1
}
```

再仔细看看，修正这两个地方！💪

---

第三次尝试（AC ✅）：
```cpp
class Solution {
public:
    bool isUnique(string astr) {
        //利用位图思想，
        if(astr.size() > 26) return false;//鸽巢原理，先优化一下
        int bitMap = 0;
        for(auto ch : astr)
        {
            int i = ch - 'a';
            if((bitMap >> i & 1) == 1) return false;//说明出现过
            else bitMap |= (1 << i);//如果没出现，先生成第i位为1的数，再和bitMap或运算
        }
        return true;
    }
};
```

**运行结果：✅ AC**

### 核心知识点总结

**位图方法 vs 哈希表方法对比**：
| 方法 | 空间复杂度 | 实现方式 |
|------|-----------|---------|
| 哈希表 | O(26) = O(1) | 用数组 `int hash[26]` |
| 位图 | O(1) | 用一个 `int bitMap` 变量 |

**位图的核心操作**：
1. **检查第i位是否为1**：`(bitMap >> i) & 1`
   - 右移i位，让目标位移到最低位
   - 与1做按位与，只保留最低位

2. **将第i位设置为1**：`bitMap |= (1 << i)`
   - `1 << i`：生成只有第i位为1的数（如 `1 << 3 = 0b1000`）
   - `|=`：按位或，将该位设置为1

3. **鸽巢原理优化**：`if(astr.size() > 26) return false`
   - 26个小写字母，如果字符串长度>26，必然有重复

**关键错误回顾**：
- ❌ `for(auto ch : bitMap)` → ✅ `for(auto ch : astr)`（遍历字符串）
- ❌ `hash[astr[i]]` → ✅ `hash[astr[i] - 'a']`（字符转索引）
- ❌ `bitMap |= (i << 1)` → ✅ `bitMap |= (1 << i)`（1左移i位）

**位图的优势**：
- 节省空间：用1个int（4字节）代替26个int（104字节）
- 操作快速：位运算比数组访问更快
- 面试加分：体现对位运算的深入理解

---

## 第34题：LeetCode 268 - 丢失的数字 ⭐ (Easy)

### 题目描述
给定一个包含 `[0, n]` 中 n 个数的数组 `nums`，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

**示例 1：**
```
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字。
```

**示例 2：**
```
输入：nums = [0,1]
输出：2
```

**示例 3：**
```
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
```

**示例 4：**
```
输入：nums = [0]
输出：1
```

**提示：**
- n == nums.length
- 1 <= n <= 10^4
- 0 <= nums[i] <= n
- nums 中的所有数字都独一无二
- **进阶**：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

### 解题思路提示

💡 **异或的"消消乐"性质**：
- 回顾昨天学的：`a ^ a = 0`, `a ^ 0 = a`
- 如果把所有数都异或在一起，相同的数会互相抵消

💡 **问题转换**：
- 完整的序列应该是：`[0, 1, 2, ..., n]`
- 数组中缺少了一个数
- 如果把**数组中的所有数** + **[0, n]中的所有数**都异或在一起会怎样？

💡 **举例理解**：
```
数组：[3, 0, 1]  (缺少2)
完整：[0, 1, 2, 3]

异或过程：
数组中的数: 3 ^ 0 ^ 1
完整序列:   0 ^ 1 ^ 2 ^ 3
合并:       (3^3) ^ (0^0) ^ (1^1) ^ 2 = 0 ^ 0 ^ 0 ^ 2 = 2
```

💡 **算法框架**：
```cpp
int ret = 0;
// 1. 先把数组中所有数异或起来
// 2. 再把[0, n]中所有数异或起来
// 3. 返回ret
```

### 我的代码

第一次尝试：
```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int ret1,ret2 = 0;  //❌ 错误！
        //先得到完全的数
        for(int i = 0 ; i <= n ; i++)
        {
            ret1 ^= i;
        }
        //再得到数组异或的数
        for(int i = 0 ; i < n ; i++)
        {
            ret2 ^= nums[i];
        }
        int ret = ret1 ^ ret2;
        return ret;
    }
};
```

### 运行结果

**解答错误**：
```
0 / 122 个通过的测试用例
输入：nums = [3,0,1]
输出：-262537124
预期结果：2
```

### 错误分析

**关键错误：变量初始化陷阱！**

你的代码：
```cpp
int ret1, ret2 = 0;
```

**问题分析**：
- 这行代码**只初始化了 `ret2 = 0`**！
- `ret1` **没有被初始化**，是一个随机的垃圾值！
- 所以 `ret1` 可能是 -262537124 或其他随机值

**C++变量初始化规则**：
- ❌ `int a, b = 0;` → 只有 `b` 被初始化为0，`a` 是随机值
- ✅ `int a = 0, b = 0;` → 两个都被初始化为0

**修正方法1（两个变量）**：
```cpp
int ret1 = 0, ret2 = 0;  // 两个都初始化
```

**修正方法2（更优雅，只用一个变量）**：
```cpp
int ret = 0;
// 先异或数组中的数
for(auto x : nums) ret ^= x;
// 再异或完整序列的数
for(int i = 0; i <= nums.size(); i++) ret ^= i;
return ret;
```

因为异或满足**交换律和结合律**，所以可以在一个变量中完成所有异或操作！

---

### 多种解法对比

**解法1：哈希表方法**

💡 **思路提示**：
- 用一个哈希表（或数组）记录数组中出现过的数
- 然后遍历 `[0, n]`，找到第一个没出现过的数

💡 **具体步骤**：
1. 创建一个哈希表（或布尔数组 `bool hash[n+1]`）
2. 遍历数组，把出现的数标记为 true
3. 遍历 `[0, n]`，找到第一个为 false 的位置

💡 **复杂度**：
- 时间：O(n)
- 空间：O(n)（需要额外的哈希表）

**解法2：位运算（异或）方法**

💡 **思路**：利用 `a ^ a = 0` 的性质

💡 **复杂度**：
- 时间：O(n)
- 空间：O(1)（只需要一个变量）

**解法3：数学方法（求和公式）**

💡 **思路提示**：
- 完整序列的和：`0 + 1 + 2 + ... + n = n * (n + 1) / 2`
- 数组实际的和：`sum(nums)`
- 缺失的数 = 完整和 - 实际和

💡 **复杂度**：
- 时间：O(n)
- 空间：O(1)

💡 **注意事项**：
- 需要注意大数溢出问题（n 很大时）

---

你想用哪种方法实现？建议先把**位运算方法AC**，因为它是这道题的核心考点（O(1)空间）。其他方法可以作为扩展理解！💪

---

**修正后的AC代码（位运算方法）：**
```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int n = nums.size();
        int ret = 0;  //更优雅的写法一个变量就够了
        for(auto x : nums) ret ^= x;
        for(int i = 0; i <= nums.size(); i++) ret ^= i;
        return ret;
    }
};
```

**运行结果：✅ AC**

### 核心知识点总结

**1. 异或的核心性质**：
- `a ^ a = 0`（相同的数异或为0）
- `a ^ 0 = a`（任何数与0异或等于自己）
- **交换律**：`a ^ b = b ^ a`
- **结合律**：`(a ^ b) ^ c = a ^ (b ^ c)`

**2. 算法原理**：
```
数组：[3, 0, 1]  (n=3，缺少2)
完整：[0, 1, 2, 3]

ret = 0
步骤1：ret ^= 3 ^= 0 ^= 1  → ret = 3^0^1
步骤2：ret ^= 0 ^= 1 ^= 2 ^= 3  → ret = 3^0^1^0^1^2^3
简化：ret = (3^3) ^ (0^0) ^ (1^1) ^ 2 = 0 ^ 0 ^ 0 ^ 2 = 2 ✅
```

**3. C++易错点**：
- ❌ `int a, b = 0;` → 只有b被初始化，a是随机值
- ✅ `int a = 0, b = 0;` → 两个都被初始化
- ✅ `int ret = 0;` → 必须初始化为0才能正确异或

**4. 时间空间复杂度**：
- 时间复杂度：O(n)
- 空间复杂度：O(1)（只用了一个额外变量）

**5. 扩展思考**：
这道题展示了异或在"消消乐"场景中的强大应用，类似的题目：
- 昨天的 LeetCode 136 - 只出现一次的数字
- 昨天的 LeetCode 260 - 只出现一次的数字III

---

## 第35题：LeetCode 371 - 两整数之和 ⭐⭐ (Medium)

### 题目描述
给你两个整数 a 和 b，**不使用运算符 + 和 -**，计算并返回两整数之和。

**示例 1：**
```
输入：a = 1, b = 2
输出：3
```

**示例 2：**
```
输入：a = 2, b = 3
输出：5
```

**提示：**
- -1000 <= a, b <= 1000

### 解题思路提示

💡 **核心思想：用位运算模拟加法**

**回顾小学加法过程**：
```
    1 0 1 1  (11)
+   0 1 1 1  (7)
-----------
  1 0 0 1 0  (18)
```

分为两步：
1. **不考虑进位的相加**（逐位相加）
2. **计算进位**

💡 **位运算对应关系**：
1. **无进位加法** → **异或 (^)**
   - `0 + 0 = 0` → `0 ^ 0 = 0`
   - `0 + 1 = 1` → `0 ^ 1 = 1`
   - `1 + 0 = 1` → `1 ^ 0 = 1`
   - `1 + 1 = 0`（不考虑进位）→ `1 ^ 1 = 0`

2. **进位** → **与运算后左移 ((a & b) << 1)**
   - 只有 `1 + 1` 会产生进位
   - `a & b` 找出所有同时为1的位
   - `<< 1` 进位要向左移一位

💡 **算法流程**：
```
循环直到没有进位(b == 0)：
  1. 计算无进位加法结果：x = a ^ b
  2. 计算进位：carry = (a & b) << 1
  3. 更新：a = x, b = carry
返回 a
```

💡 **举例说明**：
```
a = 5 (101), b = 3 (011)

第1轮：
  x = 101 ^ 011 = 110  (无进位加法)
  carry = (101 & 011) << 1 = 001 << 1 = 010  (进位)
  a = 110, b = 010

第2轮：
  x = 110 ^ 010 = 100
  carry = (110 & 010) << 1 = 010 << 1 = 100
  a = 100, b = 100

第3轮：
  x = 100 ^ 100 = 000
  carry = (100 & 100) << 1 = 100 << 1 = 1000
  a = 000, b = 1000

第4轮：
  x = 000 ^ 1000 = 1000
  carry = (000 & 1000) << 1 = 000 << 1 = 0
  a = 1000, b = 0

b == 0，循环结束，返回 a = 1000 (8) ✅
```

💡 **注意事项**：
- C++中需要将进位转换为 `unsigned int`，避免负数左移的未定义行为
- Java中直接用 `int` 即可

### 我的代码

```cpp
class Solution {
public:
    int getSum(int a, int b) {
        //异或是无进位相加，所以我们还要算出进位，然后进位再左移1这样就再进行异或即可
        
        while(b != 0)  //在进位为0时结束
        {
            int x = a ^ b;
            unsigned int carry = (unsigned int)(a & b) << 1;
            a = x;
            b = carry;
        }
        return a;
    }
};
```

### 运行结果
✅ AC

### 核心知识点：为什么需要 unsigned int？

**问题：负数左移是未定义行为**

**C++标准规定**：
- 负数的左移操作是**未定义行为（Undefined Behavior）**
- 不同编译器可能有不同的处理方式，可能导致程序崩溃或产生错误结果

**什么情况下会出现负数左移？**

考虑这个例子：
```cpp
a = -1 (补码: 11111111111111111111111111111111)
b = -2 (补码: 11111111111111111111111111111110)

a & b = 11111111111111111111111111111110 (这是一个负数！)

如果直接 (a & b) << 1，就是负数左移！
```

**为什么 unsigned int 能解决问题？**

```cpp
unsigned int carry = (unsigned int)(a & b) << 1;
```

1. `a & b` 计算出进位的位置（可能是负数）
2. `(unsigned int)(a & b)` 将其转换为无符号数
   - 补码表示不变，但解释方式改变
   - 比如 `-2` 的补码转为 `unsigned int` 就是一个很大的正数
3. 无符号数左移是安全的，不会有未定义行为

**具体例子**：
```cpp
// 负数情况
a = -1, b = -2

a & b = 11111111111111111111111111111110 (作为int是-2)

转换为unsigned int:
(unsigned int)(-2) = 4294967294

左移1位: 4294967294 << 1 = 4294967292

赋值给b: b = 4294967292 (自动转回int，补码不变)
```

**关键理解**：
- `unsigned int` 只是为了**安全地进行左移操作**
- 补码表示本身不变，只是告诉编译器"这是无符号数，可以安全左移"
- 最终赋值给 `b` 时会自动转回 `int`，补码保持不变

**总结**：
- ❌ `int carry = (a & b) << 1;` → 负数左移，未定义行为
- ✅ `unsigned int carry = (unsigned int)(a & b) << 1;` → 安全的左移操作

---

## 第36题：LeetCode 137 - 只出现一次的数字II ⭐⭐⭐ (Medium)

### 题目描述
给你一个整数数组 `nums`，除某个元素仅出现**一次**外，其余每个元素都恰出现**三次**。请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法且不使用额外空间来解决此问题。

**示例 1：**
```
输入：nums = [2,2,3,2]
输出：3
```

**示例 2：**
```
输入：nums = [0,1,0,1,0,1,99]
输出：99
```

**提示：**
- 1 <= nums.length <= 3 * 10^4
- -2^31 <= nums[i] <= 2^31 - 1
- nums 中，除某个元素仅出现一次外，其余每个元素都恰出现三次

### 我的代码

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret = 0;
        for(int i = 0; i < 32; i++)  //依次去修改ret的每一位
        {
            int sum = 0;  //计算nums所有数在第i位的和
            for(int j = 0; j < nums.size(); j++)
            {
                if(((nums[j] >> i) & 1) == 1) sum++;
            }
            sum %= 3;
            if(sum == 1) ret |= (1 << i); 
        }
        return ret;
    }
};
```

### 运行结果
✅ AC

### 核心算法：位计数法

**核心思想**：
- 其他数都出现3次，只有目标数出现1次
- 对于每一位，统计所有数在该位上1的个数
- 如果这个和 `% 3 == 1`，说明目标数在该位上是1
- 如果这个和 `% 3 == 0`，说明目标数在该位上是0

**举例说明**：
```
nums = [2, 2, 3, 2]
转为二进制：
2: 010
2: 010
3: 011  ← 目标数
2: 010

第0位（从右往左）：0+0+1+0 = 1  → 1 % 3 = 1 → ret的第0位是1
第1位：1+1+1+1 = 4  → 4 % 3 = 1 → ret的第1位是1
第2位：0+0+0+0 = 0  → 0 % 3 = 0 → ret的第2位是0

结果：ret = 011 (二进制) = 3 ✅
```

**算法流程**：
1. 遍历32位（int范围）
2. 对于第i位：
   - 统计所有数在第i位上1的个数 `sum`
   - `sum %= 3` 得到目标数在第i位的值
   - 如果为1，用 `ret |= (1 << i)` 设置该位

**核心位操作**：
- **检查第i位**：`((nums[j] >> i) & 1) == 1`
- **设置第i位**：`ret |= (1 << i)`

**时间复杂度**：
- 外层循环32次（常数）
- 内层循环n次
- 总体：O(32n) = O(n)

**空间复杂度**：O(1)

**与昨天的区别**：
| 题目 | 其他数出现次数 | 目标数出现次数 | 解法 |
|------|--------------|--------------|------|
| LeetCode 136 | 2次 | 1次 | 异或（直接消消乐） |
| LeetCode 260 | 2次 | 1次（两个数）| 异或+分组 |
| LeetCode 137 | **3次** | 1次 | **位计数法（% 3）** |

**关键理解**：
- 异或只能处理"出现2次"的情况（因为 `a ^ a = 0`）
- 出现3次时，异或不再适用
- 位计数法是通用解法：统计每位1的个数，然后 `% k`（k是其他数出现的次数）

---

## 第37题：面试题17.19 - 消失的两个数字 ⭐⭐⭐ (Hard)

### 题目描述
给定一个数组，包含从 1 到 N 所有的整数，但其中**缺了两个数字**。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？

以任意顺序返回这两个数字均可。

**示例 1：**
```
输入: [1]
输出: [2,3]
```

**示例 2：**
```
输入: [2,3]
输出: [1,4]
```

**提示：**
- nums.length <= 30000

### 解题思路提示

💡 **这道题是前面两道题的综合！**

**问题转换**：
- 原问题：从 `[1, N]` 中缺少两个数
- 类似于：**LeetCode 268 - 丢失的数字**（缺一个数）
- 再类似于：**LeetCode 260 - 只出现一次的数字III**（找两个只出现一次的数）

💡 **算法思路（三步走）**：

**步骤1：异或所有数，得到 a ^ b**
- 把数组中的所有数异或起来
- 再把 `[1, N+2]` 的所有数异或起来
- 结果 `tmp = a ^ b`（a, b是两个缺失的数）

**步骤2：找到a和b不同的某一位**
- 因为 `a != b`，所以 `a ^ b` 至少有一位是1
- 找到这一位的位置 `diff`

**步骤3：按照diff位分组异或**
- 根据第diff位是0还是1，将所有数分成两组
- 每组分别异或，得到a和b

💡 **举例说明**：
```
输入：[2, 3]  (缺少1和4)
N = 4

步骤1：异或所有数
  数组：2 ^ 3
  完整：1 ^ 2 ^ 3 ^ 4
  tmp = (2^2) ^ (3^3) ^ 1 ^ 4 = 0 ^ 0 ^ 1 ^ 4 = 1 ^ 4 = 5
  (二进制: 101)

步骤2：找不同位
  5 = 101 (二进制)
  第0位是1，选择diff = 0

步骤3：分组异或
  第0位为1的：1, 3（数组中）+ 1, 3（完整序列）
    → 1 ^ 3 ^ 1 ^ 3 = 0（这组没有缺失的数）
    
  第0位为0的：2（数组中）+ 2, 4（完整序列）
    → 2 ^ 2 ^ 4 = 4（缺失4）
    
  等等，我算错了...让我重新算
```

💡 **关键知识点回顾**：
- **LeetCode 268**：如何用异或找一个缺失的数
- **LeetCode 260**：如何用异或+分组找两个只出现一次的数
- 结合这两个方法就能解决本题！

### 我的代码

第一次尝试：
```cpp
class Solution {
public:
    vector<int> missingTwo(vector<int>& nums) {
     //首先找到缺失的两个数字的异或结果，那么就是整体异或完整数组与缺失数组异或得到
     //找到一个分界位，利用分界位，分别与完整数组与缺失数组按异或位有无分别异或得到最终结果，分界位保证这两个数一定在两个不同组内
     unsigned int xor_ret = 0;
     for(int k:nums) xor_ret ^=k;
     for(int i = 0; i < nums.size()+2;i++) {xor_ret^= i;}  //❌ 错误1
     //找分界位
    unsigned int diff = xor_ret & (-xor_ret);
    //利用分界位划分
    int a = 0 ,b = 0 ;
    for(int num : nums)//先对缺失数组异或第一次
    { 
        if((diff & num) == 1) a^= num;  //❌ 错误2
        else b^= num;
    }
    for(int i = 0 ; i < nums.size() + 2;i++)  //❌ 错误1
    {
        if((diff & i) ==1) a^= i;  //❌ 错误2
        else b^= i;
    }
    return {a,b};
    }
};
```

### 运行结果
**解答错误**：
```
0 / 44 个通过的测试用例
输入：nums = [1]
输出：[0,2]
预期结果：[3,2]
```

### 错误分析

**错误1：循环范围错误**

你的代码：
```cpp
for(int i = 0; i < nums.size()+2; i++)
```

**问题分析**：
- 题目说的是包含从 **1 到 N** 的整数（不是从0开始！）
- `nums = [1]` 意味着完整序列是 `[1, 2, 3]`（N=3）
- 你的循环是 `i = 0, 1, 2`，异或了 `0 ^ 1 ^ 2`
- 正确应该是 `i = 1, 2, 3`，异或 `1 ^ 2 ^ 3`

**修正**：
```cpp
for(int i = 1; i <= nums.size() + 2; i++)  // 从1开始，到N+2
```

---

**错误2：分组判断条件错误**

你的代码：
```cpp
if((diff & num) == 1) a ^= num;
```

**问题分析**：
- `diff = xor_ret & (-xor_ret)` 得到的是**最低位的1**
- 比如：
  - `xor_ret = 5 (101)`，`diff = 1 (001)`，此时 `diff & num` 可能等于1
  - `xor_ret = 6 (110)`，`diff = 2 (010)`，此时 `diff & num` 可能等于2，**不等于1**！

**举例说明**：
```cpp
diff = 2 (010)  // 第1位是1
num = 3 (011)   // 第1位也是1

diff & num = 010 & 011 = 010 = 2
2 != 1，但应该判断为同一组！
```

**修正方法1（判断是否不为0）**：
```cpp
if((diff & num) != 0) a ^= num;
else b ^= num;
```

**修正方法2（判断是否等于diff）**：
```cpp
if((diff & num) == diff) a ^= num;
else b ^= num;
```

**原理**：
- `diff` 只有一位是1，其他位都是0
- `diff & num` 的结果要么是0（该位为0），要么是diff（该位为1）
- 所以应该判断 `!= 0` 或 `== diff`

---

**总结两个错误**：
1. ❌ `for(int i = 0; i < nums.size()+2; i++)` → ✅ `for(int i = 1; i <= nums.size()+2; i++)`
2. ❌ `if((diff & num) == 1)` → ✅ `if((diff & num) != 0)` 或 `if((diff & num) == diff)`

---

**修正后的正确代码**：
```cpp
class Solution {
public:
    vector<int> missingTwo(vector<int>& nums) {
     //首先找到缺失的两个数字的异或结果，那么就是整体异或完整数组与缺失数组异或得到
     //找到一个分界位，利用分界位，分别与完整数组与缺失数组按异或位有无分别异或得到最终结果，分界位保证这两个数一定在两个不同组内
     unsigned int xor_ret = 0;
     for(int k:nums) xor_ret ^=k;
     
     // 修改1：从1开始，到nums.size()+2（包含），因为题目范围是[1, N]
     for(int i = 1; i <= nums.size()+2; i++) {xor_ret^= i;}  // ✅ 改：0 -> 1，< -> <=
     
     //找分界位
    unsigned int diff = xor_ret & (-xor_ret);
    
    //利用分界位划分
    int a = 0 ,b = 0 ;
    for(int num : nums)//先对缺失数组异或第一次
    { 
        // 修改2：判断是否不为0，因为diff不一定是1
        if((diff & num) != 0) a^= num;  // ✅ 改：== 1 -> != 0
        else b^= num;
    }
    
    // 修改1：从1开始，到nums.size()+2（包含）
    for(int i = 1; i <= nums.size() + 2; i++)  // ✅ 改：0 -> 1，< -> <=
    {
        // 修改2：判断是否不为0
        if((diff & i) != 0) a^= i;  // ✅ 改：== 1 -> != 0
        else b^= i;
    }
    return {a,b};
    }
};
```

**修改总结**：
- **修改1**：循环范围从 `i = 0; i < n+2` 改为 `i = 1; i <= n+2`（2处）
- **修改2**：判断条件从 `== 1` 改为 `!= 0`（2处）

**运行结果**：✅ AC

### 核心知识点总结

**综合应用了两道经典题目**：
1. **LeetCode 268 - 丢失的数字**：
   - 用异或找一个缺失的数
   - 核心：数组元素 ^ 完整序列 = 缺失的数

2. **LeetCode 260 - 只出现一次的数字III**：
   - 用异或+分组找两个只出现一次的数
   - 核心：找分界位，按分界位分组异或

**本题算法三步走**：
```
步骤1：异或得到 a ^ b
  - 数组所有元素异或
  - [1, N+2] 所有元素异或
  - 结果 = a ^ b（两个缺失数的异或）

步骤2：找分界位 diff
  - diff = (a ^ b) & (-(a ^ b))
  - 得到最低位的1的位置
  - 这一位上 a 和 b 必然不同

步骤3：按 diff 分组异或
  - 第diff位为1的一组
  - 第diff位为0的一组
  - 每组分别异或得到 a 和 b
```

**易错点回顾**：
1. **题目范围是 [1, N]，不是 [0, N-1]**
   - 循环要从 1 开始：`for(int i = 1; i <= n+2; i++)`
   
2. **分组判断不能用 `== 1`**
   - `diff` 不一定是1，可能是2, 4, 8等
   - 应该用 `!= 0` 或 `== diff`

**时间空间复杂度**：
- 时间复杂度：O(n)
- 空间复杂度：O(1)

---

## 今日总结

### 完成情况
- ✅ **完成题目数：5/5** 🎉 全部完成！

### 今日题目回顾

| 题号 | 难度 | 核心技巧 | 状态 |
|------|------|---------|------|
| 面试题01.01 | ⭐ Easy | 位图思想（int当哈希表） | ✅ AC |
| LeetCode 268 | ⭐ Easy | 异或消消乐 | ✅ AC |
| LeetCode 371 | ⭐⭐ Medium | 位运算实现加法 | ✅ AC |
| LeetCode 137 | ⭐⭐⭐ Medium | 位计数法（%3） | ✅ AC |
| 面试题17.19 | ⭐⭐⭐ Hard | 综合应用（268+260） | ✅ AC |

### 关键收获

**1. 位图思想**
- 用int的32位表示状态，节省空间
- 核心操作：检查位 `(bitMap >> i) & 1`，设置位 `bitMap |= (1 << i)`

**2. 异或的强大应用**
- 消消乐性质：`a ^ a = 0`, `a ^ 0 = a`
- 交换律和结合律：可以任意调换顺序
- 找缺失/唯一元素的利器

**3. 位运算实现加法**
- 异或 = 无进位加法
- 与+左移 = 进位
- 负数左移需要用 `unsigned int` 避免未定义行为

**4. 位计数法**
- 当异或不适用时（如出现3次）
- 统计每位1的个数，然后 `% k`
- 通用且强大的解法

**5. 异或分组技巧**
- 找到不同的位作为分界
- `diff = x & (-x)` 获取最低位的1
- 按 `(diff & num) != 0` 分组

### 易错点总结

**C++语法易错点**：
- ❌ `int a, b = 0;` → 只初始化b
- ✅ `int a = 0, b = 0;` → 都初始化
- ❌ 负数左移未定义行为
- ✅ 用 `unsigned int` 安全左移
- ❌ `for(auto ch : bitMap)` → int不能遍历
- ✅ `for(auto ch : astr)` → 遍历字符串

**位运算易错点**：
- ❌ `bitMap |= (i << 1)` → i左移1位
- ✅ `bitMap |= (1 << i)` → 1左移i位
- ❌ `hash[astr[i]]` → ASCII值作索引
- ✅ `hash[astr[i] - 'a']` → 转为0-25
- ❌ `if((diff & num) == 1)` → diff不一定是1
- ✅ `if((diff & num) != 0)` → 判断是否非0

**题目理解易错点**：
- ❌ 范围 `[0, n]` vs `[1, n]` → 循环起点不同
- ✅ 仔细看题目说明的范围

### 学习时长统计
- 第1题（位图）：约40分钟（包含哈希表方法）
- 第2题（异或）：约20分钟（含变量初始化错误）
- 第3题（位运算加法）：约25分钟（AC后深入理解负数左移）
- 第4题（位计数）：约30分钟（看课程理解后AC）
- 第5题（综合）：约35分钟（两个易错点调试）
- **总计：约2.5小时**

### 知识点连贯性

**昨天（Day12）→ 今天（Day13）**：
- Day12基础：异或消消乐（136）、异或分组（260）、位计数（191、338）
- Day13进阶：综合应用这些技巧解决更复杂的问题
- 完美的递进关系！✅

### 明天计划
继续位运算进阶或开始新的专题（根据比特课程安排）
