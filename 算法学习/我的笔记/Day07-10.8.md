# Day07 - 10月8日学习笔记

**开始时间：** 2025年10月8日

## 📝 快速回顾 Day06 关键点（15分钟）

### 昨天踩的坑：
1. **数组越界问题（字符串的排列）：**
   - 固定窗口初始化时，忘记检查 `s2.size() < s1.size()` 
   - 导致 `heap-buffer-overflow`
   - **教训：** 用索引前，先检查边界！

2. **可变窗口的结果更新位置（水果成篮）：**
   - 错误写法：`if(hash.size() <= 2) ret++`
   - 正确写法：`ret = max(ret, right - left + 1)`
   - **教训：** 更新长度用 `max`，不是累加！

3. **思维转换（将x减到0）：**
   - `L + R = x` 转换成 `M = sum - x`
   - 从两端移除 → 找中间最长子数组
   - 数学证明：`L + M + R = sum`，所以 `L + R = sum - M`

4. **valid计数器（最小覆盖子串）：**
   - 记录满足条件的**字符种类数**，不是总个数
   - `window[c] == target[c]` 才 `valid++`
   - `window[d] == target[d]` 才 `valid--`

### 滑动窗口模板：
```cpp
// 固定窗口
for(int i = 0; i < k; i++) { 进窗口 }
if(条件) 更新结果;
for(int right = k; right < n; right++) {
    left = right - k;
    出窗口; 进窗口; 判断条件; 更新结果;
}

// 可变窗口（求最长）
for(int left = 0, right = 0; right < n; right++) {
    进窗口;
    while(条件不满足) { 出窗口; left++; }
    更新结果 = max(ret, right - left + 1);
}

// 可变窗口（求最短）
for(int left = 0, right = 0; right < n; right++) {
    进窗口;
    while(条件满足) { 
        更新结果 = min(ret, right - left + 1);
        出窗口; left++; 
    }
}
```

---

## 🎯 今日题目（5题栈专题 - 比特课程）

**今天目标：** 掌握栈的基本应用，理解"栈模拟"的思路！

**题目来源：** 比特课程/算法精品课3.md - 栈部分

---

### 第1题：删除字符串中的所有相邻重复项（LeetCode 1047）

**题目描述：**
给出由小写字母组成的字符串 `s`，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 `s` 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**
```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。
之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

**提示：**
- `1 <= s.length <= 10^5`
- `s` 仅由小写英文字母组成

**题目链接：** https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/

**比特课程讲解：** 打开 `比特课程/算法精品课3.md`，第65题

**思路提示：**
- 这题可以用栈模拟消除过程！
- 比特课程建议：用**数组模拟栈**（string的`push_back`和`pop_back`）
- 遍历字符串，如果栈顶和当前字符相同...？

---

**我的思路：**




---

**我的代码：**
```cpp
// 在这里写你的代码
```

**提交结果：**


---

**我的错误（如果有）：**




---

**正确代码：**
```cpp
// AC代码
```

---

**复杂度分析：**
- **时间复杂度：** 
- **空间复杂度：** 

---

**我的收获：**




---

### 第3题：比较含退格的字符串（LeetCode 844）

**题目描述：**
给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：** 如果对空文本输入退格字符，文本继续为空。

**示例：**
```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。

输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。

输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

**提示：**
- `1 <= s.length, t.length <= 200`
- `s` 和 `t` 只含有小写字母以及字符 `'#'`

**题目链接：** https://leetcode.cn/problems/backspace-string-compare/

**比特课程讲解：** 打开 `比特课程/算法精品课3.md`，第66题

**思路提示：**
- 用栈模拟退格操作
- 遇到 `#` 就让栈顶出栈
- 最后比较两个处理后的字符串是否相等

---

**我的思路：**




---

**我的代码：**
```cpp
// 在这里写你的代码
```

**提交结果：**


---

**我的错误（如果有）：**




---

**正确代码：**
```cpp
// AC代码
```

---

**复杂度分析：**
- **时间复杂度：** 
- **空间复杂度：** 

---

**我的收获：**




---

### 第3题：基本计算器II（LeetCode 227）⭐⭐

**题目描述：**
给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

你可以假设给定的表达式总是有效的。所有中间结果将在 `[-2^31, 2^31 - 1]` 的范围内。

**注意：** 不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

**示例：**
```
输入：s = "3+2*2"
输出：7

输入：s = " 3/2 "
输出：1

输入：s = " 3+5 / 2 "
输出：5
```

**提示：**
- `1 <= s.length <= 3 * 10^5`
- `s` 由整数和算符 `('+', '-', '*', '/')` 组成，中间由一些空格隔开
- `s` 表示一个有效的表达式
- 表达式中的所有整数都是非负整数，且在范围 `[0, 2^31 - 1]` 内
- 题目数据保证答案是一个 32-bit 整数

**题目链接：** https://leetcode.cn/problems/basic-calculator-ii/

**比特课程讲解：** 打开 `比特课程/算法精品课3.md`，第67题

**思路提示：**
- 考虑运算符的优先级：`*` `/` 优先于 `+` `-`
- 用栈保存待计算的数字
- 遇到 `+` `-` 直接入栈，遇到 `*` `/` 先计算再入栈
- 这是本专题的难题，建议看比特课程的详细讲解！

---

**我的思路：**




---

**我的代码：**
```cpp
// 在这里写你的代码
```

**提交结果：**


---

**我的错误（如果有）：**




---

**正确代码：**
```cpp
// AC代码
```

---

**复杂度分析：**
- **时间复杂度：** 
- **空间复杂度：** 

---

**我的收获：**




---

### 第4题：字符串解码（LeetCode 394）⭐⭐

**题目描述：**
给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 `3a` 或 `2[4]` 的输入。

**示例：**
```
输入：s = "3[a]2[bc]"
输出："aaabcbc"

输入：s = "3[a2[c]]"
输出："accaccacc"

输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

**提示：**
- `1 <= s.length <= 30`
- `s` 由小写英文字母、数字和方括号 `'[]'` 组成
- `s` 保证是一个有效的输入

**题目链接：** https://leetcode.cn/problems/decode-string/

**比特课程讲解：** 打开 `比特课程/算法精品课3.md`，第68题

**思路提示：**
- 这题需要用**两个栈**！一个存数字，一个存字符串
- 遇到 `[` 的时候...？遇到 `]` 的时候...？
- 这是本专题的难题，可以看比特课程的详细讲解！

---

**我的思路：**




---

**我的代码：**
```cpp
// 在这里写你的代码
```

**提交结果：**


---

**我的错误（如果有）：**




---

**正确代码：**
```cpp
// AC代码
```

---

**复杂度分析：**
- **时间复杂度：** 
- **空间复杂度：** 

---

**我的收获：**




---

### 第5题：验证栈序列（LeetCode 946）

**题目描述：**
给定 `pushed` 和 `popped` 两个序列，每个序列中的 **值都不重复**，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 `true` ；否则，返回 `false` 。

**示例：**
```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1

输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

**提示：**
- `1 <= pushed.length <= 1000`
- `0 <= pushed[i] <= 1000`
- `pushed` 的所有元素 **互不相同**
- `popped.length == pushed.length`
- `popped` 是 `pushed` 的一个排列

**题目链接：** https://leetcode.cn/problems/validate-stack-sequences/

**比特课程讲解：** 打开 `比特课程/算法精品课3.md`，第69题

**思路提示：**
- 用栈来模拟进出栈的过程
- 一直让元素进栈，进栈的同时判断是否需要出栈
- 当所有元素模拟完毕后，如果栈中还有元素...？

---

**我的思路：**




---

**我的代码：**
```cpp
// 在这里写你的代码
```

**提交结果：**


---

**我的错误（如果有）：**




---

**正确代码：**
```cpp
// AC代码
```

---

**复杂度分析：**
- **时间复杂度：** 
- **空间复杂度：** 

---

**我的收获：**




---

## 📊 今日完成情况

| 题目 | 状态 | 用时 | 错误次数 | 关键收获 |
|------|------|------|----------|----------|
| 删除相邻重复项 |  |  |  |  |
| 比较含退格字符串 |  |  |  |  |
| 基本计算器II |  |  |  |  |
| 字符串解码 |  |  |  |  |
| 验证栈序列 |  |  |  |  |

---

## 💡 今日总结

**今天完成题数：** /5

**累计完成：** 17题 → __题

**用时：** __小时__分钟

**今天的关键收获：**
1. 
2. 
3. 

**我遇到的问题：**
1. 
2. 

**明天的目标：**
-

---

**学习进度：** Day07/150 ✅

