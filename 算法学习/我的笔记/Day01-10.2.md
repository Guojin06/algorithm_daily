# Day 01 - 10月2日 算法学习笔记

## 今日完成情况

- [x] 1. 移动零（比特课程）✅ 
- [x] 2. 两数之和（补充题）✅ ⭐⭐⭐
- [x] 3. 删除重复项（补充题）✅
- [ ] 4. 反转字符串（补充题）- 明天做
- [ ] 5. 复写零（比特课程）- 明天做

**今日完成：3/8题**  
**用时：2小时**  
**收获：双指针、哈希表基础**

---



1.移动零（比特课程）
力扣：283.移动零，简单
思路：定义两个指针，一个cur，一个dest，cur遍历数组，dest指向最后一个非零元素，如果cur指向的元素是0，则cur++，如果cur指向的元素不是0，则交换cur和dest指向的元素，cur++，dest++，直到cur遍历完数组为止。（划分成了三段区间）
代码：
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left=-1 ,right = 0;
        int n = nums.size();
        
        while(right < n)
        {
            //进行判断
            if(right != 0)
            {   
                swap(nums[left+1],nums[right++]);//此时只能交换不能直接令nums[right]为0，如果此时还没有零出现，那么会导致出错
                left++;

            }
            else right++;

        }
        return ;
    }
};
解答出错：
nums =
[0,1,0,3,12]

添加到测试用例
输出
[1,0,3,12,0]
预期结果
[1,3,12,0,0]
时间复杂度分析：O（n）级别，因为cur和dest最多都遍历了n次

⚠️ 我踩的坑：
- 把 if(right != 0) 写成了 if(nums[right] != 0)
- 教训：注意区分"索引"和"值"！
时间：40分钟（太久了，下次30分钟必须求助）


2.两数之和
leetcode：1.两数之和，简单
思路：暴力法：两层循环，时间复杂度O（n^2），空间复杂度O（1）

代码：
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0,right = n-1;
        vector<int> ret;
        for(;left < right;left++){
            for(;left < right; right--)
            {
                if(nums[left] + nums[right] == target)
                {
                    ret = {left,right};
                    
                }
                right = n-1;
            }
        }
          return ret;
    }
};
超时，且不正确
时间复杂度：O（n^2）
正确解法：
哈希：
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;  // 存储：值→索引
        
        for(int i = 0; i < nums.size(); i++)
        {
            int complement = target - nums[i];  // 需要找的另一个数
            
            if(hash.count(complement))  // 如果找到了
            {
                return {hash[complement], i};
            }
            
            hash[nums[i]] = i;  // 把当前数存入哈希表
        }
        
        return {};
    }
};
时间复杂度：O（n）
法2：暴力法：两层循环，时间复杂度O（n^2），空间复杂度O（1）

class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        
        for(int i = 0; i < n; i++)  // 第一个数
        {
            for(int j = i + 1; j < n; j++)  // 第二个数（从i+1开始）
            {
                if(nums[i] + nums[j] == target)
                {
                    return {i, j};
                }
            }
        }
        
        return {};
    }
};
⚠️ 我踩的坑：
1. 一开始想用双指针，但数组没排序，不能用！
2. 尝试在内层循环重置right，导致无限循环超时！
3. 学会了：
   - hash.count(key) 检查key是否存在
   - 哈希表：边遍历边查找
   - 暴力法：j从i+1开始，避免重复

教训：
- 双指针只适用于有序数组
- 循环变量的重置要小心，别写在循环内部
- 这题用哈希表是最优解！

⚠️ 时间复杂度理解：
- 哈希表的查找/插入：O(1) ⭐核心！
- 哈希法：n次循环 × O(1)查找 = O(n)
- 暴力法：n次循环 × n次循环 = O(n²)
- 关键：哈希把内层的"循环查找"变成了"直接查找"！

为什么哈希查找是O(1)？
- 通过哈希函数直接计算位置
- 不需要遍历，直接定位
- 就像数组arr[5]一样快

⚠️ 深入理解：为什么是"先查找，后插入"？

- 先查找，后插入 → 避免找到自己（不允许重复下标）
- 先插入，后查找 → 可以找到自己（允许重复下标）

例子：nums=[3], target=6
  先查后插：找不到 → 返回[]
  先插后查：找到自己 → 返回[0,0]

关键：查找时，当前元素在不在hash中？
  不在 → 不会找到自己 ✅
  在 → 会找到自己 ❌（如果不允许重复）


3.
双指针
代码：
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int left ,right = 0;
        int n = nums.size();
        //遍历
        for(;left<right && right < n;right++)
        {
            if(nums[right+1] == nums[right])
            {
                left = right;
                delete nums[right+1];
            }
            
        }
        return nums.size();
    }
};
编译失败
O（n）

int left ,right = 0;  // ❌ 问题1：left未初始化！
                      // 这句话只是 right=0，left是随机值！

for(;left<right && right < n;right++)  // ❌ 问题2：逻辑错了
{
    if(nums[right+1] == nums[right])  // ❌ 问题3：right+1会越界！
    {
        left = right;
        delete nums[right+1];  // ❌ 问题4：delete不能这样用！
    }
}
return nums.size();  // ❌ 问题5：返回值错了

初始：slow=0 (指向第一个不重复元素)

fast=1: nums[1]=0 == nums[0] → 重复，跳过
fast=2: nums[2]=1 != nums[0] → 不重复！
        → slow++，nums[slow]=nums[fast]
        → nums变成[0,1,1,1,1,2,2,3,3,4]，slow=1
        
fast=3: nums[3]=1 == nums[1] → 重复，跳过
fast=4: nums[4]=1 == nums[1] → 重复，跳过
fast=5: nums[5]=2 != nums[1] → 不重复！
        → slow++，nums[slow]=nums[fast]
        → nums变成[0,1,2,1,1,2,2,3,3,4]，slow=2

...以此类推

最终：nums变成[0,1,2,3,4,_,_,_,_,_]
      返回 slow+1 = 5 ✅

3. 删除重复项 ✅
LeetCode 26，简单
思路：快慢指针
- slow指向不重复元素的最后位置
- fast遍历数组
- 如果nums[fast] != nums[slow]，说明发现新元素
  → slow++，nums[slow] = nums[fast]

代码：
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.empty()) return 0;  // 边界情况
        
        int slow = 0;  // slow指向不重复元素的最后位置
        
        for(int fast = 1; fast < nums.size(); fast++)  // fast从1开始
        {
            if(nums[fast] != nums[slow])  // 发现不重复元素
            {
                slow++;                    // slow前进
                nums[slow] = nums[fast];   // 把不重复元素复制到slow位置
            }
        }
        
        return slow + 1;  // 返回不重复元素的个数（slow是索引，所以+1）
    }
};

⚠️ 我踩的坑：
1. int left, right = 0 → 只初始化了right，left是随机值！
   正确：int left = 0, right = 0;
2. 用delete删除数组元素 → delete不能这样用！
   这题不需要delete，用覆盖的方式
3. nums[right+1] 会越界
4. 逻辑理解错了：不是删除，是用不重复元素覆盖前面

正确理解：
- 有序数组，重复元素相邻
- 用slow维护不重复区域
- 用fast找新的不重复元素
- 发现新元素就复制到slow+1位置

时间复杂度：O(n)
空间复杂度：O(1)
用时：10分钟（第一次写错了，理解思路后重写）

---

## 今日总结

### 完成情况
- ✅ 完成3道题（移动零、两数之和、删除重复项）
- ⏰ 用时：2小时
- 📊 进度：3/8题

### 核心收获
1. **双指针技巧**
   - 快慢指针：移动零、删除重复项
   - 关键：slow维护结果区域，fast遍历查找

2. **哈希表应用**
   - 两数之和：O(n)时间复杂度
   - 关键：先查找后插入（避免找到自己）
   - hash.count(key) 是O(1)操作

3. **易错点**
   - 变量初始化：`int a, b = 0` 只初始化b！
   - 数组越界：访问前要检查边界
   - 时间复杂度：哈希查找O(1) vs 循环查找O(n)

### 踩的坑（重要！）
1. 移动零：if(right != 0) 应该是 if(nums[right] != 0)
2. 两数之和：内层循环重置变量导致无限循环
3. 删除重复项：delete不能用来删除vector元素

### 明天计划
- [ ] 继续Day01剩余5题
- [ ] 目标：完成8题，建立节奏
- [ ] 注意：单题不超过30分钟！

---

**写于：2025年10月2日 23:00**  
**Day 1/150 - 开始了！** 💪