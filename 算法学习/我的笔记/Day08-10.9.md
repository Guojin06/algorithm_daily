# Day08 - 10月9日学习笔记

**开始时间：** 2025年10月9日  
**今日专题：** 完成前缀和 + 开始新专题

## 📝 快速回顾 Day07 关键点（5分钟）

### 前缀和+哈希表核心套路：
1. **和为k的子数组** - `hash[sum-k]` 查找，记录次数
2. **整除k的子数组** - `hash[(sum%k+k)%k]` 查找余数，记录次数
3. **连续数组** - `hash[sum]` 查找，记录第一次出现的位置（今天要做）

**关键理解：**
- `hash[0] = 1` 或 `hash[0] = -1` 表示虚拟起点
- 查找的是**历史前缀和**，不会重复统计
- 负数取模：`(sum % k + k) % k`

---

## 🎯 今日题目

### 第5题：连续数组（LeetCode 525）⭐⭐⭐

**题目描述：**
给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例：**
```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。

输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量 0 和 1 的最长连续子数组。
```

**提示：**
- `1 <= nums.length <= 10^5`
- `nums[i]` 不是 `0` 就是 `1`

**题目链接：** https://leetcode.cn/problems/contiguous-array/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第31题

**思路提示：**
- **思维转换！** 把 `0` 看作 `-1`，问题变成：找和为 `0` 的最长子数组
- 如果 `sum[i] == sum[j]`，则 `[j+1, i]` 区间的和为 0
- 用哈希表记录每个前缀和 **第一次出现的位置**
- 遍历时，查找当前前缀和在哈希表中的位置，更新最大长度

---

**我的思路：**
此题和前面两题类似，都是用哈希表记录前缀和，只不过这次是记录前缀和第一次出现的位置，然后查找当前前缀和是否在哈希表中，如果在，则更新最大长度，不在时，则记录当前前缀和的位置。此题还有一个难点就是如何把 `0` 看作 `-1`，就是说，当遇到 `0` 时，就把前缀和减 `1`，遇到 `1` 时，就把前缀和加 `1`，这样就可以把 `0` 和 `1` 看作是相同的了，用三目运算符可以简化代码。



---

**我的代码：**
```cpp
// 在这里写你的代码
class Solution {
public:
    int findMaxLength(vector<int>& nums) {
        unordered_map<int ,int> hash;//与之前两题不同，此时存的不是前缀和与次数，而是前缀和与下标，因为要返回长度，所以得存下标
        hash[0] = -1;//默认有一个前缀和为0的情况，否则会遗漏
        int ret = 0 ;
        int sum = 0 ;
        for(int i = 0 ; i < nums.size() ; i++)
        {
            sum += nums[i] == 0 ? -1 : 1;//细节将0当做-1来看，这样就转换成了求最长前缀和为0的数组，关键点
            if(hash.count(sum)) ret = max(ret,i - hash[sum]);//如果存在，就用最大值
            else hash[sum] = i;//之前没存入时才记入哈希，记录下标


        }
        return ret;

    }
};
```

**提交结果：** ✅ AC

---

**我的错误（如果有）：**
无，一次AC！✨

---

**❓ 我的疑惑：能用前缀和数组代替哈希表吗？**

**教练解答：**

理论上可以，但**不推荐**！

**为什么哈希表更好：**
1. **处理负数方便：** 前缀和可能是[-n, n]范围，数组需要映射 `dp[sum+n]`
2. **只记录第一次：** 哈希表天然支持"key存在就不更新"
3. **空间高效：** 只存出现过的前缀和，数组需要开`2n+1`空间

**如果硬要用数组：**
```cpp
vector<int> dp(2*n+1, -2);  // -2表示未出现
dp[0+n] = -1;               // 前缀和0映射到dp[n]

for(int i = 0; i < n; i++) {
    sum += nums[i] == 0 ? -1 : 1;
    int idx = sum + n;  // 负数映射到正数下标
    
    if(dp[idx] != -2) ret = max(ret, i - dp[idx]);
    else dp[idx] = i;
}
```

**结论：** 能用，但代码复杂且空间浪费，哈希表是最优选择！✅

---

**复杂度分析：**
- **时间复杂度：** O(n)
- **空间复杂度：** O(n)

---

**我的收获：**
1. **思维转换：** 把`0`看作`-1`，问题变成"找和为0的最长子数组"
2. **哈希表存位置：** 和前两题不同，这里存的是**第一次出现的位置**，不是次数
3. **为什么存位置：** 因为要求**最长**，需要用`i - hash[sum]`计算长度
4. **和前面的区别：**
   - 第3题（和为k）：`hash[sum]` 存**次数**，求有多少个子数组
   - 第4题（整除k）：`hash[余数]` 存**次数**
   - 第5题（连续数组）：`hash[sum]` 存**位置**，求最长子数组
5. **前缀和数组 vs 哈希表：** 理论上都能用，但哈希表更简洁高效



---

## 📊 前缀和专题完成情况

| 题目 | 状态 | 用时 | 错误次数 | 关键收获 |
|------|------|------|----------|----------|
| 寻找数组的中心下标 | ✅ AC | 约15分钟 | 0 | 前缀和基础应用 |
| 除自身以外数组的乘积 | ✅ AC | 约20分钟 | 0 | 前后缀和分开处理 |
| 和为k的子数组 | ✅ AC | 约1小时 | 理解困难 | 前缀和+哈希表核心思想 |
| 和可被K整除的子数组 | ✅ AC | 约40分钟 | 1次WA | 余数思想，负数取模陷阱 |
| 连续数组 | ✅ AC | 约20分钟 | 0 | 思维转换，哈希表存位置 |

**前缀和专题（Day07-08）：5/5完成！** ✅  
**剩余2题（二维前缀和）明天完成！**

---

## 🎯 今日新专题：二分查找（算法精品课1 - 第17-24题）

**二分查找核心思想：**
- 在**有序**数组中查找目标值
- 每次排除一半的搜索范围
- 时间复杂度：O(log n)

**二分查找模板：**
```cpp
int left = 0, right = n - 1;
while(left <= right) {
    int mid = left + (right - left) / 2;
    if(nums[mid] == target) return mid;
    else if(nums[mid] < target) left = mid + 1;
    else right = mid - 1;
}
return -1;
```

---

### 第2题：二分查找（LeetCode 704）⭐ 模板题

**题目描述：**
给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

**示例：**
```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

**提示：**
- `1 <= nums.length <= 10^4`
- `-10^4 < nums[i], target < 10^4`
- `nums` 中的所有整数**互不相同**
- `nums` 按**升序**排列

**题目链接：** https://leetcode.cn/problems/binary-search/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第17题

---

**我的思路：**




---

**我的代码：**
```cpp

```

**提交结果：**



---

**我的错误（如果有）：**




---

**我的收获：**




---

### 第3题：在排序数组中查找元素的第一个和最后一个位置（LeetCode 34）⭐⭐

**题目描述：**
给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例：**
```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]

输入：nums = [], target = 0
输出：[-1,-1]
```

**提示：**
- `0 <= nums.length <= 10^5`
- `-10^9 <= nums[i] <= 10^9`
- `nums` 是一个非递减数组
- `-10^9 <= target <= 10^9`

**题目链接：** https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第18题

**思路提示：**
- 需要找**左边界**和**右边界**
- 左边界：第一个 `>= target` 的位置
- 右边界：第一个 `> target` 的位置 - 1

---

**我的思路：**




---

**我的代码：**
```cpp

```

**提交结果：**



---

**我的错误（如果有）：**




---

**我的收获：**




---

### 第4题：搜索插入位置（LeetCode 35）

**题目描述：**
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例：**
```
输入: nums = [1,3,5,6], target = 5
输出: 2

输入: nums = [1,3,5,6], target = 2
输出: 1

输入: nums = [1,3,5,6], target = 7
输出: 4
```

**提示：**
- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` 为**无重复元素**的**升序**排列数组
- `-10^4 <= target <= 10^4`

**题目链接：** https://leetcode.cn/problems/search-insert-position/

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第19题

**思路提示：**
- 找第一个 `>= target` 的位置
- 就是上一题的左边界模板！

---

**我的思路：**




---

**我的代码：**
```cpp

```

**提交结果：**



---

**我的错误（如果有）：**




---

**我的收获：**

---

## 💡 今日总结

**今天完成题数：** /4 (1题前缀和 + 3题二分查找)

**累计完成：** 24题 → 题

**用时：** 约 小时

**今天的关键收获：**
1. **前缀和专题完成！** 5/5题全部AC
2. **前缀和三种用法：**
   - 存次数（和为k、整除k）
   - 存位置（连续数组）
   - 前后缀分开处理（除自身乘积）
3. **二分查找入门：** 
   - 核心：有序数组 + 每次排除一半
   - 左边界：第一个 >= target
   - 右边界：第一个 > target - 1

**我遇到的问题：**
1. 疑惑能否用前缀和数组代替哈希表 → 理论可以但不推荐
2. 二分查找的边界条件（做题过程中记录）

**明天的目标：**
- 完成二维前缀和（2题）
- 继续二分查找专题（4-5题）

---

**学习进度：** Day08/150 ✅

