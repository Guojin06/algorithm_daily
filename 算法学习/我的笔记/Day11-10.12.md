# Day11 - 10月12日学习笔记

**开始时间：** 2025年10月12日  
**今日专题：** 二分查找进阶 + 新专题

## 📝 快速回顾 Day10 关键点（5分钟）

### 昨天的核心收获：
1. **二维前缀和的索引映射** - 哨兵位+1，预处理映射，查询转换
2. **二分查找找峰值** - 比较`mid`与相邻元素，判断单调性
3. **通用分析框架** - 遇到哨兵位问题可以自己推导映射关系

**关键理解：**
- 哨兵位的作用：防止越界，统一公式
- 映射规律：`mat[i][j]` ↔ `dp[i+1][j+1]`
- 查询公式：包含的边界+1，排除的边界-1再+1抵消

---

## 🎯 今日学习计划

**你现在的进度：**
- ✅ Day07: 前缀和+哈希（4题）
- ✅ Day08: 连续数组 + 二分查找开始（2题）
- ✅ Day09: 二分查找进阶（3题）
- ✅ Day10: 二维前缀和 + 二分找峰值（5题）
- 📊 **累计完成：33题**

---

### 今日安排：二分查找收尾 + 位运算专题开启

根据比特课程进度，今天的计划是：

#### 上午：二分查找收尾（2-3题）

**推荐题目（旋转数组系列）：**
1. **搜索旋转排序数组**（LeetCode 33）⭐⭐⭐⭐⭐ - 超高频面试题
2. **寻找旋转排序数组中的最小值**（LeetCode 153）⭐⭐⭐
3. **搜索旋转排序数组 II**（LeetCode 81）⭐⭐⭐ - 有重复元素（可选）

#### 下午/晚上：位运算专题开启（5题）

**比特课程 - 算法精品课2（位运算章节）：**

1. **判断字符是否唯一**（面试题 01.01）⭐⭐ - easy
   - 知识点：位图思想
   - 用一个int的32位表示26个字母
   
2. **丢失的数字**（LeetCode 268）⭐⭐ - easy
   - 知识点：异或运算的"消消乐"规律
   - `x ^ x = 0, x ^ 0 = x`
   
3. **两整数之和**（LeetCode 371）⭐⭐⭐ - medium
   - 知识点：异或是无进位加法，按位与得到进位
   
4. **只出现一次的数字 II**（LeetCode 137）⭐⭐⭐⭐ - medium
   - 知识点：比特位计数
   - 统计每个比特位的和 % 3
   
5. **消失的两个数字**（面试题 17.19）⭐⭐⭐⭐ - hard
   - 知识点：异或 + 分组
   - 268题 + 260题的组合

---

## 💬 教练建议

今天的安排很合理！

**上午2小时：** 把二分查找彻底收尾，旋转数组是高频面试题，必须掌握！

**下午/晚上2-3小时：** 开始位运算专题，这是比特课程精品课2的内容，5道题难度递增，正好系统学习位运算技巧。

**预计总用时：** 4-5小时

**学习重点：**
- 二分查找：理解旋转数组如何二分，找到单调性
- 位运算：掌握位图、异或、位操作的基本技巧

---

## 📝 今日任务

### 上午任务：二分查找收尾

#### 第1题：搜索旋转排序数组（LeetCode 33）⭐⭐⭐⭐⭐

**题目链接：** https://leetcode.cn/problems/search-in-rotated-sorted-array/

**题目描述：**
整数数组 `nums` 按升序排列，数组中的值 **互不相同**。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了**旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标从 0 开始）。例如， `[0,1,2,4,5,6,7]` 在下标 3 处经旋转后可能变为 `[4,5,6,7,0,1,2]`。

给你**旋转后**的数组 `nums` 和一个整数 `target`，如果 `nums` 中存在这个目标值 `target`，则返回它的下标，否则返回 `-1`。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**
```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**
```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**
```
输入：nums = [1], target = 0
输出：-1
```

**提示：**
- `1 <= nums.length <= 5000`
- `-10^4 <= nums[nums.length - 1] < nums[0] <= 10^4`
- `nums` 中的每个值都**独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-10^4 <= target <= 10^4`

---

**思路提示：**

旋转数组的特点：数组被分成两段，每段都是有序的。

关键思路：
1. 用二分查找，但要判断 `mid` 在哪一段
2. 如果 `nums[left] <= nums[mid]`，说明左半边是有序的
3. 如果 `nums[mid] <= nums[right]`，说明右半边是有序的
4. 判断 `target` 是否在有序的那一段，决定移动哪个指针

**核心技巧：** 
- 旋转数组虽然整体不单调，但局部单调
- 通过 `nums[left]` 和 `nums[mid]` 的大小关系，判断哪一段是有序的
- 在有序的一段中，可以直接判断 `target` 是否在其中

**比特课程讲解：** 虽然这题不在比特课程里，但是属于二分查找的经典变体，面试高频！

---

---

**我的代码（两次二分思路）：**
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size() - 1;
        
        // 第一次二分：找峰顶（最大值位置）
        int left = 0, right = n;
        while(left < right) {
            int mid = left + (right - left + 1) / 2;
            if(nums[mid] > nums[n]) left = mid;  // 和最后一个比
            else right = mid - 1;
        }
        int pick = left;
        
        // 检查峰顶本身
        if(nums[pick] == target) return pick;
        
        // 判断target是否可能存在
        if(nums[pick] < target && nums[n] < target) return -1;
        
        // 第二次二分：在对应区间查找
        if(nums[n] < target) {  // 在左区间
            left = 0;
            right = pick;
            if(left > right) return -1;  // 区间为空
            while(left < right) {
                int mid = left + (right - left + 1) / 2;
                if(nums[mid] <= target) left = mid;
                else right = mid - 1;
            }
            if(nums[left] == target) return left;
            else return -1;
        }
        else {  // 在右区间
            left = pick + 1;
            right = n;
            if(left > right) return -1;  // 区间为空
            while(left < right) {
                int mid = left + (right - left + 1) / 2;
                if(nums[mid] <= target) left = mid;
                else right = mid - 1;
            }
            if(nums[left] == target) return left;
            else return -1;
        }
    }
};
```

**提交结果：** ✅ AC！

---

**我踩的5个坑（血泪教训）：**

### 坑1：数组越界
❌ `if(nums[mid] <= nums[mid + 1])` → 当 `mid = n` 时，`mid+1` 越界
✅ 改成 `if(nums[mid] > nums[n])` → 和固定位置比较

### 坑2：区间为空仍访问
❌ `left = pick + 1, right = n` 可能导致空区间，但还访问 `nums[left]`
✅ 加判断：`if(left > right) return -1;`

### 坑3：峰顶本身没检查
❌ 区间 `[0, pick]` 和 `[pick+1, n]`，峰顶不在任何区间
✅ 加判断：`if(nums[pick] == target) return pick;`

### 坑4：边界判断不完整
❌ `if(nums[pick] < target)` → 没考虑最大值可能在 `nums[n]`
✅ 改成：`if(nums[pick] < target && nums[n] < target)`

### 坑5：二段性断裂（核心问题）
❌ `nums[mid] > nums[mid-1]` → 二段性：`[✅✅✅|❌|✅✅]` 断裂
✅ `nums[mid] > nums[n]` → 二段性：`[✅✅✅✅|❌❌❌]` 连续

---

**关键理解：**

### 为什么和 `nums[n]` 比而不是和前一个比？

**旋转数组的特征：**
```
[4, 5, 6, 7, 0, 1, 2]
         ↑峰顶

和nums[n]=2比：
4>2? ✅  5>2? ✅  6>2? ✅  7>2? ✅ | 0>2? ❌  1>2? ❌  2>2? ❌
[✅ ✅ ✅ ✅ | ❌ ❌ ❌]  ← 二段性连续！

和前一个比：
5>4? ✅  6>5? ✅  7>6? ✅ | 0>7? ❌ | 1>0? ✅  2>1? ✅
[✅ ✅ ✅ | ❌ | ✅ ✅]  ← 二段性断裂！
```

**二分查找的前提：** 必须是连续的两段 `[✅✅✅|❌❌❌]`

---

**和昨天山峰题的区别：**

| 题目 | 要求 | 二段性 | 能用 `>前一个` 吗？ |
|------|------|--------|---------------------|
| 昨天峰值(162) | **任意峰** | 不连续也行 | ✅ 可以 |
| 今天旋转(33) | **唯一最大值峰** | 必须连续 | ❌ 不行 |

**原因：** 昨天找到任何峰都对，今天必须找到最大值峰！

---

---

#### 第2题：寻找旋转排序数组中的最小值（LeetCode 153）⭐⭐⭐

**题目链接：** https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/

**问题描述：**
已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次旋转后，得到输入数组。找出并返回数组中的最小元素。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**我的代码（10分53秒，一次AC！）：**
```cpp
class Solution {
public:
    int findMin(vector<int>& nums) {
        //一次二分就够
        int left = 0; 
        int right = nums.size() - 1;
        int n = nums.size();
        while(left < right)
        {
            int mid = left + (right - left + 1)/2;
            if(nums[mid] > nums[n - 1]) left = mid;
            else right = mid - 1;
        }
        if(nums.size() == 0 || nums.size() == 1) return nums[left];//边界情况，空数组或1个元素情况
        if(nums[left] < nums[n - 1]) return nums[left];//旋转0次的情况讨论
        return nums[left + 1];
    }
};
```

**提交结果：** ✅ AC！（10分53秒）

**我的思路：**
1. 找最大值位置（峰顶）
2. 最小值 = 峰顶的下一个位置
3. 处理边界：空数组、单元素、无旋转

**核心理解：**
- 用第1题学到的框架，直接套用！
- `nums[mid] > nums[n-1]` 找最后一个大于末尾的
- 最小值就是 `nums[left + 1]`

**耗时对比：**
- 第1题：2小时（深度学习）
- 第2题：10分53秒（秒杀！）
- **提速10倍！证明深度学习有效！** 🚀

---

#### 第3题：搜索旋转排序数组 II（LeetCode 81）⭐⭐⭐

**题目链接：** https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/

**问题描述：**
已知存在一个按非降序排列的整数数组 `nums`，数组中的值**不必互不相同**。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了旋转。

请你判断给定的目标值 `target` 是否存在于数组中。如果 `nums` 中存在这个目标值 `target` ，则返回 `true` ，否则返回 `false` 。

**我的代码（错误版本）：**
```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        //存在与否target，那和之前题目类似，需要两次二分
        int left = 0 , right = nums.size() - 1;
        int n = nums.size();
        while(left < right)
        {
            int mid = left + (right -left +1)/2;
            if(nums[mid] > nums[n - 1]) left = mid;
            else right = mid - 1;
        }
        //接下来进行边界情况以及特殊情况讨论
        //先记录一下left或者right此时的值（它们是同一数值，以防未旋转数组改变）
        int memory = left;
        if(nums.size() == 0) return false;//空数据返回false
        if(nums.size() == 1 && nums[left] != target) return false;//单元素数组判断
        if(nums[left] < nums[n - 1]) //未旋转数组,进行二分判断
        {
            left = 0,right = nums.size() - 1;
            while(left < right)
            {
                int mid1 = left + (right -left +1)/2;  // ❌ 错误1：变量作用域
                if(nums[mid1] > target) left = mid1;   // ❌ 错误3：条件反了
                else right = mid1 - 1;
            }
            if(nums[mid1] != target) return false;  // ❌ mid1已销毁，编译错误！
            else return true;
        }
        //接下来就是一般情况，进行了旋转，在左右区间查找判断然后进行二分
        if(nums[left] == target) return true;//如果峰顶本身就是那么直接返回true
        if(nums[left] < target) return false;//如果小于target，那么肯定数组中找不到了，直接返回false
        if( nums[n - 1] >= target)//右区间
        {
            left = memory;//重新赋值一下以防改变
            right = nums[n - 1];  // ❌ 错误2：right应该是下标，不是值！
            while(left < right)
            {
                int mid2 = left + (right -left +1)/2;  // ❌ 错误1
                if(nums[mid2] > target) left = mid2;   // ❌ 错误3
                else right = mid2 - 1;
            }
            if(nums[mid2] != target) return false;  // ❌ mid2已销毁
            else return true;
        }
        if(nums[n - 1] < target)//左区间
        {
            left = memory;
            right = nums[n - 1];  // ❌ 错误2
            while(left < right)
            {
                int mid3 = left + (right -left +1)/2;  // ❌ 错误1
                if(nums[mid3] > target) left = mid3;   // ❌ 错误3
                else right = mid3 - 1;
            }
            if(nums[mid3] != target) return false;  // ❌ mid3已销毁
            else return true;
        }
    }
};
```

**编译错误：** `use of undeclared identifier 'mid1'`

---

**我的4个错误分析：**

### ❌ 错误1：变量作用域问题（致命错误）
```cpp
while(left < right) {
    int mid1 = ...;  // mid1只在循环内有效
}
if(nums[mid1] != target)  // ❌ 循环外mid1已经销毁了！
```

**正确做法：** 变量定义在循环外，或者用 `left` 来判断：
```cpp
while(left < right) {
    int mid = ...;
}
if(nums[left] != target) return false;  // ✅ 用left，因为最后left==right
```

---

### ❌ 错误2：区间赋值错误
```cpp
right = nums[n - 1];  // ❌ right是下标，不应该赋值为数组的值！
```

**正确做法：**
```cpp
right = n - 1;  // ✅ right是下标
```

---

### ❌ 错误3：二分判断条件错误
```cpp
if(nums[mid1] > target) left = mid1;  // ❌ 这是找最大值的条件
else right = mid1 - 1;
```

**问题：** 这里要查找 `target`，不是找最大值！应该用标准二分：
```cpp
if(nums[mid] == target) return true;
else if(nums[mid] < target) left = mid + 1;  // ✅ 标准二分
else right = mid - 1;
```

---

### ❌ 错误4：没处理重复元素（这题的陷阱！）

**LeetCode 81 和 33 的关键区别：** 有**重复元素**！

```
[2, 5, 6, 0, 0, 1, 2]  ← 有重复的2

和nums[n-1]=2比：
2>2? ❌  5>2? ✅  6>2? ✅ | 0>2? ❌  ...  2>2? ❌
      ↑ 无法判断在哪一段！
```

**解决方法：** 遇到 `nums[mid] == nums[n-1]` 时，`right--`（去掉重复）

---

**反思：**
1. ✅ 思路是对的（两次二分）
2. ❌ C++语法细节（变量作用域）
3. ❌ 混淆了"找最大值"和"查找target"的条件
4. ❌ 没注意到"有重复元素"这个关键变化

**学到的：**
- 变量定义位置很重要
- 二分查找和二分搜索条件不同
- 审题要注意数据特征（重复元素）

---

**AC代码（一次二分+特殊处理）：**
```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        
        while(left <= right) {
            int mid = left + (right - left) / 2;
            
            if(nums[mid] == target) return true;
            
            // 关键：无法判断时缩小范围
            if(nums[left] == nums[mid] && nums[mid] == nums[right]) {
                left++;
                right--;
            }
            // 左半边有序
            else if(nums[left] <= nums[mid]) {
                if(nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            // 右半边有序
            else {
                if(nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        
        return false;
    }
};
```

**提交结果：** ✅ AC！

**核心理解：**
- LeetCode 33（无重复） → 两次二分可行
- LeetCode 81（有重复） → 一次二分+特殊处理
- 有重复元素时，二段性会被破坏，需要特殊处理

**详细理解：** 明天早上用苏格拉底式教学深入理解！

---

### 下午任务：位运算专题（明天做，今天好好消化二分！）

（位运算5题留到明天，今天已经收获满满！）

---

## 💡 今日总结

**今天完成题数：** 3/3（1题深度学习AC + 1题秒杀AC + 1题攻坚AC）

**累计完成：** 33题 → 36题

**用时：** 约2.5小时（深度学习+快速应用）

**今天的关键收获：**
1. **攻克面试超高频题** - 搜索旋转排序数组（LeetCode 33）⭐⭐⭐⭐⭐
2. **掌握二分查找底层逻辑** - 二段性必须连续才能二分
3. **建立二分通用框架** - 5步思维法+5大检查清单
4. **踩坑5次，经验拉满** - 越界、空区间、峰顶遗漏、边界判断、二段性断裂
5. **理解旋转数组本质** - 为什么和 `nums[n]` 比而不是和前一个比
6. **验证学习成果** - 第2题10分钟秒杀，提速10倍！🚀
7. **C++语法陷阱** - 变量作用域、下标vs值、查找vs搜索条件

**我遇到的问题：**
1. **第1题（5次WA）：** 数组越界、区间为空、分界点遗漏、边界不完整、二段性断裂
2. **第2题（1次AC）：** 完美应用框架，10分钟秒杀！
3. **第3题（编译错误）：** 变量作用域、下标vs值混淆、查找条件错误、没处理重复元素

**解决方案：**
- 越界 → 用固定位置比较（`nums[0]`, `nums[n-1]`）
- 空区间 → 先判断 `left > right`
- 分界点 → 单独检查
- 边界 → 考虑所有极值位置
- 二段性 → 选对比较对象
- **变量作用域 → 定义在循环外或用left/right**
- **下标vs值 → right是下标，不能赋值为nums[i]**
- **查找条件 → 标准二分：`==`, `<`, `>`三分支**

**核心理解：**
- 昨天山峰题：找"任意峰" → 二段性不连续也行
- 今天旋转题：找"唯一峰" → 二段性必须连续
- **二分的前提：** `[满足条件 | 不满足条件]` 连续两段

**明天的目标：**
- 早上默写二分框架（5分钟）
- 开始位运算专题（5题）
- 时间充裕的话，修正并AC第3题

---

**学习进度：** Day11/150 ✅

**教练评价：** 🌟🌟🌟🌟🌟
今天是完美的学习示范！
- 第1题：2小时深度学习，踩坑5次，建立底层框架
- 第2题：10分钟秒杀验证，提速10倍！
- 第3题：暴露新问题（变量作用域、条件混淆），继续成长

**这就是真正的学习：**
- 不是刷题数量，而是思维深度
- 不是一次AC，而是理解本质
- 不怕犯错，每个错都是经验

**你已经建立了二分查找的核心思维！** 💪

继续保持这种节奏，150天后你将脱胎换骨！🚀

