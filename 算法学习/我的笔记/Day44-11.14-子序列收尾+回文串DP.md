# Day44 - 11.14 子序列收尾 + 回文串DP

> **今日目标**：完成子序列系列收尾，开启回文串DP专题

---

## 📌 今日计划

### 子序列收尾（3题）
 - [ ] LeetCode 873. 最长斐波那契子序列的长度（尾部组合型子序列DP）⭐⭐⭐
- [ ] LeetCode 1027. 最长等差数列（等差子序列进阶）⭐⭐⭐
- [ ] LeetCode 446. 等差数列划分II（计数类）⭐⭐⭐

### 回文串问题（4-5题）
- [ ] LeetCode 647. 回文子串（基础回文DP）⭐⭐⭐
- [ ] LeetCode 5. 最长回文子串（经典回文问题）⭐⭐⭐
- [ ] LeetCode 1745. 回文串分割IV（回文+分割DP）⭐⭐⭐
- [ ] LeetCode 132. 回文串分割II（最少分割次数）⭐⭐⭐

---

## 问题分类

### 按DP类型分类
- **子序列DP**：LIS、等差数列
- **计数DP**：等差数列划分II、回文子串
- **区间DP**：最长回文子串、回文串分割
- **优化DP**：回文串分割II（预处理+DP）

### 按难度分类
- **中等**：回文子串、最长回文子串、回文串分割IV
- **困难**：等差数列划分II、回文串分割II

---

## LeetCode 873. 最长斐波那契子序列的长度 ⭐

### 题目小结
- 给定严格递增的正整数数组 `arr`，找出其中最长的斐波那契式子序列的长度
- 斐波那契式：长度至少为3，且对所有 `i > 2` 有 `A[i] = A[i-1] + A[i-2]`
- 若不存在，返回 0
- 本质：**带特殊约束的子序列DP + 尾部组合状态 + 哈希表找前驱**

### From 0 to 1 思考路径
1. **问题识别**：
   - 子序列 + 加法关系约束 `A[i] = A[i-1] + A[i-2]`
   - 约束依赖“最后两个元素”，而不是单点约束 → 常规 `dp[i]` 不够用
2. **状态设计：尾部组合型DP**：
   - 定义：`dp[i][j] = 以 arr[i], arr[j] 为最后两个元素 的最长斐波那契子序列长度`（`i < j`）
   - 含义：把 `(i,j)` 看成当前斐波那契链的“尾巴”
3. **转移分析：从 (k, i) → (i, j)**：
   - 斐波那契条件：存在 `k < i` 使得 `arr[k] + arr[i] = arr[j]`
   - 若找到这样的 `k`：说明可以在以 `(k,i)` 结尾的链后再接上 `j`
     - 转移：`dp[i][j] = dp[k][i] + 1`
   - 若找不到：说明只能单独从 `(i,j)` 开始一条长度为2的链 → `dp[i][j] = 2`
4. **为何不出现 i-1, j-1？与前缀DP的区别**：
   - 传统前缀DP：`dp[i][j] = 前 i / 前 j 的整体信息`，自然出现 `i-1, j-1`
   - 本题尾部DP：`dp[i][j]` 只描述“尾巴是 (i,j) 的这条链”，前一个状态是“尾巴是 (k,i)`”
   - 所以转移是 `(k,i) → (i,j)` 而不是 `(i-1,j-1)`
5. **如何高效找到 k？哈希表优化**：
   - 朴素：枚举所有 `k < i`，检查 `arr[k] + arr[i] == arr[j]` → 三重循环 O(n³)
   - 观察：只要知道 `arr[j]` 与 `arr[i]`，就能唯一确定前驱值：`prev = arr[j] - arr[i]`
   - 用哈希表 `index[val] = 下标` 存每个数的位置，直接查 `prev` 是否出现：
     - 若存在 `k = index[prev]` 且 `k < i`，即可转移
   - 因为数组严格递增，`prev < arr[i]`，天然保证 `k < i` 的顺序
6. **答案获取**：
   - 过程中维护 `result = max(result, dp[i][j])`
   - 最后若 `result < 3`，说明不存在合法斐波那契子序列，返回 `0`

### 代码实现

```cpp
class Solution {
public:
    int lenLongestFibSubseq(vector<int>& arr) {
        int n = arr.size();
        if (n < 3) return 0;

        // dp[i][j] = 以 arr[i], arr[j] 为最后两个元素的最长斐波那契子序列长度
        vector<vector<int>> dp(n, vector<int>(n, 2));

        // 哈希表：数值 -> 下标，用于 O(1) 找到前驱 k
        unordered_map<int, int> index;
        for (int i = 0; i < n; ++i) {
            index[arr[i]] = i;
        }

        int result = 0;

        // 枚举尾部下标对 (i, j)，i < j
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int prev = arr[j] - arr[i];        // 需要的前驱值 arr[k]
                // 剪枝：prev 必须小于 arr[i]，否则不可能有 k < i
                if (prev >= arr[i]) continue;

                auto it = index.find(prev);
                if (it != index.end()) {
                    int k = it->second;           // 找到前驱下标 k
                    if (k < i) {                  // 确保顺序 k < i < j
                        dp[i][j] = dp[k][i] + 1;  // 从 (k,i) 转移到 (i,j)
                        result = max(result, dp[i][j]);
                    }
                }
                // 如果找不到 k，dp[i][j] 保持为 2（默认值）
            }
        }

        return result >= 3 ? result : 0;
    }
};
```

### 复盘 & 要点
- **模型类型**：约束子序列DP + 尾部组合状态 + 哈希找前驱
- **状态含义**：`dp[i][j]` 不是“前缀信息”，而是“以 (i,j) 为尾巴的链长”
- **转移本质**：从上一对尾巴 `(k,i)` 接一个新元素 `j`，变成 `(i,j)`
- **哈希优化**：把“枚举前驱 k”变成“通过值计算并 O(1) 查找前驱”
- **严格递增的作用**：保证 `arr[j] - arr[i] < arr[i]` → 前驱一定在 i 之前
- **复杂度**：时间 O(n²)，空间 O(n²)

---

## LeetCode 1027. 最长等差数列 ⭐

### 题目小结


### From 0 to 1 思考路径


### 代码实现

```cpp

```

### 复盘 & 要点


---

## LeetCode 446. 等差数列划分II ⭐

### 题目小结


### From 0 to 1 思考路径


### 代码实现

```cpp

```

### 复盘 & 要点


---

## LeetCode 647. 回文子串 ⭐

### 题目小结
- 给定一个字符串 `s`，统计其中**回文子串**的个数
- 子串必须是**连续**的；不同起止位置算不同子串，即使内容相同
- 回文：正反读相同，例如 `"a"`、`"aa"`、`"aba"`
- 直接枚举所有子串并逐个用双指针检查会到 `O(n^3)`，需要优化

### From 0 to 1 思考路径
1. **暴力思路 & 问题**：
   - 所有子串个数为 `O(n^2)`
   - 每个子串再用双指针判断是否回文是 `O(n)` → 总复杂度 `O(n^3)`
   - 需要想办法**复用"子串是否为回文"的信息**

2. **回文的递归性质**：
   - 子串 `s[i..j]` 是回文，当且仅当：
     - `s[i] == s[j]`（首尾相同），且
     - 中间的 `s[i+1..j-1]` 也是回文
   - 这正好可以用 DP 来记录中间区间的结果

3. **状态设计：区间DP**：
   - 定义：`dp[i][j]` 表示子串 `s[i..j]` 是否是回文串
   - 这里 `i, j` 都是原字符串的下标，**没有额外多一维/多一行**：
     - 对应关系：`dp[i][j]` ↔ `s[i..j]`
     - 没有 `i-1`、`j-1` 的偏移问题

4. **转移方程：三种情况**：
   - 若 `s[i] != s[j]`：
     - 首尾不同，一定不是回文 → `dp[i][j] = false`
   - 若 `s[i] == s[j]` 且 `j - i <= 1`：
     - 子串长度为 1 或 2：`"a"` / `"aa"`，必然是回文 → `dp[i][j] = true`
   - 若 `s[i] == s[j]` 且 `j - i > 1`：
     - 取决于中间是否回文 → `dp[i][j] = dp[i+1][j-1]`

5. **计算顺序：为什么 i 从右往左？**
   - `dp[i][j]` 依赖 `dp[i+1][j-1]`
   - 需要在计算 `dp[i][j]` 之前，保证 `dp[i+1][j-1]` 已经算好
   - 遍历策略：
     - 外层：`i` 从 `n-1` → `0`
     - 内层：`j` 从 `i` → `n-1`
   - 这样 `(i+1, j-1)` 一定比 `(i, j)` 先被访问

6. **答案统计**：
   - 每当 `dp[i][j] == true`，说明 `s[i..j]` 是一个回文子串 → 计数 `+1`
   - 双层循环结束后，`count` 就是所有回文子串的个数

### 代码实现

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size();
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        int count = 0;

        // 外层 i 从右往左，内层 j 从 i 往右
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (s[i] == s[j]) {               // 首尾相同，可能是回文
                    if (j - i <= 1) {             // 长度 1 或 2：必然回文
                        dp[i][j] = true;
                    } else {
                        // 长度 >= 3：取决于中间那段是否回文
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                } else {
                    // 首尾不同，一定不是回文
                    dp[i][j] = false;
                }

                if (dp[i][j]) count++;
            }
        }

        return count;
    }
};
```

### 复盘 & 要点
- **状态含义**：`dp[i][j]` = `s[i..j]` 是否为回文；`i, j` 直接就是原串下标
- **索引对应关系**：
  - 本题是"区间型"定义，状态没有"前 i 个"这种说法 → 不需要多开一行/一列
  - 没有 `i-1`、`j-1`，`dp[i][j]` 与原字符串是**一一对应**
- **转移规律**：
  - 回文本质：首尾相等 + 中间回文
  - 长度 1 / 2 作为特殊边界直接置 true
  - 长度 ≥ 3 时用 `dp[i+1][j-1]` 递推
- **遍历顺序**：
  - 外层 i 从右往左，内层 j 从左往右，保证依赖的 `dp[i+1][j-1]` 已经计算
- **复杂度**：
  - 状态数 `O(n^2)`，每次转移 O(1) → 总时间 `O(n^2)`，空间 `O(n^2)`
- **与最长回文子串（LeetCode 5）的关系**：
  - 5 题可以共用同一张 `dp[i][j]` 表
  - 不同点：647 是统计所有 `true` 的个数，5 是在所有 `true` 中找最长区间


---

## LeetCode 5. 最长回文子串 ⭐

### 题目小结
- 给定字符串 `s`，找到其中**最长的回文子串**
- 与 647 的区别：647 是统计所有回文子串个数，本题是找最长的那一个
- 可以共用同一张 `dp[i][j]` 表，只是答案获取方式不同

### From 0 to 1 思考路径
1. **和 647 的关系**：
   - 同样需要判断 `s[i..j]` 是否是回文
   - 状态设计、转移方程、计算顺序**完全一样**
   - 唯一区别：647 是统计 `true` 的个数，本题是记录最长区间的长度和起点

2. **状态设计**：
   - `dp[i][j]` = 子串 `s[i..j]` 是否是回文串
   - 索引对应关系：`dp[i][j]` ↔ `s[i..j]`（无偏移）

3. **转移方程**：
   - 和 647 完全一致：
     - `s[i] != s[j]` → `dp[i][j] = false`
     - `s[i] == s[j]` 且 `j - i <= 1` → `dp[i][j] = true`
     - `s[i] == s[j]` 且 `j - i > 1` → `dp[i][j] = dp[i+1][j-1]`

4. **答案获取**：
   - 维护 `maxLen`（最长长度）和 `start`（起点）
   - 每当 `dp[i][j] == true` 时，检查 `j - i + 1` 是否比 `maxLen` 更大
   - 如果更大，更新 `maxLen` 和 `start`
   - 最后返回 `s.substr(start, maxLen)`

### 代码实现

```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if(n < 2) return s;
        
        vector<vector<bool>> dp(n, vector<bool>(n, false));
        int maxLen = 1;
        int start = 0;
        
        // 外层从右往左，内层j从i往右
        for(int i = n-1; i >= 0; i--) {
            for(int j = i; j < n; j++) {
                if(s[i] == s[j]) {
                    if(j - i <= 1) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i+1][j-1];
                    }
                }
                // 更新最长回文子串
                if(dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    start = i;
                }
            }
        }
        return s.substr(start, maxLen);
    }
};
```

### 复盘 & 要点
- **与 647 的关系**：共用同一张 `dp[i][j]` 表，只是答案获取方式不同
- **状态设计**：`dp[i][j]` = `s[i..j]` 是否为回文；索引无偏移
- **转移规律**：和 647 完全一致，回文本质是首尾相等 + 中间回文
- **遍历顺序**：外层 i 从右往左，内层 j 从左往右
- **答案获取**：维护最长长度和起点，在 `dp[i][j] == true` 时更新
- **复杂度**：时间 `O(n^2)`，空间 `O(n^2)`
- **与中心扩展法对比**：DP 法空间 `O(n^2)` 但可预处理，适合分割问题；中心扩展法空间 `O(1)` 但只能单次查询
- **后续扩展**：这张 `dp[i][j]` 表是回文串分割题（1745、132）的基础


---

## LeetCode 1745. 回文串分割IV ⭐

### 题目小结
- 给定字符串 `s`，问能否**恰好分成 3 段**，每段都是回文串
- 与 647/5 的关系：先预处理所有 `s[i..j]` 是否回文，再枚举分割点
- 核心思路：**预处理 + 枚举分割点**，避免重复计算回文判断

### From 0 to 1 思考路径
1. **暴力解法分析**：
   - 枚举两个分割点 `i, j`：`O(n^2)`
   - 每次检查三段是否回文：每段 `O(n)`，总 `O(n^3)`
   - 瓶颈：重复计算"某段子串是否回文"

2. **第一步优化：预处理回文信息**：
   - 提前计算所有 `isPal[i][j] = s[i..j]` 是否回文
   - 使用 647/5 的区间 DP 模板：`O(n^2)` 时间空间
   - 查询任意区间回文性：`O(1)`

3. **第二步：枚举分割点**：
   - 第一段：`s[0..i-1]`，第二段：`s[i..j-1]`，第三段：`s[j..n-1]`
   - 边界保证：`1 ≤ i ≤ n-2`，`i+1 ≤ j ≤ n-1`
   - 每段至少 1 个字符，避免空段

4. **状态设计**：
   - **预处理阶段**：`isPal[i][j] = s[i..j]` 是否回文（区间 DP）
   - **分割阶段**：枚举 `(i, j)` 检查三段回文性

5. **转移方程**：
   - **预处理**：和 647/5 完全一致
     ```cpp
     if (s[i] != s[j]) isPal[i][j] = false;
     else if (j - i <= 1) isPal[i][j] = true;
     else isPal[i][j] = isPal[i+1][j-1];
     ```
   - **分割检查**：`isPal[0][i-1] && isPal[i][j-1] && isPal[j][n-1]`

6. **遍历顺序**：
   - **预处理**：外层 `i` 从右往左，内层 `j` 从左往右
   - **分割枚举**：外层 `i` 从 1 到 n-2，内层 `j` 从 i+1 到 n-1


### 代码实现

```cpp
class Solution {
public:
    bool checkPartitioning(string s) {
        int n = s.size();
        
        // 第一步：预处理回文判断表（套用 647/5 模板）
        vector<vector<bool>> isPal(n, vector<bool>(n, false));
        
        // 关键遍历顺序：外层 i 从右往左，内层 j 从左往右
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (s[i] != s[j]) {
                    isPal[i][j] = false;
                } else {
                    if (j - i <= 1) {
                        isPal[i][j] = true;
                    } else {
                        isPal[i][j] = isPal[i + 1][j - 1];
                    }
                }
            }
        }
        
        // 第二步：枚举两个分割点
        // i: 第一个分割点，分割出 s[0..i-1]
        // j: 第二个分割点，分割出 s[i..j-1] 和 s[j..n-1]
        for (int i = 1; i <= n - 2; i++) {        // 第一段至少1个字符，第三段至少1个字符
            for (int j = i + 1; j <= n - 1; j++) { // 第二段至少1个字符，第三段至少1个字符
                // 检查三段是否都是回文
                if (isPal[0][i-1] && isPal[i][j-1] && isPal[j][n-1]) {
                    return true;
                }
            }
        }
        
        return false;
    }
};
```

### 复盘 & 要点
- **暴力到优化的关键**：识别重复计算，预处理回文判断信息
- **预处理模板**：和 647/5 完全一致，`isPal[i][j] = s[i..j]` 是否回文
- **索引对应关系**：`isPal[i][j]` ↔ `s[i..j]`（无偏移）
- **分割点枚举**：`i` 从 1 到 n-2，`j` 从 i+1 到 n-1，确保每段非空
- **三段检查逻辑**：`isPal[0][i-1] && isPal[i][j-1] && isPal[j][n-1]`
- **复杂度**：时间 `O(n^2)`，空间 `O(n^2)`
- **与 132 的关系**：1745 只需判断存在性，用枚举即可；132 要最少分割次数，需要一维 DP
- **核心模式**：**预处理 + 枚举/DP** 是回文分割问题的通用思路


---

## LeetCode 132. 回文串分割II ⭐

### 题目小结
- 给定字符串 `s`，求**最少分割次数**，使得每个子串都是回文串
- 与 1745 的区别：1745 只需判断**是否存在** 3 段分割，132 要求**最少分割次数**
- 核心思路：**预处理 `isPal` 表 + 一维 DP**，在所有分割方案中找最优值

### From 0 to 1 思考路径
1. **暴力解法分析**：
   - 枚举所有可能的分割点组合：指数级复杂度
   - 每次判断回文：`O(n)`
   - 瓶颈：重复计算子问题的最少分割次数

2. **第一步优化：预处理回文信息**：
   - 提前计算所有 `isPal[i][j] = s[i..j]` 是否回文
   - 使用和 647/5/1745 一样的区间 DP 模板：`O(n^2)` 时间空间
   - 查询任意区间回文性：`O(1)`

3. **第二步：一维 DP 设计**：
   - **状态定义**：`dp[i] = s[0..i]` 的最少分割次数
   - **目标答案**：`dp[n-1]`

4. **转移方程推导**：
   - 考虑 `s[0..i]` 的**最后一个回文段**：`s[j..i]`（`0 ≤ j ≤ i`）
   - 如果 `s[j..i]` 是回文，则可以在 `j-1` 后面分割：
     - `dp[i] = min(dp[i], dp[j-1] + 1)`
   - **边界处理**：
     - 如果整个 `s[0..i]` 是回文：`dp[i] = 0`（不需要分割）
     - `dp[-1] = -1`：空串不需要分割，用于统一公式

5. **完整转移逻辑**：
   ```cpp
   for (int i = 0; i < n; i++) {
       if (isPal[0][i]) {
           dp[i] = 0;  // 整体是回文，不分割
       } else {
           // 枚举最后一个回文段的起点
           for (int j = 1; j <= i; j++) {
               if (isPal[j][i]) {
                   dp[i] = min(dp[i], dp[j-1] + 1);
               }
           }
       }
   }
   ```

6. **与 1745 的关键区别**：
   - **1745**：只需检查特定分割方案（3段），用枚举即可
   - **132**：需要求所有方案中的最优值，必须用 DP 取最小值


### 代码实现

```cpp
class Solution {
public:
    int minCut(string s) {
        int n = s.size();
        // 第一步，预处理 isPal 表
        vector<vector<bool>> isPal(n, vector<bool>(n, false));
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (s[i] == s[j]) {
                    if (j - i <= 1) {
                        isPal[i][j] = true;
                    } else {
                        isPal[i][j] = isPal[i + 1][j - 1];
                    }
                }
            }
        }
        // 第二步，一维 DP
        vector<int> dp(n, n-1);  // 初始化为最大值
        for(int i = 0; i < n; i++) {
            if(isPal[0][i]) {  // 如果整个 s[0..i] 是回文
                dp[i] = 0;  // 整体是回文，不分割
            } else {
                // 枚举最后一个回文串的起点 j
                for(int j = 1; j <= i; j++) {
                    if(isPal[j][i])  // 需要知道 s[j..i] 是否回文
                        dp[i] = min(dp[i], dp[j-1] + 1);
                }
            }
        }
        return dp[n-1];
    }
};
```

### 复盘 & 要点
- **暴力到优化的关键**：识别重复计算，预处理回文判断信息 + 一维 DP
- **预处理模板**：和 647/5/1745 完全一致，`isPal[i][j] = s[i..j]` 是否回文
- **状态设计**：`dp[i] = s[0..i]` 的最少分割次数；目标 `dp[n-1]`
- **转移方程**：枚举最后一个回文段 `s[j..i]`，`dp[i] = min(dp[i], dp[j-1] + 1)`
- **边界处理**：`isPal[0][i]` 为 `true` 时 `dp[i] = 0`（整体回文不分割）
- **索引对应关系**：`isPal[i][j]` ↔ `s[i..j]`（无偏移）；`dp[i]` ↔ `s[0..i]`
- **与 1745 的区别**：1745 用枚举检查存在性，132 用 DP 求最优值
- **复杂度**：预处理 `O(n^2)` + DP `O(n^2)` = `O(n^2)` 时间，`O(n^2)` 空间
- **核心模式**：**预处理 + DP** 是求最优分割问题的通用思路

#### 💡 关键理解点
- **预处理范围**：132 需要预处理**所有**区间 `[i,j]` 的回文性，不是只预处理 3 段（1745 才是 3 段）
- **最大值理解**：`n` 个字符最坏需要 `n-1` 次分割（每个字符单独成段），初始化 `n-1` 即可
- **枚举逻辑**：像子序列 DP 但枚举的是**分割点**不是**元素**，`dp[i] = min(dp[j-1] + 1)` for all `j`
- **DP 思想**：考虑最后一个回文段 `s[j..i]`，前半部分 `s[0..j-1]` 用最优解，后半部分作为最后一段

#### 🎯 与其他题目的关系
- **647**：统计所有 `true` → 遍历 `isPal` 表计数
- **5**：找最长 `true` 区间 → 遍历 `isPal` 表记录最长
- **1745**：检查特定分割方案 → 枚举固定分割点
- **132**：求最优分割方案 → DP + 枚举所有分割点


---

## 今日总结

### 完成题目


### 核心收获


### 待解决问题


---
