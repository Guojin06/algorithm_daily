# Day12 - 10月13日学习笔记

**开始时间：** 2025年10月13日  
**今日专题：** LeetCode 81深度理解 + 位运算专题开启

## 📝 快速回顾 Day11 关键点（5分钟）

### 昨天的核心收获：
1. **搜索旋转排序数组（LeetCode 33）** - 两次二分找峰值+查找target
2. **寻找最小值（LeetCode 153）** - 一次二分快速秒杀
3. **二分查找通用框架** - 5步思维法+5大检查清单
4. **二段性必须连续** - 为什么和`nums[n]`比而不是和前一个比

**关键理解：**
- 旋转数组找峰值：`nums[mid] > nums[n]` → 左半边有峰值
- 二分模板：`left=mid` 找最后一个，`right=mid` 找第一个
- 变量作用域：定义在循环外
- 下标vs值：`right` 是下标，不能赋值为 `nums[i]`

---

## 🎯 今日学习计划

**你现在的进度：**
- ✅ Day07-11: 前缀和+二分查找（36题）
- 📊 **累计完成：36题**

---

### 早上任务（10-15分钟）：LeetCode 81深度理解

**问题：** 为什么LeetCode 81（有重复元素）不能用"两次二分"？

**目标：**
- 用苏格拉底式对话理解"重复元素如何破坏二段性"
- 理解"一次二分+特殊处理"的本质

---

### 上午/下午：位运算专题（5题）

**比特课程 - 算法精品课2（位运算章节）：**

1. **判断字符是否唯一**（面试题 01.01）⭐⭐ - easy
   - 知识点：位图思想
   - 用一个int的32位表示26个字母
   
2. **丢失的数字**（LeetCode 268）⭐⭐ - easy
   - 知识点：异或运算的"消消乐"规律
   - `x ^ x = 0, x ^ 0 = x`
   
3. **两整数之和**（LeetCode 371）⭐⭐⭐ - medium
   - 知识点：异或是无进位加法，按位与得到进位
   
4. **只出现一次的数字 II**（LeetCode 137）⭐⭐⭐⭐ - medium
   - 知识点：比特位计数
   - 统计每个比特位的和 % 3
   
5. **消失的两个数字**（面试题 17.19）⭐⭐⭐⭐ - hard
   - 知识点：异或 + 分组
   - 268题 + 260题的组合

---

## 💬 教练建议

**今天的节奏：**
- 早上10-15分钟理解81题
- 然后全新专题：位运算
- 轻松愉快，难度递增

**预计总用时：** 3-4小时

---

## 🧠 苏格拉底式教学：LeetCode 81深度理解

### 核心问题：为什么有重复元素就不能"两次二分"了？

---

### 第1步：理解二段性被破坏

**LeetCode 33（无重复）：**
```
数组：[4, 5, 6, 7, 0, 1, 2]

nums[mid] > nums[n] → 左边有峰值 ✅
nums[mid] < nums[n] → 右边有峰值 ✅  
nums[mid] == nums[n] → 不存在（无重复）

✅ 二段性连续 → 可以两次二分 O(log n)
```

**LeetCode 81（有重复）：**
```
数组：[1, 0, 1, 1, 1]

nums[mid] > nums[n] → 左边有峰值 ✅
nums[mid] < nums[n] → 右边有峰值 ✅
nums[mid] == nums[n] → 不知道！❌

❌ 二段性被破坏 → 无法用两次二分找峰值
```

**关键理解：** 当 `nums[mid] == nums[n]` 时，**无法判断峰值在左还是右**！

---

### 第2步：如何处理"无法判断"

**问题：** `nums[mid] == nums[n] == 1` 时，去掉 `nums[n]` 会漏答案吗？

**答案：不会！**
- `nums[mid] = 1`（中间有个 `1`）
- `nums[n] = 1`（最后也有个 `1`）
- 去掉最后的 `1`，中间还有一个！✅

**所以：**
```cpp
if(nums[left] == nums[mid] && nums[mid] == nums[right]) {
    left++;   // 去掉左边重复
    right--;  // 去掉右边重复
}
```

**时间复杂度：** 最坏情况 `[1,1,1,1,1]` → O(n)

---

### 第3步：为什么用"一次二分"而不是"两次二分"？

**方案对比：**
- **方案1（两次二分）：** 找峰值 O(n) + 查找 O(log n) = O(n)
- **方案2（一次二分）：** 直接找 target O(n) = O(n)

**结论：** 既然时间复杂度一样，选更简单的"一次二分"！

---

### 第4步：理解"至少一半有序"

**旋转数组的本质：** 两段有序拼接
```
原始：[0, 1, 2, 4, 5, 6, 7]
旋转：[4, 5, 6, 7, | 0, 1, 2]
      ←有序→   ←有序→
```

**取中点 mid：**
- **情况1：** `nums[left] <= nums[mid]` → 左半边 `[left...mid]` 有序
- **情况2：** `nums[left] > nums[mid]` → 右半边 `[mid...right]` 有序

**至少有一半是有序的！**

---

### 第5步：判断 target 在哪半边

**左半边有序：**
```cpp
if(nums[left] <= nums[mid]) {
    // target 在左半边 [left...mid] 的范围内吗？
    if(nums[left] <= target && target < nums[mid]) {
        right = mid - 1;  // 在左半边，往左找
    } else {
        left = mid + 1;   // 不在左半边，往右找
    }
}
```

**右半边有序：**
```cpp
else {
    // target 在右半边 [mid...right] 的范围内吗？
    if(nums[mid] < target && target <= nums[right]) {
        left = mid + 1;   // 在右半边，往右找
    } else {
        right = mid - 1;  // 不在右半边，往左找
    }
}
```

---

### 第6步：为什么用 `while(left <= right)`？

**两种模板对比：**

| 模板 | 适用场景 | 循环结束条件 |
|------|----------|--------------|
| `while(left < right)` | 找边界位置 | `left == right` |
| `while(left <= right)` | 判断是否存在 | `left > right` |

**81题用 `while(left <= right)` 的原因：**
- 题目要求判断 target 是否存在（返回 `true/false`）
- 找到时直接 `return true`，不需要最后的位置
- 避免单元素数组 `[5]` 时无法进入循环的问题

---

### 核心总结

**33题 vs 81题的本质区别：**

| 题目 | 特征 | 二段性 | 解法 | 时间复杂度 |
|------|------|--------|------|------------|
| LeetCode 33 | 无重复 | 连续 ✅ | 两次二分 | O(log n) |
| LeetCode 81 | 有重复 | 被破坏 ❌ | 一次二分+特殊处理 | O(n) 最坏 |

**核心理解：**
1. **重复元素破坏二段性** - `nums[mid] == nums[n]` 时无法判断
2. **去重不会漏答案** - 中间还有相同的值
3. **至少一半有序** - 旋转数组的本质
4. **判断 target 在哪半** - 有序部分可以用范围判断

---

### AC代码（完整版）

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        
        while(left <= right) {
            int mid = left + (right - left) / 2;
            
            // 找到了，直接返回
            if(nums[mid] == target) return true;
            
            // 关键：无法判断时缩小范围（去重）
            if(nums[left] == nums[mid] && nums[mid] == nums[right]) {
                left++;
                right--;
            }
            // 左半边有序
            else if(nums[left] <= nums[mid]) {
                // target 在左半边的范围内吗？
                if(nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;  // 在左半边
                } else {
                    left = mid + 1;   // 不在左半边
                }
            }
            // 右半边有序
            else {
                // target 在右半边的范围内吗？
                if(nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;   // 在右半边
                } else {
                    right = mid - 1;  // 不在右半边
                }
            }
        }
        
        return false;
    }
};
```

**提交结果：** ✅ AC！

---

