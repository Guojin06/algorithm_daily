# Day12 - 10月13日学习笔记

**开始时间：** 2025年10月13日  
**今日专题：** LeetCode 81深度理解 + 位运算专题开启

## 📝 快速回顾 Day11 关键点（5分钟）

### 昨天的核心收获：
1. **搜索旋转排序数组（LeetCode 33）** - 两次二分找峰值+查找target
2. **寻找最小值（LeetCode 153）** - 一次二分快速秒杀
3. **二分查找通用框架** - 5步思维法+5大检查清单
4. **二段性必须连续** - 为什么和`nums[n]`比而不是和前一个比

**关键理解：**
- 旋转数组找峰值：`nums[mid] > nums[n]` → 左半边有峰值
- 二分模板：`left=mid` 找最后一个，`right=mid` 找第一个
- 变量作用域：定义在循环外
- 下标vs值：`right` 是下标，不能赋值为 `nums[i]`

---

## 🎯 今日学习计划

**你现在的进度：**
- ✅ Day07-11: 前缀和+二分查找（36题）
- 📊 **累计完成：36题**

---

### 早上任务（10-15分钟）：LeetCode 81深度理解

**问题：** 为什么LeetCode 81（有重复元素）不能用"两次二分"？

**目标：**
- 用苏格拉底式对话理解"重复元素如何破坏二段性"
- 理解"一次二分+特殊处理"的本质

---

### 上午/下午：位运算专题（5题）

**今日任务（基础位运算题）：**

1. **位1的个数**（LeetCode 191）⭐⭐ - easy
   - 知识点：位计数基础
   - `n & (n-1)` 消除最低位的1
   
2. **比特位计数**（LeetCode 338）⭐⭐ - easy
   - 知识点：动态规划+位运算
   - `dp[i] = dp[i>>1] + (i&1)`
   
3. **汉明距离**（LeetCode 461）⭐⭐ - easy
   - 知识点：异或+位计数
   - 先异或，再统计1的个数
   
4. **只出现一次的数字**（LeetCode 136）⭐⭐ - easy
   - 知识点：异或运算的"消消乐"
   - `x ^ x = 0, x ^ 0 = x`
   
5. **只出现一次的数字 III**（LeetCode 260）⭐⭐⭐ - medium
   - 知识点：异或 + 分组
   - 利用异或结果的某一位将数组分成两组

**说明：** 这些题之前其他课讲过，今天做一遍巩固。明天继续后面5道位运算题。

---

## 💬 教练建议

**今天的节奏：**
- 早上10-15分钟理解81题
- 然后全新专题：位运算
- 轻松愉快，难度递增

**预计总用时：** 3-4小时

---

## 🧠 苏格拉底式教学：LeetCode 81深度理解

### 核心问题：为什么有重复元素就不能"两次二分"了？

---

### 第1步：理解二段性被破坏

**LeetCode 33（无重复）：**
```
数组：[4, 5, 6, 7, 0, 1, 2]

nums[mid] > nums[n] → 左边有峰值 ✅
nums[mid] < nums[n] → 右边有峰值 ✅  
nums[mid] == nums[n] → 不存在（无重复）

✅ 二段性连续 → 可以两次二分 O(log n)
```

**LeetCode 81（有重复）：**
```
数组：[1, 0, 1, 1, 1]

nums[mid] > nums[n] → 左边有峰值 ✅
nums[mid] < nums[n] → 右边有峰值 ✅
nums[mid] == nums[n] → 不知道！❌

❌ 二段性被破坏 → 无法用两次二分找峰值
```

**关键理解：** 当 `nums[mid] == nums[n]` 时，**无法判断峰值在左还是右**！

---

### 第2步：如何处理"无法判断"

**问题：** `nums[mid] == nums[n] == 1` 时，去掉 `nums[n]` 会漏答案吗？

**答案：不会！**
- `nums[mid] = 1`（中间有个 `1`）
- `nums[n] = 1`（最后也有个 `1`）
- 去掉最后的 `1`，中间还有一个！✅

**所以：**
```cpp
if(nums[left] == nums[mid] && nums[mid] == nums[right]) {
    left++;   // 去掉左边重复
    right--;  // 去掉右边重复
}
```

**时间复杂度：** 最坏情况 `[1,1,1,1,1]` → O(n)

---

### 第3步：为什么用"一次二分"而不是"两次二分"？

**方案对比：**
- **方案1（两次二分）：** 找峰值 O(n) + 查找 O(log n) = O(n)
- **方案2（一次二分）：** 直接找 target O(n) = O(n)

**结论：** 既然时间复杂度一样，选更简单的"一次二分"！

---

### 第4步：理解"至少一半有序"

**旋转数组的本质：** 两段有序拼接
```
原始：[0, 1, 2, 4, 5, 6, 7]
旋转：[4, 5, 6, 7, | 0, 1, 2]
      ←有序→   ←有序→
```

**取中点 mid：**
- **情况1：** `nums[left] <= nums[mid]` → 左半边 `[left...mid]` 有序
- **情况2：** `nums[left] > nums[mid]` → 右半边 `[mid...right]` 有序

**至少有一半是有序的！**

---

### 第5步：判断 target 在哪半边

**左半边有序：**
```cpp
if(nums[left] <= nums[mid]) {
    // target 在左半边 [left...mid] 的范围内吗？
    if(nums[left] <= target && target < nums[mid]) {
        right = mid - 1;  // 在左半边，往左找
    } else {
        left = mid + 1;   // 不在左半边，往右找
    }
}
```

**右半边有序：**
```cpp
else {
    // target 在右半边 [mid...right] 的范围内吗？
    if(nums[mid] < target && target <= nums[right]) {
        left = mid + 1;   // 在右半边，往右找
    } else {
        right = mid - 1;  // 不在右半边，往左找
    }
}
```

---

### 第6步：为什么用 `while(left <= right)`？

**两种模板对比：**

| 模板 | 适用场景 | 循环结束条件 |
|------|----------|--------------|
| `while(left < right)` | 找边界位置 | `left == right` |
| `while(left <= right)` | 判断是否存在 | `left > right` |

**81题用 `while(left <= right)` 的原因：**
- 题目要求判断 target 是否存在（返回 `true/false`）
- 找到时直接 `return true`，不需要最后的位置
- 避免单元素数组 `[5]` 时无法进入循环的问题

---

### 核心总结

**33题 vs 81题的本质区别：**

| 题目 | 特征 | 二段性 | 解法 | 时间复杂度 |
|------|------|--------|------|------------|
| LeetCode 33 | 无重复 | 连续 ✅ | 两次二分 | O(log n) |
| LeetCode 81 | 有重复 | 被破坏 ❌ | 一次二分+特殊处理 | O(n) 最坏 |

**核心理解：**
1. **重复元素破坏二段性** - `nums[mid] == nums[n]` 时无法判断
2. **去重不会漏答案** - 中间还有相同的值
3. **至少一半有序** - 旋转数组的本质
4. **判断 target 在哪半** - 有序部分可以用范围判断

---

### AC代码（完整版）

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        
        while(left <= right) {
            int mid = left + (right - left) / 2;
            
            // 找到了，直接返回
            if(nums[mid] == target) return true;
            
            // 关键：无法判断时缩小范围（去重）
            if(nums[left] == nums[mid] && nums[mid] == nums[right]) {
                left++;
                right--;
            }
            // 左半边有序
            else if(nums[left] <= nums[mid]) {
                // target 在左半边的范围内吗？
                if(nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;  // 在左半边
                } else {
                    left = mid + 1;   // 不在左半边
                }
            }
            // 右半边有序
            else {
                // target 在右半边的范围内吗？
                if(nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;   // 在右半边
                } else {
                    right = mid - 1;  // 不在右半边
                }
            }
        }
        
        return false;
    }
};
```

**提交结果：** ✅ AC！

---

## 🔢 位运算专题开始

### 基础知识回顾

**左移运算符 `<<`：**
- 将二进制位向左移动，右边用0填充
- 公式：`a << b` = `a × 2^b`
- 示例：`5 << 1 = 10`（0101 → 1010）

**右移运算符 `>>`：**
- 将二进制位向右移动，左边用0填充（无符号数）
- 公式：`a >> b` = `a ÷ 2^b`（向下取整）
- 示例：`10 >> 1 = 5`（1010 → 0101）

**常用技巧：**
- `1 << n`：快速计算 2^n
- `x & 1`：判断奇偶（1为奇数，0为偶数）
- `x & (x-1)`：消除最低位的1
- `x ^ x = 0`：任何数异或自己等于0
- `x ^ 0 = x`：任何数异或0等于自己

---

### 第1题：LeetCode 191 - 位1的个数

**题目：** 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

**示例：**
```
输入：11 (二进制 1011)
输出：3
```

**核心技巧：** `n & (n-1)` 会消除最低位的1

---

#### ❌ 初次尝试 - 数组存储（错误）

```cpp
class Solution {
public:
    int hammingWeight(int n) {
        int i = n, j = 0;
        int a[INT_MAX];  // ❌ 错误1：数组太大，爆栈
        int ret = 0;
        while(i) {
            a[j] = i % 2;
            i >> 1;         // ❌ 错误2：右移没有赋值
            if(a[j]) ret++;
            j++;
        }
        return ret;
    }
};
```

**错误分析：**
1. `int a[INT_MAX]` - 开了2147483647大小的数组，直接爆栈
2. `i >> 1` - 只计算了结果，没赋值给i，死循环
3. 思路复杂化了，不需要存储每一位

---

#### ✅ AC代码 - 方法1：逐位检查

```cpp
class Solution {
public:
    int hammingWeight(int n) {
        int ret = 0;
        while(n) {
            if(n & 1) ret++;  // 检查最低位是否为1
            n >>= 1;          // 右移一位
        }
        return ret;
    }
};
```

**思路：**
- 用 `n & 1` 检查最低位是否为1
- 用 `n >>= 1` 右移一位（相当于除以2）
- 循环32次（int型32位）

**时间复杂度：** O(32) = O(1)  
**空间复杂度：** O(1)

---

#### ✅ AC代码 - 方法2：`n & (n-1)` 技巧⭐

```cpp
class Solution {
public:
    int hammingWeight(int n) {
        int ret = 0;
        while(n) {
            n = n & (n - 1);  // 消除最低位的1
            ret++;
        }
        return ret;
    }
};
```

**核心技巧：** `n & (n-1)` 会消除n的最低位的1

**示例：**
```
n       = 1011000
n-1     = 1010111  (借位：最低的1变0，后面全变1)
n&(n-1) = 1010000  (消除了最低位的1)
```

**优势：** 有多少个1就循环多少次，比方法1更快！

**时间复杂度：** O(k)，k为1的个数  
**空间复杂度：** O(1)

---

### 第2题：LeetCode 338 - 比特位计数

**题目：** 给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数，返回一个长度为 n+1 的数组 ans 作为答案。

**示例：**
```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

**核心技巧：** 
- 方法1：调用上一题的函数n+1次
- 方法2：动态规划 `dp[i] = dp[i>>1] + (i&1)` ⭐

**提示：** `i>>1` 表示去掉最低位，`i&1` 表示最低位的值

---

#### ❌ 初次尝试 - 在循环里修改循环变量（错误）

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans(n + 1);
        ans[0] = 0;
        for(int i = 1; i <= n; i++) {
            while(i) {
                if(i & 1) ans[i]++;
                i = i >> 1;  // ❌ 在for循环里修改了循环变量i！
            }
        }
        return ans;
    }
};
```

**错误分析：**
- 在 `while` 循环里修改了 `for` 循环的变量 `i`
- 导致 `i` 变成0后，`for` 的 `i++` 又让 `i` 变成1
- **死循环**！

---

#### ✅ AC代码 - 方法1：暴力法（用临时变量）

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans(n + 1);
        for(int i = 0; i <= n; i++) {
            int temp = i;  // ✅ 用临时变量
            while(temp) {
                if(temp & 1) ans[i]++;
                temp >>= 1;
            }
        }
        return ans;
    }
};
```

**时间复杂度：** O(n log n) - 每个数最多32位  
**空间复杂度：** O(1) - 不算返回的ans数组

---

#### ✅ AC代码 - 方法2：动态规划⭐（最优解）

```cpp
class Solution {
public:
    vector<int> countBits(int n) {
        vector<int> ans(n + 1);
        ans[0] = 0;
        for(int i = 1; i <= n; i++) {
            ans[i] = ans[i >> 1] + (i & 1);  // DP公式
        }
        return ans;
    }
};
```

**核心公式：** `ans[i] = ans[i >> 1] + (i & 1)`

**理解：**
- `i >> 1` 是把 i 右移一位（去掉最低位）
- `i & 1` 是 i 的最低位（0或1）
- i的1的个数 = (i去掉最低位)的1的个数 + i的最低位

**示例：**
```
i = 5 (101):
  i>>1 = 2 (10)，ans[2] = 1
  i&1 = 1
  ans[5] = ans[2] + 1 = 2 ✅

i = 6 (110):
  i>>1 = 3 (11)，ans[3] = 2
  i&1 = 0
  ans[6] = ans[3] + 0 = 2 ✅
```

**时间复杂度：** O(n) - 满足进阶要求！  
**空间复杂度：** O(1)

**为什么DP是O(n)？**
- 位运算（`>>`, `&`）是CPU指令，**O(1)**
- 数组访问 `ans[i>>1]` 直接查表，**O(1)**
- DP利用已计算结果，避免重复计算
- 循环n次 × 每次O(1) = **O(n)** ✅

---

### 第3题：LeetCode 461 - 汉明距离

**题目：** 两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 x 和 y，计算并返回它们之间的汉明距离。

**示例：**
```
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
```

**核心思路：**
1. 先异或：`x ^ y` 得到不同的位（不同为1，相同为0）
2. 再统计1的个数（用第1题的方法）

**示例：**
```
1 ^ 4 = 0001 ^ 0100 = 0101  (二进制有2个1)
答案：2
```

---

#### ✅ AC代码 - 方法1：`n & (n-1)` 技巧

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        int xor_result = x ^ y;  // 异或得到不同的位
        int count = 0;
        
        // 统计1的个数（用第1题的方法）
        while(xor_result) {
            xor_result = xor_result & (xor_result - 1);
            count++;
        }
        
        return count;
    }
};
```

**思路：**
1. `x ^ y` 异或得到不同的位（不同为1，相同为0）
2. 统计结果中1的个数

**时间复杂度：** O(k)，k为1的个数  
**空间复杂度：** O(1)

---

#### ✅ AC代码 - 方法2：逐位检查

```cpp
class Solution {
public:
    int hammingDistance(int x, int y) {
        int xor_result = x ^ y;
        int count = 0;
        
        while(xor_result) {
            if(xor_result & 1) count++;
            xor_result >>= 1;
        }
        
        return count;
    }
};
```

**时间复杂度：** O(32) = O(1)  
**空间复杂度：** O(1)

---

### 第4题：LeetCode 136 - 只出现一次的数字

**题目：** 给你一个**非空**整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**示例：**
```
输入：nums = [2,2,1]
输出：1

输入：nums = [4,1,2,1,2]
输出：4
```

**进阶：** 你的算法应该具有线性时间复杂度 O(n)，并且只使用常量额外空间 O(1)。

**核心知识点：异或的"消消乐"规律**
- `a ^ a = 0` - 任何数异或自己等于0
- `a ^ 0 = a` - 任何数异或0等于自己
- 异或满足交换律和结合律

**示例：**
```
[4, 1, 2, 1, 2]
= 4 ^ 1 ^ 2 ^ 1 ^ 2
= 4 ^ (1 ^ 1) ^ (2 ^ 2)  (结合律)
= 4 ^ 0 ^ 0
= 4 ✅
```

**提示：** 把所有数异或一遍，出现两次的会"消掉"，剩下的就是答案！

---

#### ❌ 初次尝试 - 只异或相邻元素（错误）

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int n = nums.size();
        int ret = 0;
        for(int i = 0; i <= n - 2; i++) {
            ret = nums[i] ^ nums[i+1];  // ❌ 每次都在覆盖ret！
        }
        return ret;
    }
};
```

**错误分析：**
1. 每次循环用 `=` 赋值，覆盖了之前的结果，应该用 `^=` 累积
2. 只异或了**相邻的两个元素**，而不是**所有元素**
3. 应该遍历所有数，让出现两次的自动"消掉"

**错误过程：**
```
nums = [2, 2, 1]
i=0: ret = nums[0] ^ nums[1] = 2 ^ 2 = 0
i=1: ret = nums[1] ^ nums[2] = 2 ^ 1 = 3  ← 覆盖了！
返回 3 ❌
```

---

#### ✅ AC代码 - 全部异或

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret = 0;
        for(int num : nums) {
            ret ^= num;  // 累积异OR所有元素
        }
        return ret;
    }
};
```

**正确过程：**
```
nums = [2, 2, 1]
ret = 0
ret ^= 2  →  ret = 0 ^ 2 = 2
ret ^= 2  →  ret = 2 ^ 2 = 0  (消掉！)
ret ^= 1  →  ret = 0 ^ 1 = 1 ✅
```

**核心理解：**
- `a ^ a = 0` - 出现两次的消掉
- `a ^ 0 = a` - 只出现一次的保留
- 异OR满足交换律和结合律，顺序无关

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

---

### 第5题：LeetCode 260 - 只出现一次的数字 III ⭐

**题目：** 给你一个整数数组 `nums`，其中恰好有**两个元素**只出现一次，其余所有元素均出现两次。找出只出现一次的那**两个**元素。可以按任意顺序返回答案。

**示例：**
```
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效答案
```

**进阶：** 你的算法应该具有线性时间复杂度 O(n)，并且只使用常量额外空间 O(1)。

**核心思路（难点）：**
1. **步骤1：** 全部异OR，得到 `a ^ b`（两个只出现一次的数的异OR）
2. **步骤2：** 找到 `a ^ b` 中任意一个为1的位（说明a和b在这一位不同）
3. **步骤3：** 根据这一位将数组分成两组，分别异OR

**示例：**
```
nums = [1, 2, 1, 3, 2, 5]

步骤1：全部异OR
1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5 = 3 ^ 5 = 6 (二进制 110)

步骤2：找到最低位的1
6 & (-6) = 2 (二进制 010)  ← 第2位为1

步骤3：按第2位分组
第2位为0：[1,1,3]  → 1^1^3 = 3 ✅
第2位为1：[2,2,5]  → 2^2^5 = 5 ✅

答案：[3, 5]
```

**关键技巧：**
- `x & (-x)` 可以得到x的最低位的1
- 或者 `x & (x-1) ^ x` 也可以

---

#### ❌ 初次尝试 - 数组越界 + 整数溢出（错误）

```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        // 1. 先全部异或
        int xor_all = 0;
        for(int num : nums) xor_all ^= nums[num];  // ❌ 错误1：nums[num] 应该是 num

        // 2. 找分界位
        int xor_ret = xor_all & (-xor_all);  // ❌ 错误2：INT_MIN 取负会溢出
        int a = 0, b = 0;
        for(int i = 0; i < nums.size(); i++) {
            if(xor_ret & nums[i]) a ^= nums[i];
            else b ^= nums[i];
        }
        return {a, b};
    }
};
```

**错误分析：**
1. **数组越界：** `nums[num]` 中 `num` 是元素值，不是下标！当 `num` 大于数组长度时越界
2. **整数溢出：** `xor_all = INT_MIN` 时，`-xor_all` 会溢出（-2147483648 取负超出int范围）

---

#### ✅ AC代码 - 异或分组法

```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        // 1. 先全部异或，得到 a ^ b
        unsigned int xor_all = 0;  // ✅ 用 unsigned int 避免溢出
        for(int num : nums) xor_all ^= num;  // ✅ 直接用 num，不是 nums[num]

        // 2. 找分界位（最低位的1）
        unsigned int diff = xor_all & (-xor_all);  // ✅ 无符号数不会溢出
        
        // 3. 按分界位分组异或
        int a = 0, b = 0;
        for(int num : nums) {
            if(diff & num) a ^= num;  // 这一位为1的组
            else b ^= num;            // 这一位为0的组
        }
        
        return {a, b};
    }
};
```

---

#### 🧠 核心思路详解

**为什么这样分组能找到两个数？**

**步骤1：全部异或**
```
nums = [1, 2, 1, 3, 2, 5]
xor_all = 1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5 = 3 ^ 5 = 6 (110)
```

**步骤2：找分界位**
```
diff = 6 & (-6) = 110 & 010 = 010  ← 第2位为1
```
**含义：** 3和5在第2位不同！

**步骤3：按第2位分组**
```
第2位为0：[1(001), 1(001), 3(011)]  → 1^1^3 = 3 ✅
第2位为1：[2(010), 2(010), 5(101)]  → 2^2^5 = 5 ✅
```

**关键理解：**
- `a ^ b` 中为1的位，说明a和b在这一位**不同**
- 按这一位分组，**a和b一定在不同组**  
- 相同的数在这一位**相同**，所以**在同一组**
- 每组异或，相同的消掉，剩下a或b

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

---

## 🎉 今日总结

**恭喜完成位运算基础专题！** 今天共完成 **5道经典位运算题**：

| 题目 | 核心技巧 | 难度 | 状态 |
|------|----------|------|------|
| LeetCode 191 | `n & (n-1)` 消除最低位1 | ⭐⭐ | ✅ AC |
| LeetCode 338 | DP: `dp[i] = dp[i>>1] + (i&1)` | ⭐⭐ | ✅ AC |
| LeetCode 461 | 异或+位计数组合 | ⭐⭐ | ✅ AC |
| LeetCode 136 | 异或消消乐：`a ^ a = 0` | ⭐⭐ | ✅ AC |
| LeetCode 260 | 异或+分组：找两个不同数 | ⭐⭐⭐ | ✅ AC |

### 🔑 核心收获

**位运算基础：**
- 左移 `<<`：乘以2的幂
- 右移 `>>`：除以2的幂
- 异或 `^`：相同为0，不同为1，满足交换律和结合律

**经典技巧：**
- `n & (n-1)`：消除最低位的1
- `n & (-n)`：提取最低位的1  
- `n & 1`：判断奇偶
- `a ^ a = 0, a ^ 0 = a`：异或消消乐

**进阶应用：**
- **位计数优化：** DP比暴力快一个数量级
- **异或分组：** 巧妙利用位的不同来分组
- **类型选择：** 位运算推荐用 `unsigned` 避免溢出

### 📅 明天计划

明天继续**位运算进阶题**（5道），包括：
- 比特位操作
- 状态压缩DP
- 位掩码技巧

**今日用时约：** 2-3小时  
**累计完成：** 41题（前缀和+二分+位运算基础）

---

**今天学得很棒！** 位运算的基础已经打牢了，明天加油！💪