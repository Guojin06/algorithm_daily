# Day10 - 10月11日学习笔记

**开始时间：** 2025年10月11日  
**今日专题：** 测试昨天遗留题目 + 完成二维前缀和

## 📝 快速回顾 Day09 关键点（5分钟）

### 昨天完成情况（Day09 - 10.10）：
- ✅ 搜索插入位置（LeetCode 35）- WA→AC（搞混了left和mid）
- ✅ x的平方根（LeetCode 69）- Runtime Error→AC（类型转换陷阱）
- **累计完成：** 28题

### 昨天学到的核心知识：
1. **类型转换陷阱：**
   ```cpp
   long long mid = left + (right - left + 1) / 2;  // ❌ 右边还是int
   long long mid = left + ((long long)right - left + 1) / 2;  // ✅
   ```

2. **二分查找判断永远是 `nums[mid]`：**
   - 不是 `nums[left]`，不是 `nums[right]`
   - `left`、`right` 是边界，`mid` 是中间位置

### 待完成任务：
- ⏸️ Day08第3题：查找第一个和最后一个位置（LeetCode 34）- 代码已写，待测试
- ⏸️ 二维前缀和模板（比特课程第26题）
- ⏸️ 矩阵区域和（LeetCode 1314，比特课程第32题）

---

## 🎯 今日任务

### 上午任务（8:30-10:30，2小时）

#### ✅ 第一件事：测试Day08第3题（15分钟）

**第1题：在排序数组中查找元素的第一个和最后一个位置（LeetCode 34）**

**Day08写的代码：**
```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0) return {-1,-1};
        int leftval = 0, rightval = 0;
        int left = 0, right = nums.size() - 1;
        
        // 处理左端点
        while(left < right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] < target) left = mid + 1;
            else right = mid;
        }
        if(nums[left] != target) return{-1,-1};
        else leftval = left;
        
        // 处理右端点
        left = 0, right = nums.size() - 1;
        while(left < right) {
            int mid = left + (right - left + 1) / 2;
            if(nums[mid] <= target) left = mid;
            else right = mid - 1;
        }
        if(nums[left] != target) return{-1,-1};
        else rightval = right;  // ← 教练提示：可能有bug，应该是left
        
        return {leftval, rightval};
    }
};
```

**任务：**
1. 提交测试
2. 如果有错误，修正（可能是 `rightval = right` 应该改成 `rightval = left`）
3. AC后记录到笔记

---

**我的思路：**




---

**我的代码（如果需要修改）：**
```cpp

```

**提交结果：**
✅ AC！教练提示正确，确实是 `rightval = right` 应该改成 `rightval = left`


---

**我的收获：**

二分查找找右边界时，循环结束后 `left == right`，所以应该用 `left` 而不是 `right`。这是个容易忽略的细节！


---

#### 第2题：【模板】二维前缀和（比特课程第26题）

**题目说明：**
- 这是比特课程的模板题
- 理解二维前缀和的概念和公式

**二维前缀和核心公式：**

**1. 预处理前缀和矩阵：**
```
sum[i][j] = 矩阵 [0,0] 到 [i,j] 区域的和

递推公式：
sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + mat[i][j]

图解：
  +-------+---+
  |       | ↑ |
  | [i-1] | j |
  |  [j]  |   |
  +-------+---+
  | ← i   |当前|
  +-------+[i,j]

sum[i,j] = 上面矩形 + 左边矩形 - 重复部分 + 当前元素
```

**2. 使用前缀和矩阵求区域和：**
```
求 [x1,y1] 到 [x2,y2] 的区域和：

area = sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1]

图解：
  +-------+-------+
  |   A   |   B   |
  +-------+-------+
  |   C   | 目标区域|
  +-------+-------+

目标区域 = 大矩形 - 上方B - 左方C + 左上角A（因为被减了两次）
```

**比特课程讲解：** 打开 `比特课程/算法精品课1.md`，第26题

**学习任务：**
1. 阅读比特课程讲解
2. 理解公式和图解
3. 手推一个例子

---

**我的理解：**

先预处理前缀和矩阵，然后使用前缀和矩阵求区域和。
时间复杂度就是先遍历矩阵求前缀和需要O(mn)，然后求区域和需要q次，那么时间复杂度就是O(mn+q)。


---

#### 第3题：矩阵区域和（LeetCode 1314）⭐⭐ - 苏格拉底式教学

**题目描述：**
给你一个 `m x n` 的矩阵 `mat` 和一个整数 `k` ，请你返回一个矩阵 `answer` ，其中每个 `answer[i][j]` 是所有满足下述条件的元素 `mat[r][c]` 的和： 
- `i - k <= r <= i + k`
- `j - k <= c <= j + k`
- `(r, c)` 在矩阵内。

**示例：**
```
输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[12,21,16],[27,45,33],[24,39,28]]
```

**题目链接：** https://leetcode.cn/problems/matrix-block-sum/

---

## 🎓 教练带你一步步搞懂（苏格拉底式教学）

### 第一步：理解题意（用最简单的例子）

**问题1：我们先看一个超级简单的例子**

假设有矩阵：
```
mat = [[1, 2],
       [3, 4]]
k = 1
```

**提问：** `answer[0][0]` 应该是多少？（也就是 `mat[0][0]` 周围k=1距离内的所有元素之和）

**思考区域：**
```
位置 [0][0] 的值是 1
周围 k=1 距离内的元素有哪些？

     j=0  j=1
i=0  [1]  [2]   ← i-k=0-1=-1（越界），i+k=0+1=1
i=1  [3]  [4]   
     ↑    ↑
   j-k=0  j+k=1
   
所以区域是：[0][0] 到 [1][1]
sum = 1 + 2 + 3 + 4 = 10
```

**✅ 关键发现：** 我们需要计算的是一个**矩形区域**的和！

---

### 第二步：回顾一维前缀和的索引映射

**提问：** 在一维前缀和中，为什么要让前缀和数组多开一位？

**回忆一维前缀和：**
```cpp
原数组：  nums[0]  nums[1]  nums[2]  nums[3]
前缀和：dp[0]=0  dp[1]    dp[2]    dp[3]    dp[4]
         ↑        ↑        ↑        ↑        ↑
       哨兵位   到nums[0] 到nums[1] 到nums[2] 到nums[3]
                 的和      的和      的和      的和
```

**核心规则：**
- `dp[i]` 表示 `nums[0]` 到 `nums[i-1]` 的和
- **映射关系：** `dp[i]` 对应 `nums[i-1]`

**好处：** 有了哨兵位 `dp[0]=0`，我们就不用担心左边界越界了！

---

### 第三步：二维前缀和的索引映射（核心难点！）

**二维前缀和也是一样的思路！**

```
原矩阵 mat：        前缀和矩阵 dp：
                    
  j=0 j=1 j=2         j=0  j=1  j=2  j=3
i=0 [1] [2] [3]    i=0 [0]  [0]  [0]  [0]  ← 哨兵行
i=1 [4] [5] [6]    i=1 [0]  ...  ...  ...
i=2 [7] [8] [9]    i=2 [0]  ...  ...  ...
                   i=3 [0]  ...  ...  ...
                        ↑
                     哨兵列
```

**核心映射关系（敲黑板！）：**
```
dp[i][j] 表示原矩阵从 [0,0] 到 [i-1, j-1] 的区域和

也就是说：
- dp[1][1] → mat[0][0] 的和
- dp[2][2] → mat[0][0] 到 mat[1][1] 的和
- dp[3][3] → mat[0][0] 到 mat[2][2] 的和（整个矩阵）
```

**提问：** 如果我想求 `mat[0][0]` 到 `mat[1][1]` 的区域和，应该查询 `dp` 的哪个位置？

**答案：** `dp[2][2]`（因为 mat的[1][1] 对应 dp的[2][2]）

**转换公式：**
```
mat[i][j] ↔ dp[i+1][j+1]

想查 mat 的 [x1,y1] 到 [x2,y2]
就查 dp 的 [x1+1, y1+1] 到 [x2+1, y2+1]
```

---

### 第四步：手推示例（理解+1的含义）

用题目给的例子：
```
mat = [[1,2,3],
       [4,5,6],
       [7,8,9]]
k = 1

计算 answer[0][0]（也就是mat[0][0]周围k=1的区域和）
```

**Step 1：确定原矩阵的区域边界**
```
mat[0][0] 周围 k=1 的区域：
- 行范围：i-k 到 i+k = 0-1 到 0+1 = -1 到 1
  但要在矩阵内，所以是 max(0, -1) 到 min(2, 1) = 0 到 1
  
- 列范围：j-k 到 j+k = 0-1 到 0+1 = -1 到 1
  但要在矩阵内，所以是 max(0, -1) 到 min(2, 1) = 0 到 1

所以在 mat 中，区域是 [0,0] 到 [1,1]
```

**Step 2：转换到dp的坐标**
```
mat 的 [0,0] 到 [1,1]
↓
dp 的 [0+1, 0+1] 到 [1+1, 1+1]
=
dp 的 [1,1] 到 [2,2]
```

**Step 3：使用查询公式**
```
区域和 = dp[2][2] - dp[0][2] - dp[2][0] + dp[0][0]
```

**提问：** 现在你明白为什么要 `+1` 了吗？

---

### 第五步：修正你的代码

**你的代码错误分析：**

```cpp
// ❌ 错误1：预处理时漏了减去重复部分
dp[i][j] = dp[i-1][j] + dp[i][j-1] + mat[i-1][j-1];

// ✅ 应该是：
dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1];
//                                   ↑ 这里要减！
```

**为什么要减？** 因为 `dp[i-1][j]` 和 `dp[i][j-1]` 都包含了左上角 `dp[i-1][j-1]`，加了两次要减一次！

---

**✅ 完整正确代码：**

```cpp
class Solution {
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
        int m = mat.size(), n = mat[0].size();
        
        // 1. 预处理前缀和矩阵（多开一行一列作为哨兵）
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                // ✅ 核心公式：加加减加
                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1];
                //         上面矩形  + 左边矩形  - 重复部分(左上) + 当前元素
            }
        }
        
        // 2. 计算每个位置的区域和
        vector<vector<int>> ret(m, vector<int>(n));
        
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                // Step 1: 在mat中确定区域边界
                int x1 = max(0, i - k);      // 起始行
                int y1 = max(0, j - k);      // 起始列
                int x2 = min(m - 1, i + k);  // 结束行
                int y2 = min(n - 1, j + k);  // 结束列
                
                // Step 2: 转换到dp坐标（+1）
                // Step 3: 使用查询公式
                ret[i][j] = dp[x2+1][y2+1] - dp[x1][y2+1] - dp[x2+1][y1] + dp[x1][y1];
                //          大矩形         - 上方矩形    - 左方矩形    + 左上角
            }
        }
        
        return ret;
    }
};
```

---

### 第六步：记忆口诀（永远不会忘！）

**二维前缀和两大公式：**

1. **预处理：加加减加**
   ```cpp
   dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1];
   ```

2. **查询：大减上减左加角**
   ```cpp
   sum = dp[x2+1][y2+1] - dp[x1][y2+1] - dp[x2+1][y1] + dp[x1][y1];
   ```

**索引映射：**
- `dp` 比 `mat` 多一行一列
- `mat[i][j]` 对应 `dp[i+1][j+1]`
- 查询 `mat` 的 `[x1,y1]` 到 `[x2,y2]`，就查 `dp` 的 `[x1+1,y1+1]` 到 `[x2+1,y2+1]`
- 但查询公式的左上角要用 `dp[x1][y1]`（不+1），因为要**完全排除**这部分

---

**我的代码（修正版）：**
```cpp
class Solution {
public:
    vector<vector<int>> matrixBlockSum(vector<vector<int>>& mat, int k) {
        int m = mat.size(), n = mat[0].size();
        
        // 1. 预处理前缀和矩阵
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1];
            }
        }
        
        // 2. 计算区域和
        vector<vector<int>> ret(m, vector<int>(n));
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                int x1 = max(0, i - k);
                int y1 = max(0, j - k);
                int x2 = min(m - 1, i + k);
                int y2 = min(n - 1, j + k);
                
                ret[i][j] = dp[x2+1][y2+1] - dp[x1][y2+1] - dp[x2+1][y1] + dp[x1][y1];
            }
        }
        
        return ret;
    }
};
```

**提交结果：**
✅ AC！

---

**我的收获：**

### 1. 哨兵位的作用（自己推导出来的！）
- `dp` 比 `mat` 多开一圈（+1），第0行、第0列全是0
- **作用：** 防止越界，统一公式，不用写边界判断
- **代价：** 索引映射发生变化

### 2. 预处理的映射关系
```cpp
dp[i][j] 存的是 mat[0][0] 到 mat[i-1][j-1] 的区域和

映射：mat[i][j] ↔ dp[i+1][j+1]
```

### 3. 查询公式的本质（最重要！）
```cpp
查询 mat 的 [x1,y1] 到 [x2,y2]:

区域和 = dp[x2+1][y2+1] - dp[x1][y2+1] - dp[x2+1][y1] + dp[x1][y1]
```

**为什么这样转换？**
- 包含的右下角 `mat[x2][y2]` → `dp[x2+1][y2+1]`
- 排除的上方到 `mat[x1-1][y2]` → `dp[(x1-1)+1][y2+1]` = `dp[x1][y2+1]`
- 排除的左方到 `mat[x2][y1-1]` → `dp[x2+1][(y1-1)+1]` = `dp[x2+1][y1]`
- 排除的左上角 `mat[x1-1][y1-1]` → `dp[x1][y1]`

**关键理解：** 
- 看起来 `x1` 没+1，其实是 `(x1-1)+1` 抵消了！
- 包含的边界直接+1，排除的边界是 `-1` 再 `+1` 抵消

### 4. 记忆口诀
```
预处理：加加减加
  dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1]

查询：大减上减左加角
  包含的+1，排除的不+1（实际是-1和+1抵消）
```

### 5. 通用分析方法（以后自己用）
1. 看到 `dp(m+1, n+1)` → 有哨兵位
2. 推导基本映射 → `dp[i]` 对应 `mat[i-1]`
3. 查询时 → 包含的边界+1，排除的边界-1再+1抵消

### 下午任务（如果有时间，可选）

#### 第4题：继续二分查找专题

**可选题目：**
- 山峰数组的峰顶（LeetCode 852）
- 寻找峰值（LeetCode 162）
- 搜索旋转排序数组中的最小值（LeetCode 153）

---

## 💡 今日总结

**今天完成题数：** 3/3

**累计完成：** 28题 → 31题

**用时：** 约2.5小时

**今天的关键收获：**
1. **掌握了二维前缀和的索引映射本质** - 通过苏格拉底式教学，自己推导出哨兵位的作用和映射规律
2. **理解了查询公式为什么这样写** - 包含的边界+1，排除的边界实际是-1再+1抵消
3. **建立了通用分析框架** - 以后遇到类似问题可以自己分析

**我遇到的问题：**
1. 预处理时漏了 `- dp[i-1][j-1]`，导致结果偏大
2. 索引映射一开始很混乱，不理解为什么有的+1有的不+1

**明天的目标：**
- 继续二分查找专题，完成山峰数组、寻找峰值等题目
- 如果有时间，回顾一下前缀和+哈希的两道遗留题

---

**学习进度：** Day10/150 ✅

