# Day32 - 11.1 动态规划进阶

**日期**：2025年11月1日  
**主题**：线性DP - 解码方法 + 路径问题  
**学习目标**：掌握字符串DP和二维DP

---

## 📋 今日计划

### 核心题目
1. ⭐⭐⭐ LeetCode 91 - 解码方法（Medium）
2. ⭐⭐ LeetCode 62 - 不同路径（Medium）

**备注**：今天时间有限（参加天池赛10小时），专注这2道核心题

---

## 💡 今日学习重点

### **1. 字符串DP**
- 状态定义：`dp[i]` 表示前i个字符的解码方法数
- 需要考虑1位数字和2位数字的组合
- 边界条件：'0'的特殊处理

### **2. 二维DP**
- 状态定义：`dp[i][j]` 表示到达位置(i,j)的路径数
- 转移方程：从上方和左方转移
- 空间优化：二维→一维

---

## 1. LeetCode 91 - 解码方法

### 📌 题目信息
- **难度**：Medium
- **标签**：动态规划、字符串
- **链接**：[LeetCode 91](https://leetcode.com/problems/decode-ways/)

---

### 📋 题目描述

一条包含字母 `A-Z` 的消息通过以下映射进行了编码：
```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

给你一个只含数字的字符串 `s`，请计算并返回解码方法的总数。

**示例 1**：
```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或 "L"（12）。
```

**示例 2**：
```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ"（2 26）, "VF"（22 6）或 "BBF"（2 2 6）。
```

**示例 3**：
```
输入：s = "06"
输出：0
解释："06" 无法映射到 "F"，因为 "6" 和 "06" 不同。
```

---

### 🤔 解题思路

**核心问题**：每个位置的字符可以单独解码，也可以和前一个字符组合解码

**DP四步法**：

**Step 1：状态表示**
```
dp[i] 表示：字符串 s[0...i-1] 的解码方法数
（dp[i]对应前i个字符）
```

**Step 2：状态转移方程**
```
对于位置i，考虑两种情况：

1. 单独解码（1位数字）：
   如果 s[i-1] != '0'，可以单独解码
   dp[i] += dp[i-1]

2. 组合解码（2位数字）：
   如果 s[i-2:i] 在 [10, 26] 范围内，可以组合解码
   dp[i] += dp[i-2]

综合：
if (s[i-1] != '0')
    dp[i] += dp[i-1];
if (s[i-2] == '1' || (s[i-2] == '2' && s[i-1] <= '6'))
    dp[i] += dp[i-2];
```

**Step 3：初始化**
```
dp[0] = 1  （空字符串有1种解码方法）
dp[1] = s[0] != '0' ? 1 : 0  （第1个字符）
```

**Step 4：填表顺序**
```
从左往右：i 从 2 到 n
```

---

### 🎯 关键点分析

#### **1. '0'的特殊处理**
```
'0' 不能单独解码（没有字母对应"0"）
'0' 只能和前一个字符组成 "10" 或 "20"

示例：
"10" → 1种方法（"J"）
"30" → 0种方法（无效）
"06" → 0种方法（"6"和"06"不同）
```

#### **2. 两位数的有效范围**
```
有效的两位数：10 ~ 26

判断条件：
- s[i-2] == '1'：11~19 都有效
- s[i-2] == '2' && s[i-1] <= '6'：20~26 有效
- 其他：无效
```

#### **3. 状态转移示例**

```
s = "226"

i=0: dp[0] = 1 (空字符串)
i=1: s[0]='2' → dp[1] = 1 (方法:"2")
i=2: s[1]='2' 
     - 单独: '2' 可以 → dp[2] += dp[1] = 1
     - 组合: '22' 在[10,26]内 → dp[2] += dp[0] = 1
     - dp[2] = 2 (方法:"2,2" 和 "22")
i=3: s[2]='6'
     - 单独: '6' 可以 → dp[3] += dp[2] = 2
     - 组合: '26' 在[10,26]内 → dp[3] += dp[1] = 1
     - dp[3] = 3 (方法:"2,2,6" 和 "22,6" 和 "2,26")
```

---

### 💻 代码实现

#### **版本1：直接处理边界（初版）**

```cpp
class Solution {
public:
    int numDecodings(string s) {
        // DP四步法：
        // 1. 创建dp表
        // 2. 初始化
        // 3. 填表
        // 4. 返回值
        
        int n = s.size();
        vector<int> dp(n);
        
        // 初始化第1个字符
        dp[0] = s[0] != '0';
        
        // 处理边界情况
        if(n == 1) return dp[0];
        
        // 初始化第2个字符
        if(s[0] != '0' && s[1] != '0') 
            dp[1] += 1;  // 单独解码
        int t = (s[0] - '0') * 10 + s[1] - '0';  // 前两个位置表示的数
        if(t >= 10 && t <= 26) 
            dp[1] += 1;  // 组合解码
        
        // 填表
        for(int i = 2; i < n; i++) {
            if(s[i] != '0') 
                dp[i] += dp[i-1];  // 单独编码
            int t = (s[i-1] - '0') * 10 + s[i] - '0';
            if(t >= 10 && t <= 26) 
                dp[i] += dp[i-2];  // 组合编码
        }
        
        return dp[n-1];
    }
};
```

**问题**：需要单独处理dp[1]的初始化，代码较复杂

---

#### **版本2：虚拟节点优化（推荐）** ⭐⭐⭐

```cpp
class Solution {
public:
    int numDecodings(string s) {
        // DP四步法（虚拟节点优化）
        
        int n = s.size();
        vector<int> dp(n + 1);  // 多开一个位置
        
        // 初始化虚拟节点
        dp[0] = 1;  // 空字符串有1种解码方法（保证后面填表正确）
        dp[1] = s[1-1] != '0';  // 第1个字符（注意索引映射）
        
        // 填表：从i=2开始
        for(int i = 2; i <= n; i++) {
            // 单独解码
            if(s[i-1] != '0') 
                dp[i] += dp[i-1];
            
            // 组合解码
            int t = (s[i-2] - '0') * 10 + s[i-1] - '0';
            if(t >= 10 && t <= 26) 
                dp[i] += dp[i-2];
        }
        
        return dp[n];
    }
};
```

**优势**：统一了初始化和填表逻辑，代码更简洁

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

### 核心知识点

#### **DP技巧1：虚拟节点（哨兵节点）** ⭐⭐⭐

**什么是虚拟节点？**
```
在dp数组的开头额外添加一个位置dp[0]，不对应实际字符，
作为"空状态"，用于简化边界条件的处理。
```

**为什么dp[0] = 1？**

这是本题的**关键理解点**！

```
dp[0]表示：空字符串的解码方法数

问：空字符串有多少种解码方法？
答：1种（什么都不解码）

但更重要的是：dp[0]=1 保证了后面的状态转移正确！
```

**图解说明**：

```
字符串 s = "12"

版本1（无虚拟节点）：
dp数组：dp[0]  dp[1]
字符串：s[0]   s[1]
       '1'    '2'

版本2（有虚拟节点）：
dp数组：dp[0]  dp[1]  dp[2]
字符串：(空)   s[0]   s[1]
       虚拟   '1'    '2'
```

**为什么需要dp[0]=1？**

考虑 `s = "12"` 计算 `dp[2]`：
```
组合解码："12" 可以解码为 "L"
dp[2] += dp[0]

如果dp[0]=0：
dp[2] = 0 + ... （错误！"12"→"L"这种方法被忽略了）

如果dp[0]=1：
dp[2] = 1 + ... （正确！相当于"12"整体作为一个字母）
```

**再举例**：`s = "226"`

```
计算dp[2]（字符"22"）：
- 单独：dp[2] += dp[1]（前1个字符的方法数）
- 组合："22"可以组合 → dp[2] += dp[0]

dp[0]=1的含义：
如果"22"整体解码，相当于前面是空字符串（1种方法）
然后加上"22"这个整体，仍是1种方法
```

---

#### **DP技巧2：索引映射关系** ⭐⭐⭐

使用虚拟节点后，需要注意**dp数组索引**和**字符串索引**的对应关系：

```
dp数组索引：  0      1      2      3    ...   i
字符串索引：  (空)   s[0]   s[1]   s[2]  ...  s[i-1]

关键映射：
dp[i] 对应 s[i-1]（前i个字符）
```

**代码中的映射**：

```cpp
// 访问第i个字符时：
dp[1] → s[1-1] = s[0]  // 第1个字符
dp[i] → s[i-1]         // 第i个字符

// 判断单独解码：
if(s[i-1] != '0')      // 第i个字符
    dp[i] += dp[i-1];

// 判断组合解码：
int t = (s[i-2] - '0') * 10 + s[i-1] - '0';  // 第i-1和第i个字符
if(t >= 10 && t <= 26) 
    dp[i] += dp[i-2];
```

**对比表**：

| dp索引 | 对应字符 | 含义 |
|--------|---------|------|
| dp[0] | (无) | 空字符串的方法数 |
| dp[1] | s[0] | 前1个字符的方法数 |
| dp[2] | s[1] | 前2个字符的方法数 |
| dp[i] | s[i-1] | 前i个字符的方法数 |
| dp[n] | s[n-1] | 整个字符串的方法数 |

---

#### **两个版本对比**

| 特性 | 版本1（dp[n]） | 版本2（dp[n+1]）|
|------|---------------|----------------|
| **数组大小** | n | n+1 |
| **虚拟节点** | ❌ 无 | ✅ dp[0]=1 |
| **初始化** | 需要单独处理dp[0]和dp[1] | 统一处理 |
| **循环范围** | `for(i=2; i<n)` | `for(i=2; i<=n)` |
| **索引映射** | dp[i] = s[i] | dp[i] = s[i-1] |
| **返回值** | dp[n-1] | dp[n] |
| **代码复杂度** | 较复杂 | 简洁 |

**推荐**：使用版本2（虚拟节点），代码更优雅！

---

#### **虚拟节点的通用场景**

虚拟节点不仅用于本题，在很多DP问题中都有应用：

| 问题类型 | 虚拟节点作用 | 初始化 |
|---------|------------|-------|
| **字符串DP** | 表示空字符串 | dp[0]=1或0 |
| **路径问题** | 起点左边/上边的虚拟位置 | dp[0][j]=?或dp[i][0]=? |
| **背包问题** | 容量为0的状态 | dp[0]=0 |

---

### 提交结果
- 提交时间：一次AC ✅
- 执行用时：符合预期
- 内存消耗：O(n)

---

## 2. LeetCode 62 - 不同路径

### 📌 题目信息
- **难度**：Medium
- **标签**：动态规划、数学、组合数学
- **链接**：[LeetCode 62](https://leetcode.com/problems/unique-paths/)

---

### 📋 题目描述

一个机器人位于一个 `m x n` 网格的左上角（标记为 "Start"）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（标记为 "Finish"）。

问总共有多少条不同的路径？

**示例 1**：
```
输入：m = 3, n = 7
输出：28
```

**示例 2**：
```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 右 -> 下 -> 下
2. 下 -> 下 -> 右
3. 下 -> 右 -> 下
```

---

### 🤔 解题思路

**核心观察**：到达某个位置的路径数 = 从上方来的路径数 + 从左方来的路径数

**DP四步法**：

**Step 1：状态表示**
```
dp[i][j] 表示：到达位置 (i, j) 的不同路径数
```

**Step 2：状态转移方程**
```
dp[i][j] = dp[i-1][j] + dp[i][j-1]

解释：
- 到达(i,j)只有两种方式：
  1. 从上方(i-1,j)向下走一步
  2. 从左方(i,j-1)向右走一步
```

**Step 3：初始化**
```
第一行：dp[0][j] = 1  （只能一直向右）
第一列：dp[i][0] = 1  （只能一直向下）
```

**Step 4：填表顺序**
```
从左到右，从上到下
for i from 1 to m-1:
    for j from 1 to n-1:
        dp[i][j] = dp[i-1][j] + dp[i][j-1]
```

---

### 🎯 图解示例

```
m = 3, n = 3 的情况：

网格示意：
Start → → → 
  ↓     ↓   ↓
  ↓     ↓   ↓
  ↓     ↓   Finish

dp表填充过程：

初始化第一行和第一列：
  0  1  2
0[1][1][1]
1[1][ ][ ]
2[1][ ][ ]

填表：
  0  1  2
0[1][1][1]
1[1][2][3]
2[1][3][6]

计算过程：
dp[1][1] = dp[0][1] + dp[1][0] = 1 + 1 = 2
dp[1][2] = dp[0][2] + dp[1][1] = 1 + 2 = 3
dp[2][1] = dp[1][1] + dp[2][0] = 2 + 1 = 3
dp[2][2] = dp[1][2] + dp[2][1] = 3 + 3 = 6
```

---

### 💡 优化思路

#### **空间优化：二维→一维** ⭐⭐⭐

**观察**：
```
dp[i][j] = dp[i-1][j] + dp[i][j-1]

关键发现：
- dp[i][j] 只依赖当前行和上一行
- 不需要保存所有行，只需要保存一行
```

**优化方法**：
```
用一维数组 dp[n] 表示当前行

滚动更新：
for i from 1 to m-1:
    for j from 1 to n-1:
        dp[j] += dp[j-1]
        
解释：
- dp[j]：更新前是上一行的值（对应dp[i-1][j]）
- dp[j-1]：当前行左边的值（对应dp[i][j-1]）
- 相加后dp[j]变成当前行的值
```

**空间复杂度**：O(m*n) → O(n)

---

### 💻 代码实现

#### **方法1：二维DP**

（先自己实现，AC后记录）

```cpp
// 你的代码





```

**时间复杂度**：  
**空间复杂度**：

---

#### **方法2：一维DP优化**

（可选，理解二维后再尝试）

```cpp
// 你的代码





```

**时间复杂度**：  
**空间复杂度**：

---

### 提交结果
- 提交时间：
- 执行用时：
- 内存消耗：

---

## 今日总结

### 完成情况
- [x] LeetCode 91 - 解码方法 ✅
- [ ] LeetCode 62 - 不同路径

### 核心知识点

#### **1. 字符串DP特点**

```
关键：
- 需要考虑字符的有效性（如'0'不能单独解码）
- 状态转移可能来自多个前置状态
- 边界条件的特殊处理很重要
```

---

#### **2. 二维DP基础**

```
模板：
1. 状态定义：dp[i][j] 表示到达(i,j)的...
2. 状态转移：dp[i][j] = f(dp[i-1][j], dp[i][j-1], ...)
3. 初始化：第一行、第一列
4. 填表顺序：从左到右，从上到下
```

---

#### **3. 二维→一维空间优化**

```
条件：
✓ 当前状态只依赖上一行和当前行

步骤：
1. 用一维数组代替二维数组
2. 逐行更新一维数组
3. 注意更新顺序（从左到右）

优势：
- 空间复杂度：O(m*n) → O(n)
- 时间复杂度不变
```

---

#### **4. DP问题分类**

| 类型 | 示例 | 状态维度 |
|------|------|----------|
| **斐波那契型** | 爬楼梯、泰波那契 | 一维 |
| **字符串型** | 解码方法 | 一维 |
| **路径型** | 不同路径 | 二维 |

---

### 收获与反思

#### **今日核心收获** 🎯

（AC后自己总结）

---

#### **易错点记录**

（遇到的坑记录在这里）

---

#### **下一步计划**

**明天学习**：
- [ ] Day33 - 打家劫舍系列（继续DP经典题型）
- [ ] 或者：最长公共子序列系列

---

**学习环境**：参加阿里云天池赛10小时后的学习 💪  
**Day32学习完成时间**：  
**今日总用时**：  
**累计学习天数**：32天 🎉

---

