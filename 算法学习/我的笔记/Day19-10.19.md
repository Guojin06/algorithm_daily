# Day19 - 10.19 哈希表专题

## 今日目标

**主题：** 哈希表（Hash Table）

**题目列表：**
1. LeetCode 1 - 两数之和（easy）⭐
2. 面试题 01.02 - 判定是否互为字符重排（easy）
3. LeetCode 217 - 存在重复元素（easy）
4. LeetCode 219 - 存在重复元素 II（easy）
5. LeetCode 49 - 字母异位词分组（medium）⭐⭐

**预计用时：** 2-3小时

---

## 知识点梳理

### 哈希表基础

**什么是哈希表？**
- **本质：** 建立键值对（key-value）的映射关系
- **作用：** 快速查找、插入、删除，时间复杂度 O(1)
- **经典用途：** 
  - 统计频次
  - 快速查找
  - 去重
  - 建立元素与下标的映射

### C++ 常用哈希容器

#### 1. unordered_map（哈希表）
```cpp
#include <unordered_map>

unordered_map<int, int> hash;  // <key, value>

// 插入
hash[key] = value;
hash.insert({key, value});

// 查找
if(hash.count(key)) { }      // 判断是否存在
if(hash.find(key) != hash.end()) { }  // 另一种判断方式

// 访问
int val = hash[key];

// 遍历
for(auto& [key, val] : hash) { }
```

#### 2. unordered_set（哈希集合）
```cpp
#include <unordered_set>

unordered_set<int> hash;

// 插入
hash.insert(x);

// 查找
if(hash.count(x)) { }

// 删除
hash.erase(x);
```

### 哈希表常见技巧

#### 1. 统计频次
```cpp
unordered_map<int, int> hash;  // <元素, 出现次数>
for(auto x : nums) {
    hash[x]++;
}
```

#### 2. 元素与下标的映射
```cpp
unordered_map<int, int> hash;  // <nums[i], i>
for(int i = 0; i < nums.size(); i++) {
    hash[nums[i]] = i;
}
```

#### 3. 边遍历边查找（经典技巧）
```cpp
unordered_map<int, int> hash;
for(int i = 0; i < nums.size(); i++) {
    int target = k - nums[i];
    if(hash.count(target)) {
        // 找到了！
        return {hash[target], i};
    }
    hash[nums[i]] = i;  // 同时插入
}
```

#### 4. 数组模拟哈希表（字符）
```cpp
int hash[26] = {0};  // 只有小写字母

// 统计
for(char ch : s) {
    hash[ch - 'a']++;
}
```

---

## 题目解析

### 1. 两数之和（LeetCode 1）⭐

**链接：** https://leetcode.cn/problems/two-sum/

**题目描述：**
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。

**示例：**
```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]
```

#### 我的思路：

<details>
<summary>点击展开/收起</summary>

**思路分析：**

**方法一：暴力枚举**
- 两层循环遍历所有可能的组合
- 外层循环 i，内层循环 j = i+1
- 计算 nums[i] + nums[j] 是否等于 target
- 时间复杂度高但思路直观

**方法二：哈希表（最优解）** ⭐
- 核心思想：用哈希表存储 `<元素值, 下标>` 的映射
- 遍历数组时，计算 `complement = target - nums[i]`
- 先在哈希表中查找 complement 是否存在
- 如果存在，说明找到了答案，返回 `{hash[complement], i}`
- 如果不存在，将当前元素及下标存入哈希表
- **关键技巧：边遍历边查找！**

**为什么先判断后插入？**
- 防止同一个元素被使用两次
- 例如 nums = [3, 3], target = 6，如果先插入再判断，会错误地返回 [0, 0]

**时间复杂度：**
- 暴力：O(n²) - 双重循环
- 哈希表：O(n) - 一次遍历，哈希表查找 O(1)

**空间复杂度：**
- 暴力：O(1)
- 哈希表：O(n) - 最坏情况下存储所有元素

</details>

#### 我的代码：

**方法一：暴力枚举**
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        for(int i = 0; i < nums.size(); i++)
        {
            for(int j = i+1; j < nums.size(); j++)
            {
                int ret = nums[i] + nums[j];
                if(ret == target) return {i, j};
            }
        }
        return {};
    }
};
```

**方法二：哈希表（最优解）** ⭐
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hash;  // <元素值, 下标>
        int complement = 0;
        for(int i = 0; i < nums.size(); i++)
        {
            complement = target - nums[i];
            // 先判断补数是否在哈希表中
            if(hash.count(complement)) 
                return {hash[complement], i};
            // 后写入，防止将当前数算进去
            hash[nums[i]] = i;   
        }
        return {};
    }
};
```

#### 提交结果：

- **是否通过：** ✅ AC
- **用时：** 
  - 暴力法：约 O(n²)
  - 哈希表：约 O(n)
- **两种方法都通过！**

#### 易错点总结：

1. **哈希表的插入时机** ⭐⭐⭐
   - ❌ 错误：先插入再查找 → 可能导致同一元素使用两次
   - ✅ 正确：先查找再插入 → 保证两个下标不同
   
2. **返回值格式**
   - 要返回下标，不是元素值
   - C++ 中可以用 `{a, b}` 直接返回 vector

3. **边界情况**
   - 数组只有两个元素的情况
   - 数组中有重复元素的情况

#### 优化思路：

从暴力 O(n²) 到哈希表 O(n)，这是典型的**"用空间换时间"**的思想！

**核心优化：**
- 暴力法需要两层循环来查找配对
- 哈希表将"查找配对"的时间从 O(n) 降到 O(1)
- 这种"边遍历边查找"的技巧在哈希表题目中非常常用！



---

### 2. 判定是否互为字符重排（面试题 01.02）

**链接：** https://leetcode.cn/problems/check-permutation-lcci/

**题目描述：**
给定两个由小写字母组成的字符串 s1 和 s2，判断 s1 能否通过重新排列字符得到 s2。

**示例：**
```
输入: s1 = "abc", s2 = "bca"
输出: true

输入: s1 = "abc", s2 = "bad"
输出: false
```

#### 我的思路：

<details>
<summary>点击展开/收起</summary>

**思路分析：**

**核心思想：** 如果两个字符串能够互相重排，那么它们各个字符出现的次数一定相同！

**方法一：unordered_map**
- 用两个哈希表分别统计 s1 和 s2 中每个字符出现的次数
- 最后比较两个哈希表是否相等
- unordered_map 可以直接用 `==` 比较

**方法二：数组模拟哈希表** ⭐
- 只有小写字母，可以用 `int hash[26]` 模拟
- 同样分别统计两个字符串
- 数组不能直接用 `==` 比较，需要逐个元素比较

**方法三：单数组优化** ⭐⭐
- 只用一个数组
- 遍历 s1 时 `hash[ch]++`（加）
- 遍历 s2 时 `hash[ch]--`（减）
- 最后检查数组是否全为 0

**时间复杂度：**
- 三种方法都是 O(n + m)，n 和 m 分别是两个字符串的长度
- 最后检查哈希表/数组是 O(26) = O(1)

**空间复杂度：**
- unordered_map：O(字符种类数)，最多 O(26)
- 数组：O(26) = O(1)

</details>

#### 我的代码：

**方法一：unordered_map（首次AC）**
```cpp
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        unordered_map<char, int> hash1;
        unordered_map<char, int> hash2;
        
        for(int i = 0; i < s1.size(); i++) {
            hash1[s1[i]]++;
        }
        
        for(int j = 0; j < s2.size(); j++) {
            hash2[s2[j]]++;
        }
        
        if(hash1 == hash2) return true;
        else return false;
    }
};
```

**方法二：数组模拟哈希表**
```cpp
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        int hash1[26] = {0};
        int hash2[26] = {0};
        
        for(int i = 0; i < s1.size(); i++) {
            hash1[s1[i] - 'a']++;
        }
        
        for(int j = 0; j < s2.size(); j++) {
            hash2[s2[j] - 'a']++;
        }
        
        // 注意：数组不能直接用 == 比较，需要逐个元素比较
        for(int i = 0; i < 26; i++) {
            if(hash1[i] != hash2[i]) return false;
        }
        return true;
    }
};
```

**方法三：单数组优化（推荐）** ⭐
```cpp
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        if(s1.size() != s2.size()) return false;  // 长度不同直接false
        
        int hash[26] = {0};
        
        // s1加，s2减
        for(int i = 0; i < s1.size(); i++) {
            hash[s1[i] - 'a']++;
            hash[s2[i] - 'a']--;
        }
        
        // 检查是否全为0
        for(int i = 0; i < 26; i++) {
            if(hash[i] != 0) return false;
        }
        return true;
    }
};
```

#### 提交结果：

- **是否通过：** ✅ AC
- **用时：** 3分12秒（unordered_map版本）
- **三种方法都通过！**

#### 易错点总结：

1. **单引号 vs 变量** ⭐⭐⭐
   - ❌ `hash1['s1[i]' - 'a']++` - 错误！单引号会把整个当成字符常量
   - ✅ `hash1[s1[i] - 'a']++` - 正确！s1[i] 是变量
   
2. **数组类型选择**
   - ❌ `char hash[26]` - 范围太小，计数可能溢出
   - ✅ `int hash[26]` - 足够存储计数

3. **数组比较方式** ⭐⭐⭐
   - ❌ `if(hash1 == hash2)` - 错误！比较的是地址，不是内容
   - ✅ 逐个元素比较：
     ```cpp
     for(int i = 0; i < 26; i++) {
         if(hash1[i] != hash2[i]) return false;
     }
     ```

4. **循环变量笔误**
   - ❌ `hash1[s1[1] - 'a']++` - 永远统计第2个字符
   - ✅ `hash1[s1[i] - 'a']++` - 用循环变量 i

#### 优化思路：

**从两个数组到一个数组：**
- 方法二用了两个数组，空间占用较多
- 方法三只用一个数组，利用"加减抵消"的思想
- 如果能重排，最后所有计数应该都是 0

**unordered_map vs 数组：**
- 如果字符范围确定（只有26个小写字母），数组更快
- 如果字符范围不确定（包含大小写、数字等），用 unordered_map

**哈希表的比较：**
- `unordered_map` 可以直接用 `==` 比较
- 数组必须逐个元素比较
- 这是 C++ STL 容器的便利性体现



---

### 3. 存在重复元素（LeetCode 217）

**链接：** https://leetcode.cn/problems/contains-duplicate/

**题目描述：**
如果存在一值在数组中出现至少两次，函数返回 true；如果数组中每个元素互不相同，返回 false。

**示例：**
```
输入：nums = [1,2,3,1]
输出：true

输入：nums = [1,2,3,4]
输出：false
```

#### 我的思路：

<details>
<summary>点击展开/收起</summary>

**思路分析：**

**核心思想：** 判断数组中是否有重复元素

**方法一：unordered_map 统计次数**
- 用哈希表统计每个元素出现的次数
- 边遍历边统计，如果某个元素出现次数 > 1，说明有重复
- 立即返回 true

**方法二：unordered_set（更优）** ⭐
- 不需要统计次数，只需要判断元素是否存在过
- 边遍历边检查：如果元素已经在 set 中，说明重复
- 否则将元素加入 set
- 这种"边遍历边查找"的技巧又出现了！

**时间复杂度：**
- 两种方法都是 O(n)
- 哈希表/set 的查找和插入都是 O(1)

**空间复杂度：**
- O(n) - 最坏情况下所有元素都不重复，存储所有元素

</details>

#### 我的代码：

**方法一：unordered_map（我的解法）**
```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_map<int, int> hash;
        for(int i = 0; i < nums.size(); i++)
        {
            hash[nums[i]]++;
            if(hash[nums[i]] > 1) return true;
        }
        return false;
    }
};
```

**方法二：unordered_set（更简洁）** ⭐
```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> hash;
        for(auto x : nums)
        {
            if(hash.count(x)) return true;  // 已存在，说明重复
            hash.insert(x);                  // 否则加入set
        }
        return false;
    }
};
```

#### 提交结果：

- **是否通过：** ✅ AC
- **用时：** 1分38秒 ⚡
- **速度越来越快了！**

#### 易错点总结：

1. **容器选择**
   - 只判断是否存在，用 `unordered_set`
   - 需要统计次数，用 `unordered_map`
   - 本题只需要判断存在性，set 更合适

2. **边遍历边检查**
   - 不需要先全部插入再检查
   - 遍历的同时就可以检查是否重复
   - 一旦发现重复立即返回，提高效率

3. **范围for循环**
   - `for(auto x : nums)` 比 `for(int i = 0; i < nums.size(); i++)` 更简洁
   - 不需要下标时，优先使用范围for

#### 优化思路：

**unordered_map vs unordered_set：**

| 方法 | 数据结构 | 存储内容 | 适用场景 |
|------|----------|---------|---------|
| map | `<key, value>` | 元素和次数 | 需要统计次数 |
| set | `{key}` | 只有元素 | 只需判断存在性 |

**本题只需要判断"是否重复"，不需要知道"重复几次"，所以 set 更合适！**

- ✅ 代码更简洁
- ✅ 语义更清晰
- ✅ 空间略优（不存储value）



---

### 4. 存在重复元素 II（LeetCode 219）

**链接：** https://leetcode.cn/problems/contains-duplicate-ii/

**题目描述：**
给你一个整数数组 nums 和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，满足 nums[i] == nums[j] 且 abs(i - j) <= k。

**示例：**
```
输入：nums = [1,2,3,1], k = 3
输出：true

输入：nums = [1,0,1,1], k = 1
输出：true
```

#### 我的思路：

<details>
<summary>点击展开/收起</summary>

**思路分析：**

**核心思想：** 在"存在重复元素"的基础上，增加了**距离限制**

**解题步骤：**
1. 用哈希表存储 `<元素值, 下标>` 的映射
2. 遍历数组时：
   - 先检查元素是否在哈希表中
   - 如果在，计算当前下标和上次出现下标的距离
   - 如果距离 ≤ k，返回 true
   - 否则，更新哈希表中该元素的下标为当前下标
3. 遍历结束都没找到，返回 false

**为什么要更新下标？**
- 如果同一个元素出现多次，我们只需要比较与**最近一次**的距离
- 例如：`nums = [1, 0, 1, 1], k = 1`
  - i=2: 1出现过（i=0），距离=2 > 1，不满足
  - 更新 hash[1] = 2（保存最新位置）
  - i=3: 1出现过（i=2），距离=1 ≤ 1，满足！✅
- 如果不更新，i=3时会和i=0比较，距离=3，会漏掉答案

**时间复杂度：**
- O(n) - 遍历一次数组
- 哈希表的查找和插入都是 O(1)

**空间复杂度：**
- O(min(n, k)) - 最多存储 k 个不同的元素
- 因为距离超过 k 的元素可以删除（可选优化）

</details>

#### 我的代码：

```cpp
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int, int> hash;  // <元素值, 下标>
        for(int i = 0; i < nums.size(); i++)
        {
            // 检查是否存在 且 距离满足条件
            if(hash.count(nums[i]) && abs(hash[nums[i]] - i) <= k)
                return true;
            // 更新为最新的下标
            hash[nums[i]] = i;
        }
        return false;
    }
};
```

#### 提交结果：

- **是否通过：** ✅ AC
- **用时：** 5分钟
- **调试：** 遇到括号位置bug，成功修复

#### 易错点总结：

1. **abs() 括号位置** ⭐⭐⭐（本次踩坑）
   - ❌ `abs(hash[nums[i]] - i <= k)` - 错误！
     - 先算 `- i <= k` 得到 bool（0或1）
     - 再对 bool 取绝对值
     - 完全不是想要的逻辑！
   - ✅ `abs(hash[nums[i]] - i) <= k` - 正确！
     - 先算差值
     - 再取绝对值
     - 最后判断是否 ≤ k

2. **必须更新下标** ⭐⭐
   - 每次都要执行 `hash[nums[i]] = i`
   - 即使距离不满足也要更新
   - 保证下次比较的是最近的距离

3. **运算符优先级**
   - 比较运算符 `<=` 优先级高于函数调用 `abs()`？
   - 不！但括号会改变计算顺序
   - 务必用括号明确表达意图

#### 优化思路：

**测试用例分析：**
```
输入：nums = [1,2,3,1,2,3], k = 2

手动模拟：
i=0: hash[1]=0
i=1: hash[2]=1
i=2: hash[3]=2
i=3: 1在hash中，|0-3|=3 > 2，不满足，更新 hash[1]=3
i=4: 2在hash中，|1-4|=3 > 2，不满足，更新 hash[2]=4
i=5: 3在hash中，|2-5|=3 > 2，不满足，更新 hash[3]=5

结果：false（所有重复元素距离都>2）
```

**滑动窗口优化（可选）：**
- 可以维护一个大小为 k 的滑动窗口
- 用 set 存储窗口内的元素
- 窗口外的元素可以删除
- 空间复杂度优化到 O(k)

```cpp
// 优化版本（滑动窗口）
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_set<int> window;
        for(int i = 0; i < nums.size(); i++) {
            if(window.count(nums[i])) return true;
            window.insert(nums[i]);
            if(window.size() > k) {
                window.erase(nums[i - k]);  // 移除窗口外的元素
            }
        }
        return false;
    }
};
```



---

### 5. 字母异位词分组（LeetCode 49）⭐⭐

**链接：** https://leetcode.cn/problems/group-anagrams/

**题目描述：**
给你一个字符串数组，请你将字母异位词组合在一起。可以按任意顺序返回结果列表。

字母异位词是由重新排列源单词的所有字母得到的一个新单词。

**示例：**
```
输入: strs = ["eat","tea","tan","ate","nat","bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

#### 我的思路：

<details>
<summary>点击展开/收起</summary>

**思路分析：**

**核心思想：** 字母异位词的特点是排序后完全相同！

**解题步骤：**

1. **识别异位词的关键：排序**
   - "eat" 排序后 → "aet"
   - "tea" 排序后 → "aet"
   - "ate" 排序后 → "aet"
   - 排序后相同的字符串是异位词！

2. **使用哈希表分组**
   - key: 排序后的字符串（用于识别异位词）
   - value: vector<string>，存储所有原字符串
   - 类型：`unordered_map<string, vector<string>>`

3. **构建过程**
   ```
   遍历每个字符串 s:
   ├─ 复制一份并排序，得到 key
   ├─ 将原字符串 s 加入 hash[key]
   └─ 相同 key 的自动归为一组
   ```

4. **提取结果**
   - 遍历哈希表，把每个 value（一组异位词）加入结果数组
   - 只需要 value，不需要 key

**数据结构理解：**
- `vector<string>` - 一组字符串（一维数组）
- `vector<vector<string>>` - 多组字符串（二维数组）
  ```cpp
  [
      ["eat", "tea", "ate"],  // 第一组
      ["tan", "nat"],         // 第二组
      ["bat"]                 // 第三组
  ]
  ```

**时间复杂度：**
- O(n * k * logk) 
  - n 是字符串个数
  - k 是字符串的最大长度
  - 每个字符串排序需要 O(k * logk)

**空间复杂度：**
- O(n * k) - 哈希表存储所有字符串

</details>

#### 我的代码：

```cpp
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 这题较难，hash里面存的是key字符串（排序后），value是字符串组
        unordered_map<string, vector<string>> hash;
        
        for(auto& s : strs)
        {
            string key = s;
            sort(key.begin(), key.end());  // 排序做key值了准备
            hash[key].push_back(s);        // 加入对应的string key值数组中
        }
        
        // 现在提取结果即可，取value然后返回
        vector<vector<string>> ret;
        for(auto& [key, val] : hash)
        {
            ret.push_back(val);  // val就是一组字母异位词
        }
        return ret;
    }
};
```

#### 提交结果：

- **是否通过：** ✅ AC
- **用时：** （经过思考理解后完成）
- **代码质量：** 注释清晰，逻辑正确！

#### 易错点总结：

1. **数据结构选择** ⭐⭐⭐
   - 需要用嵌套的数据结构：`unordered_map<string, vector<string>>`
   - key 是 string（排序后的）
   - value 是 vector<string>（一组原字符串）
   
2. **排序的对象**
   - ❌ 不要直接排序原字符串 `sort(s.begin(), s.end())`
   - ✅ 应该复制一份：`string key = s; sort(key.begin(), key.end());`
   - 否则原字符串会被修改

3. **vector的自动创建**
   ```cpp
   hash[key].push_back(s);
   ```
   - 如果 key 不存在，会自动创建空的 vector
   - 然后 push_back 添加元素
   - 这是 C++ map 的特性

4. **结构化绑定** (C++17)
   ```cpp
   for(auto& [key, val] : hash)
   ```
   - `key` 自动绑定到 pair 的 first
   - `val` 自动绑定到 pair 的 second
   - 比传统的 `it->first` 和 `it->second` 更清晰

#### 优化思路：

**方法对比：**

| 方法 | key的生成方式 | 时间复杂度 | 优点 |
|------|--------------|-----------|------|
| 排序 | sort(s) | O(k logk) | 简单直观 ✅ |
| 计数 | 统计字符频次 | O(k) | 更快 |

**计数优化版本（可选）：**
```cpp
// 用字符计数作为key，更快但代码更复杂
string getKey(string& s) {
    int count[26] = {0};
    for(char c : s) count[c - 'a']++;
    string key = "";
    for(int i = 0; i < 26; i++) {
        if(count[i] > 0) {
            key += string(count[i], 'a' + i);
        }
    }
    return key;
}
```

**本题排序方法已经足够好！** 代码简洁，易于理解。

#### 数据结构补充说明 📦

**vector vs pair 的区别：**

| 数据结构 | 语法 | 参数个数 | 用途 |
|---------|------|---------|------|
| `vector<T>` | 只有一个类型参数 | 1个 | 存储任意数量的 T |
| `pair<T1, T2>` | 有两个类型参数 | 2个 | 只存储2个值 |

**常见组合：**

```cpp
// ✅ 正确的写法
vector<int>                    // int 数组
vector<string>                 // string 数组
vector<vector<int>>            // 二维 int 数组
vector<vector<string>>         // 二维 string 数组 ← 本题用的
pair<int, int>                 // 两个 int
vector<pair<int, int>>         // pair 数组（如坐标）

// ❌ 错误的写法
vector<int, int>               // 不存在！vector只能有1个类型参数
vector<vector<int, int>>       // 不存在！vector<T>中T只能是一个完整类型
```

**本题为什么用 `vector<vector<string>>`？**

因为每组异位词的数量是**不固定**的：
- 第1组可能有3个：`["eat", "tea", "ate"]`
- 第2组可能有2个：`["tan", "nat"]`
- 第3组可能有1个：`["bat"]`

如果用 `pair<string, string>`，只能存2个字符串，无法满足需求！

**形象记忆：**
- `vector<T>` = 盒子，装T类型的东西，可以装任意多个
- `pair<T1, T2>` = 胶囊，左边装T1，右边装T2，固定只能装2个



---

## 今日总结

### 完成情况 ✅
- [x] LeetCode 1 - 两数之和 ⭐
- [x] 面试题 01.02 - 判定是否互为字符重排
- [x] LeetCode 217 - 存在重复元素
- [x] LeetCode 219 - 存在重复元素 II
- [x] LeetCode 49 - 字母异位词分组 ⭐⭐

**完成度：5/5** 🎯 **全部完成！**

### 核心收获

**哈希表的核心思想：**
1. **用空间换时间** - 将查找时间从 O(n) 降到 O(1)
2. **建立映射关系** - 快速找到元素、下标、频次等信息
3. **边遍历边查找** - 不需要先全部插入再查找，效率更高

**哈希表的三大应用：**
1. **判断存在性** - 用 `unordered_set`（去重、检测重复）
2. **统计频次** - 用 `unordered_map<T, int>`（计数）
3. **元素映射** - 用 `unordered_map<T, T>`（建立关系）

**易错点：**
1. **abs() 括号位置** ⭐⭐⭐
   - `abs(a - b <= k)` ❌ 错误的运算顺序
   - `abs(a - b) <= k` ✅ 正确的运算顺序

2. **数组 vs 哈希表比较**
   - 数组不能用 `==` 直接比较，需要逐个元素比较
   - unordered_map 可以直接用 `==` 比较

3. **单引号 vs 变量**
   - `'s[i]'` ❌ 多字符常量
   - `s[i]` ✅ 变量

4. **循环变量笔误**
   - `s[1]` 永远是第二个字符
   - `s[i]` 才是循环中的字符

**技巧总结：**

| 技巧 | 代码模板 | 应用场景 |
|------|---------|---------|
| 边遍历边查找 | `if(hash.count(x)) return; hash.insert(x);` | 两数之和、重复检测 |
| 元素与下标映射 | `hash[nums[i]] = i;` | 需要返回下标 |
| 加减抵消法 | `hash[s1[i]]++; hash[s2[i]]--;` | 判断字符重排 |
| 排序识别 | `sort(s); hash[s].push_back(原);` | 字母异位词 |
| 数组模拟哈希 | `int hash[26] = {0}; hash[ch-'a']++;` | 只有小写字母 |

**容器选择决策树：**
```
需要存储什么？
├─ 只判断存在性 → unordered_set<T>
├─ 需要统计次数 → unordered_map<T, int>
├─ 元素与下标 → unordered_map<T, int>
├─ 元素与元素 → unordered_map<T, T>
└─ 分组（嵌套）→ unordered_map<T, vector<T>>
```

### 进步与亮点 🌟

1. **速度提升明显**
   - 第2题：3分12秒
   - 第3题：1分38秒 ⚡
   - 说明对哈希表越来越熟练！

2. **多种方法尝试**
   - 两数之和：暴力 + 哈希表
   - 字符重排：unordered_map + 数组模拟 + 单数组优化
   - 展现了探索精神和学习能力

3. **调试能力提升**
   - 第4题遇到括号bug，通过测试用例成功定位
   - 能够手动模拟算法过程

4. **代码质量高**
   - 注释清晰，说明理解深入
   - 变量命名规范
   - 逻辑清晰

### 今日踩坑记录 🐛

| 题目 | 错误类型 | 原因 | 解决 |
|------|---------|------|------|
| 字符重排 | 语法错误 | 单引号、数组类型、循环变量 | 仔细检查语法 |
| 重复元素II | 逻辑错误 | abs()括号位置 | 测试用例调试 |
| 字母异位词 | 概念不清 | 嵌套数据结构理解 | 详细演示过程 |

### 待解决问题

**C++语法进阶：**
1. ✅ 结构化绑定 `for(auto& [k, v] : hash)` 已掌握
2. ✅ 范围for循环 `for(auto x : nums)` 已掌握
3. ✅ 二维数组 `vector<vector<T>>` 已理解

---

## 昨日遗留问题（链表）

### 待完成题目：
- [ ] LeetCode 143 - 重排链表（已有思路，待完成合并部分）
- [ ] LeetCode 23 - 合并K个升序链表
- [ ] LeetCode 25 - K个一组翻转链表

### 笔记链接：
详见 `Day18-10.18.md`

---

**学习时间：** 2024年10月19日

**实际用时：** 约2-3小时

**状态：** 🎉 今日目标完成！哈希表专题全部掌握！

