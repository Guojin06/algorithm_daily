# Day36 - 11.5 - 打家劫舍系列

## 📋 今日计划

| 题目 | 难度 | 状态 | 核心知识点 |
|------|------|------|-----------|
| 面试题 17.16 - 按摩师 | 简单 | ✅ AC | 双状态DP、选或不选 |
| LeetCode 198 - 打家劫舍 | 中等 | ✅ AC | 同按摩师 |
| LeetCode 213 - 打家劫舍 II | 中等 | ✅ AC | 环形数组转化 ⭐⭐⭐ |

---

## 1. 面试题 17.16 - 按摩师 ✅

**题目链接**：[LeetCode 面试题 17.16](https://leetcode.cn/problems/the-masseuse-lcci/)

### 题目描述

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。
- 每个预约有一个时长 `nums[i]`（单位：分钟）
- **约束**：如果接受某个预约，就无法接受与之相邻的预约（前一个和后一个都不行）
- **目标**：在不违反约束的情况下，求最大的总预约时长

**示例**：
```
输入：nums = [2,7,9,3,1]
输出：12
解释：选择 7 和 3 和 1，总时长 = 7 + 3 + 1 = 11（错误）
      选择 2 和 9 和 1，总时长 = 2 + 9 + 1 = 12（正确）
```

---

### 从看到题目到写出代码的思维流程 ⭐⭐⭐

#### **Step 1：读题，识别DP类型**

```
题目特征：
✅ 每个预约有"选或不选"的选择
✅ 相邻预约不能同时选（约束条件）
✅ 求最大总时长（最优解）

信号：约束 + 最优 + 选择 → DP！
进一步：每个元素"选或不选" → "选或不选"DP模型
```

#### **Step 2：设计状态定义（关键！）**

**错误思路**：
```cpp
dp[i] = 前i个预约的最大时长

问题：信息不够！
- 不知道第i个是否被选
- 无法判断第i+1能否选择
→ 状态信息不完整！❌
```

**正确思路**：
```cpp
f[i]：前i个预约中，选择第i个的最大时长
g[i]：前i个预约中，不选择第i个的最大时长

优势：
✅ 明确记录"第i个的选择状态"
✅ 后续转移时，能根据约束选择正确的前驱状态
✅ 状态信息完整
```

**关键思维**：
```
状态定义不仅要记录"最优值"
还要记录"达到最优值的方式"（选或不选）

后续转移需要什么信息？
→ 需要知道"前一个是否被选"
→ 所以定义两个状态分别记录
```

#### **Step 3：推导状态转移方程**

**推导f[i]（选择第i个）**：
```
问题1：选第i个，有什么约束？
答：第i-1个不能选（相邻约束）

问题2：那从哪个状态转移？
答：只能从g[i-1]（不选i-1的状态）

问题3：转移方程是什么？
答：f[i] = g[i-1] + nums[i]
          ↑         ↑
       前i-1个     第i个的
       不选i-1     时长
       的最优

验证：✅ 满足约束  ✅ 保证最优
```

**推导g[i]（不选择第i个）**：
```
问题1：不选第i个，有什么约束？
答：没有约束！第i-1个可选可不选

问题2：那从哪个状态转移？
答：可以从f[i-1]或g[i-1]，选最大的

问题3：转移方程是什么？
答：g[i] = max(f[i-1], g[i-1])
          ↑          ↑
       选i-1的    不选i-1的
       最优       最优
       （都合法，取最大）

验证：✅ 满足约束  ✅ 保证最优
```

#### **Step 4：初始化和边界**

```cpp
边界：if(n == 0) return 0;  // 空数组

初始化（i=0）：
f[0] = nums[0];  // 选第0个，得到nums[0]
g[0] = 0;        // 不选第0个，得到0
```

#### **Step 5：填表和返回**

```cpp
填表顺序：从前往后（f[i]和g[i]都依赖i-1）

返回值：max(f[n-1], g[n-1])
       最后一个可选可不选，取最大
```

---

### 核心思路：双状态DP ⭐⭐⭐

这道题是经典的**"选或不选"**模型，关键在于：
```
对于第i个预约，只有两种状态：
1. 选择第i个预约 → f[i]
2. 不选择第i个预约 → g[i]

这两种状态需要分别维护！
因为后续转移需要知道"前一个的选择状态"
```

**为什么需要两个状态？**

```
如果只用一个dp数组：
dp[i] = 前i个预约的最大时长

问题：无法追踪"第i个是否被选择"
- 如果第i个被选择，那么i+1不能选
- 如果第i个没被选择，那么i+1可以选

单状态无法区分这两种情况！
```

**双状态DP定义** ⭐⭐⭐

```cpp
f[i]：前i个预约中，选择第i个预约的最大时长
g[i]：前i个预约中，不选择第i个预约的最大时长
```

**状态转移方程**：

```cpp
1. f[i] = g[i-1] + nums[i]
   含义：选择第i个，那么第i-1个必须不选
   所以从"不选择第i-1个的状态"转移过来
   
2. g[i] = max(f[i-1], g[i-1])
   含义：不选择第i个，那么第i-1个可选可不选
   所以从"第i-1个的两种状态"中选最大值
```

**图示理解**：

```
预约序列：[2, 7, 9, 3, 1]
           ↓  ↓  ↓  ↓  ↓
          i=0 1  2  3  4

i=0时：
f[0] = 2（选择第0个）
g[0] = 0（不选择第0个）

i=1时：
f[1] = g[0] + 7 = 0 + 7 = 7（选择第1个，第0个不能选）
g[1] = max(f[0], g[0]) = max(2, 0) = 2（不选择第1个）

i=2时：
f[2] = g[1] + 9 = 2 + 9 = 11（选择第2个，第1个不能选）
g[2] = max(f[1], g[1]) = max(7, 2) = 7（不选择第2个）

i=3时：
f[3] = g[2] + 3 = 7 + 3 = 10（选择第3个）
g[3] = max(f[2], g[2]) = max(11, 7) = 11（不选择第3个）

i=4时：
f[4] = g[3] + 1 = 11 + 1 = 12（选择第4个）
g[4] = max(f[3], g[3]) = max(10, 11) = 11（不选择第4个）

答案：max(f[4], g[4]) = max(12, 11) = 12
```

---

### AC代码（双状态DP）

```cpp
class Solution {
public:
    int massage(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;  // 边界处理
        
        // 1. 创建两个dp表
        vector<int> f(n);  // f[i]：选择第i个的最大时长
        vector<int> g(n);  // g[i]：不选择第i个的最大时长
        
        // 2. 初始化
        f[0] = nums[0];  // 选择第0个
        g[0] = 0;        // 不选择第0个
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            f[i] = g[i-1] + nums[i];           // 选择i，i-1必须不选
            g[i] = max(f[i-1], g[i-1]);        // 不选择i，i-1可选可不选
        }
        
        // 4. 返回值：第n-1个可选可不选，取最大值
        return max(f[n-1], g[n-1]);
    }
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

### 代码详解 ⭐⭐⭐

**1. 为什么 `g[i] = max(f[i-1], g[i-1])`？**

```
不选择第i个预约，意味着：
- 第i个预约的时长不计入总时长
- 但前i-1个预约可以自由选择

前i-1个预约的状态有两种：
- f[i-1]：选择了第i-1个
- g[i-1]：没选择第i-1个

因为不选择第i个，所以第i-1个没有约束，两种状态都可以！
取两种状态的最大值即可。
```

**2. 为什么 `f[i] = g[i-1] + nums[i]`？**

```
选择第i个预约，意味着：
- 第i个预约的时长要计入总时长（+nums[i]）
- 第i-1个预约必须不能选（相邻约束）

所以只能从"不选择第i-1个"的状态转移：g[i-1]
```

**3. 为什么返回 `max(f[n-1], g[n-1])`？**

```
最后一个预约（第n-1个）也有两种状态：
- 选择：f[n-1]
- 不选择：g[n-1]

两种都是合法的，取最大值即可！
```

---

### 对比：单数组DP写法

**另一种思路**：
```cpp
dp[i]：前i个预约的最大时长（不管第i个是否选择）

状态转移：
dp[i] = max(dp[i-1], dp[i-2] + nums[i])
        ↑          ↑
     不选第i个   选第i个（i-1不能选，从i-2转移）
```

**代码实现**：
```cpp
class Solution {
public:
    int massage(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        
        vector<int> dp(n);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        
        for(int i = 2; i < n; i++) {
            dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
        }
        
        return dp[n-1];
    }
};
```

---

### 两种写法对比 ⭐⭐⭐

| 特性 | 双状态DP（你的代码） | 单数组DP |
|-----|------------------|---------|
| **状态定义** | f[i]选择，g[i]不选择 | dp[i]前i个最大值 |
| **状态转移** | f[i]=g[i-1]+nums[i]<br>g[i]=max(f[i-1],g[i-1]) | dp[i]=max(dp[i-1],dp[i-2]+nums[i]) |
| **初始化** | f[0]=nums[0], g[0]=0 | dp[0]=nums[0], dp[1]=max(nums[0],nums[1]) |
| **空间复杂度** | O(2n) = O(n) | O(n) |
| **思路清晰度** | ✅ 非常清晰，状态明确 | ✅ 简洁，经典 |
| **扩展性** | ✅ 容易扩展到多状态 | 适合基础情况 |

**核心区别**：
```
双状态DP：
- 明确追踪"选"和"不选"两种状态
- 状态转移更符合直觉
- 代码更容易理解和扩展

单数组DP：
- 状态定义更抽象（前i个最大值）
- 需要理解"选第i个就从i-2转移"的技巧
- 代码更简洁
```

---

### 核心知识点总结

**1. "选或不选"DP模型** ⭐⭐⭐

```
适用场景：
- 每个元素有"选"或"不选"两种选择
- 选择之间有约束（如相邻不能同时选）
- 求最优解（最大值/最小值）

核心思想：
- 明确定义每种选择的状态
- 分别维护每种状态的最优解
- 根据约束进行状态转移
```

**2. 双状态DP的优势**

```
相比单数组DP：
✅ 状态定义更清晰（明确"选"和"不选"）
✅ 状态转移更直观（根据约束推导）
✅ 容易扩展到多状态（如打家劫舍III的树形DP）
✅ 不易出错（逻辑清晰）

适用于：
- 学习阶段：理解DP思想
- 复杂问题：多状态、复杂约束
- 面试场景：清晰表达思路
```

**3. 状态转移的推导技巧**

```
Step 1：明确状态定义
f[i]：选择第i个
g[i]：不选择第i个

Step 2：分析约束条件
选择第i个 → 第i-1个不能选

Step 3：推导状态转移
f[i] = g[i-1] + nums[i]（只能从"不选i-1"转移）
g[i] = max(f[i-1], g[i-1])（可以从任意状态转移）

Step 4：确定返回值
max(f[n-1], g[n-1])（最后一个可选可不选）
```

---

### 易错点 ⚠️

**1. 边界条件处理**
```cpp
// ❌ 错误：没有处理空数组
vector<int> f(n);
f[0] = nums[0];  // 如果n=0会越界！

// ✅ 正确：先判断空数组
if(n == 0) return 0;
```

**2. g[0]的初始化**
```cpp
// g[0] = 0 的含义：不选择第0个预约，时长为0
// 这是正确的！
```

**3. 状态转移的方向**
```cpp
// f[i]从g[i-1]转移（不是f[i-1]）
// g[i]从max(f[i-1], g[i-1])转移（两者都可以）
```

---

### 空间优化（滚动变量）⭐⭐⭐

**观察**：`f[i]`和`g[i]`只依赖`f[i-1]`和`g[i-1]`，可以用4个变量优化空间！

```cpp
class Solution {
public:
    int massage(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        
        int f = nums[0], g = 0;  // 当前的f和g
        
        for(int i = 1; i < n; i++) {
            int new_f = g + nums[i];       // 新的f
            int new_g = max(f, g);         // 新的g
            f = new_f;                      // 更新f
            g = new_g;                      // 更新g
        }
        
        return max(f, g);
    }
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(1) ✅

---

---

## 2. LeetCode 213 - 打家劫舍 II ✅

**题目链接**：[LeetCode 213](https://leetcode.cn/problems/house-robber-ii/)

### 题目描述

所有的房屋都**围成一圈**，这意味着第一个房屋和最后一个房屋是紧挨着的。

**约束**：不能同时抢劫相邻的房屋  
**目标**：求能够偷窃到的最高金额

**示例**：
```
输入：nums = [2,3,2]
输出：3

输入：nums = [1,2,3,1]
输出：4
```

---

### 核心思路：环形数组转化为线性数组 ⭐⭐⭐

#### **问题分析**

```
线性数组（打家劫舍I）：
[2, 7, 9, 3, 1]
 0  1  2  3  4
约束：相邻不能同时选
注意：0和4 可以同时选（不相邻）

环形数组（打家劫舍II）：
[2, 7, 9, 3, 1]
 ↑___________↑
 0  1  2  3  4
约束：相邻不能同时选
关键：0和4 不能同时选！（环形相邻）
```

**新增约束**：第0个和第n-1个也不能同时选！

---

#### **核心洞察：枚举第0个房子的选择** ⭐⭐⭐

```
环形约束的本质：第0个和第n-1个不能同时选

枚举第0个的选择：

情况1：选第0个房子
       → 第n-1个就不能选（环形约束）
       → 问题变成：[0, n-2] 范围的线性数组
       
情况2：不选第0个房子
       → 第n-1个可以选（没有环形约束）
       → 问题变成：[1, n-1] 范围的线性数组

情况3：都不选
       → 这种情况的收益 ≤ 情况1或情况2
       → 不用单独考虑

答案 = max(情况1, 情况2)
```

**图示理解**：
```
环形数组：[2, 7, 9, 3, 1]
           0  1  2  3  4

┌─────────────────────────────────┐
│ 枚举第0个的选择                 │
├─────────────────────────────────┤
│                                 │
│  选0 → 不能选4                  │
│  └→ 范围：[0, 1, 2, 3]          │
│     即 [0, n-2]                 │
│     线性数组问题！              │
│                                 │
│  不选0 → 可以选4                │
│  └→ 范围：[1, 2, 3, 4]          │
│     即 [1, n-1]                 │
│     线性数组问题！              │
│                                 │
└─────────────────────────────────┘

答案 = max(rob[0,n-2], rob[1,n-1])
```

---

### AC代码

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        
        // 边界条件
        if(n == 1) return nums[0];
        if(n == 2) return max(nums[0], nums[1]);
        
        // 情况1：偷[0, n-2]（选0，不选n-1）
        int res1 = robRange(nums, 0, n-2);
        
        // 情况2：偷[1, n-1]（不选0，可选n-1）
        int res2 = robRange(nums, 1, n-1);
        
        // 返回两种情况的最大值
        return max(res1, res2);
    }
    
    // 打家劫舍I的逻辑（双状态DP）
    int robRange(vector<int>& nums, int start, int end) {
        if(start > end) return 0;
        if(start == end) return nums[start];
        
        // [start, end]范围的长度
        int len = end - start + 1;  // ← 注意要+1
        
        vector<int> f(len);  // 选第i个
        vector<int> g(len);  // 不选第i个
        
        // 初始化：第一个元素
        f[0] = nums[start];
        g[0] = 0;
        
        // 填表
        for(int i = 1; i < len; i++) {
            // 关键：dp[i] 对应 nums[start+i]
            f[i] = g[i-1] + nums[start + i];
            g[i] = max(f[i-1], g[i-1]);
        }
        
        return max(f[len-1], g[len-1]);
    }
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(n)

---

### 代码详解 ⭐⭐⭐

**1. 为什么 `len = end - start + 1`？**

```
范围 [start, end] 包含的元素个数：

例如：[1, 3]
索引：1, 2, 3
个数：3 - 1 + 1 = 3 ✅

公式：end - start + 1
```

**2. 为什么 `nums[start + i]`？**

```
索引映射：dp数组的索引i 对应 原数组的索引 start+i

假设 robRange(nums, 1, 3)
原数组：nums[0], nums[1], nums[2], nums[3], nums[4]
范围：           ↑[1,   2,    3]↑

dp数组：f[0], f[1], f[2]
对应：  nums[1], nums[2], nums[3]

映射关系：
f[0] ← nums[1] = nums[start + 0]
f[1] ← nums[2] = nums[start + 1]
f[2] ← nums[3] = nums[start + 2]
```

**3. 边界条件为什么这样处理？**

```cpp
if(n == 1) return nums[0];  
// 只有1个房子，没有环形约束，直接返回

if(n == 2) return max(nums[0], nums[1]);
// 只有2个房子，选大的即可
```

---

### 手动验证

```
输入：nums = [2, 3, 2]
             0  1  2

res1 = robRange(nums, 0, 1)  // [2, 3]
     = 打家劫舍I([2, 3])
     = max(2, 3) = 3

res2 = robRange(nums, 1, 2)  // [3, 2]
     = 打家劫舍I([3, 2])
     = max(3, 2) = 3

答案：max(3, 3) = 3 ✅
```

```
输入：nums = [1, 2, 3, 1]
             0  1  2  3

res1 = robRange(nums, 0, 2)  // [1, 2, 3]
     = 打家劫舍I([1, 2, 3])
     = max(1+3, 2) = 4

res2 = robRange(nums, 1, 3)  // [2, 3, 1]
     = 打家劫舍I([2, 3, 1])
     = max(2+1, 3) = 3

答案：max(4, 3) = 4 ✅
```

---

### 核心知识点总结

**1. 环形数组问题的通用解法** ⭐⭐⭐

```
环形数组约束：首尾相邻，不能同时选

解决方法：
Step 1：识别首尾约束（第0个和第n-1个不能同时选）
Step 2：枚举第0个的选择（选或不选）
Step 3：转化为两个线性问题
        - 选0 → [0, n-2]
        - 不选0 → [1, n-1]
Step 4：分别求解，取最大值

关键：环形问题 → 线性问题
```

**2. 问题转化思想**

```
复杂问题 → 简单问题
环形约束 → 枚举边界 → 线性约束

类似问题：
- 环形数组最大和（LeetCode 918）
- 环形房屋涂色（LeetCode 213）
```

**3. 索引映射技巧**

```
处理子数组时的索引映射：

原数组索引：start, start+1, ..., end
dp数组索引：0, 1, ..., len-1

映射关系：dp[i] ← nums[start + i]
```

---

### 易错点 ⚠️

**1. 长度计算错误**
```cpp
// ❌ 错误
int len = end - start;  // 少算1个

// ✅ 正确
int len = end - start + 1;
```

**2. 索引映射错误**
```cpp
// ❌ 错误
f[i] = g[i-1] + nums[i];  // 应该是nums[start+i]

// ✅ 正确
f[i] = g[i-1] + nums[start + i];
```

**3. 边界条件遗漏**
```cpp
// ❌ 错误：没处理n==1和n==2
// 会导致robRange(nums, 0, -1)等非法调用

// ✅ 正确：先处理边界
if(n == 1) return nums[0];
if(n == 2) return max(nums[0], nums[1]);
```

---

## 📚 学习收获

### 今日掌握

1. ✅ **双状态DP模型**
   - "选或不选"的状态定义
   - 两种状态的分别维护
   - 状态转移的推导方法

2. ✅ **打家劫舍系列的核心思想**
   - 相邻元素不能同时选择
   - 状态定义决定转移方程
   - 单数组vs双状态的对比

3. ✅ **环形数组问题转化** ⭐⭐⭐
   - 枚举边界元素的选择
   - 转化为两个线性子问题
   - 索引映射技巧

4. ✅ **空间优化技巧**
   - 从O(n)优化到O(1)
   - 滚动变量的使用

---

### 与之前知识的对比

**与路径DP的区别** ⭐⭐⭐

```
路径DP（Day31-35）：
- 状态：dp[i][j] = 到达(i,j)的最优解
- 转移：从相邻格子转移
- 特点：位置状态明确

打家劫舍DP（Day36）：
- 状态：f[i]选择，g[i]不选择
- 转移：根据"选或不选"的约束
- 特点：选择状态明确
- 进阶：环形数组的问题转化

共同点：
- 都是DP四步法
- 都需要分析状态转移
- 都可以空间优化
```

---

### 核心思维突破

**问题转化思想** ⭐⭐⭐

```
复杂约束 → 简化约束
环形问题 → 线性问题

方法：
1. 识别"多余"的约束（环形 = 首尾相邻）
2. 枚举边界选择（选首或不选首）
3. 消除"多余"约束（转化为线性）
4. 分别求解，合并答案
```

---

### 下一步学习

- ✅ 面试题 17.16 - 按摩师（基础）
- ✅ LeetCode 198 - 打家劫舍（同按摩师）
- ✅ LeetCode 213 - 打家劫舍 II（环形数组）
- ⏳ LeetCode 337 - 打家劫舍 III（树形DP，更复杂）

---

**完成时间**：2025年11月5日  
**状态**：✅ 3/3 题完成  
**核心突破**：环形数组问题转化 ⭐⭐⭐

