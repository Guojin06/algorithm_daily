# Day34 - 11.3 - 二维DP路径问题进阶

## 📅 学习时间
- **日期**：2025-11-03（周日）
- **时长**：预计2-3小时
- **状态**：巩固二维DP虚拟节点技巧

---

## 🎯 今日目标

**核心思路**：
- 巩固Day33的二维DP虚拟节点技巧
- 扩展路径问题：从4方向到8方向
- 掌握多列虚拟节点的应用

**重点方向**：
- [x] 下降路径最小和（LeetCode 931）
- [x] 最小路径和（LeetCode 64）
- [x] 三角形最小路径和（LeetCode 120）- 已学习

---

## 📝 题目记录

### 题目1：下降路径最小和（LeetCode 931）

**题目链接**：
- https://leetcode.cn/problems/minimum-falling-path-sum/

**问题描述**：
- 给定一个 `n x n` 的方形整数矩阵
- 从第一行任何位置开始，每次可以向下移动到下一行的三个位置：
  - 正下方：`[i+1][j]`
  - 左下方：`[i+1][j-1]`
  - 右下方：`[i+1][j+1]`
- 求从第一行到最后一行的最小下降路径和

**核心思路**：
1. **二维DP + 虚拟节点（多列版）** ⭐⭐⭐
2. **状态定义**：`dp[i][j]` 表示到达 `matrix[i-1][j-1]` 的最小路径和
3. **状态转移**：`dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + matrix[i-1][j-1]`
4. **虚拟边界**：
   - 多开一行（上边）：`dp(n+1, ...)`
   - 多开两列（左右）：`dp(..., vector<int>(n+2, INT_MAX))`
   - 虚拟行初始化为0（任意起点）
   - 虚拟列初始化为`INT_MAX`（防止越界）

**代码实现**：
```cpp
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        vector<vector<int>> dp(n+1, vector<int>(n+2, INT_MAX));
        
        // 初始化第一行（虚拟行）
        for(int j = 0; j < n+2; j++) 
            dp[0][j] = 0;

        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= n; j++) {
                // 三个方向：左上、正上、右上
                dp[i][j] = min({dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]}) 
                           + matrix[i-1][j-1];
            }
        }
        
        // 最后一行找最小值
        int ret = INT_MAX;
        for(int j = 1; j <= n; j++)
            ret = min(ret, dp[n][j]);
        
        return ret;
    }
};
```

**关键点**：
1. **多开两列的妙用** ⭐⭐⭐
   - `dp(n+1, vector<int>(n+2, INT_MAX))`
   - 左边虚拟列（j=0）和右边虚拟列（j=n+1）
   - 避免访问`dp[i-1][j+1]`时的越界判断
   
2. **虚拟列初始化为`INT_MAX`**
   - 表示不可达，自然排除边界外的路径
   - 虚拟行初始化为`0`（任意起点）

3. **下标映射**：
   - `dp[i][j]` ↔ `matrix[i-1][j-1]`
   - `dp`的列1到n对应`matrix`的列0到n-1

4. **易错点**：
   - ❌ `min(dp[i-1][j-1], min(dp[i-1][j], dp[i-1][j-1]))`（右上写成左上）
   - ✅ `min(dp[i-1][j-1], min(dp[i-1][j], dp[i-1][j+1]))`

5. **最后一步**：遍历最后一行找最小值（任意终点）

---

### 题目2：最小路径和（LeetCode 64）

**题目链接**：
- https://leetcode.cn/problems/minimum-path-sum/

**问题描述**：
- 给定一个包含非负整数的 `m x n` 网格
- 从左上角开始，每次只能向下或向右移动一步
- 找出一条从左上角到右下角的路径，使得路径上的数字总和最小

**核心思路**：
1. **二维DP + 虚拟节点** ⭐⭐⭐
2. **状态定义**：`dp[i][j]` 表示到达 `grid[i-1][j-1]` 的最小路径和
3. **状态转移**：`dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1]`
4. **虚拟边界**：多开1行1列，初始化为`INT_MAX`
5. **特殊初始化**：`dp[0][1] = dp[1][0] = 0`（确保起点计算正确）

**代码实现**：
```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
        
        // 特殊初始化：为了让dp[1][1]能正确计算
        dp[0][1] = dp[1][0] = 0;
        
        for(int i = 1; i <= m; i++) {
            for(int j = 1; j <= n; j++) {
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];
            }
        }
        
        return dp[m][n];
    }
};
```

**时间复杂度**：O(m*n)  
**空间复杂度**：O(m*n)

**提交结果**：✅ AC

**核心知识点**：
1. **虚拟节点的初始化技巧** ⭐⭐⭐
   ```
   为什么要设置 dp[0][1] = dp[1][0] = 0？
   
   计算dp[1][1]时：
   - dp[1][1] = min(dp[0][1], dp[1][0]) + grid[0][0]
   - 如果dp[0][1]和dp[1][0]都是INT_MAX，会溢出
   - 设置为0，确保起点正确计算
   
   其他位置初始化为INT_MAX：
   - 表示不可达，自然排除边界外的路径
   ```

2. **与Day33礼物最大价值的对比** ⭐⭐⭐
   ```cpp
   // Day33：礼物最大价值（求最大值）
   vector<vector<int>> dp(m+1, vector<int>(n+1, 0));  // 全部初始化为0
   // 不需要特殊设置，因为：
   // dp[1][1] = max(dp[0][1], dp[1][0]) + grid[0][0]
   //          = max(0, 0) + grid[0][0]  ✅ 正确
   
   // Day34：最小路径和（求最小值）
   vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
   dp[0][1] = dp[1][0] = 0;  // 必须特殊设置！
   // 如果不设置：
   // dp[1][1] = min(INT_MAX, INT_MAX) + grid[0][0]  ❌ 溢出
   // 设置后：
   // dp[1][1] = min(0, 0) + grid[0][0]  ✅ 正确
   ```

3. **虚拟节点初始化的通用规律**
   ```
   场景1：求最大值问题（如礼物最大价值）
   - 虚拟节点初始化为0或负无穷
   - 不影响max运算
   
   场景2：求最小值问题（如最小路径和）
   - 虚拟节点初始化为INT_MAX
   - 起点相邻的虚拟节点设为0（防止溢出）
   
   场景3：计数问题（如不同路径）
   - 虚拟节点初始化为0
   - 起点相邻的虚拟节点设为1（提供初始路径）
   ```

4. **为什么设置两个位置为0？**
   ```
   dp[0][1] = 0：为了计算第一行（从上方来）
   dp[1][0] = 0：为了计算第一列（从左方来）
   
   两个都设置，确保dp[1][1]能从两个方向正确计算
   ```

**易错点**：
1. ❌ 只设置`dp[1][0] = 0`或`dp[0][1] = 0`之一
   - 必须同时设置，确保起点计算正确

2. ❌ 不设置任何起点，导致溢出
   ```cpp
   // 错误：全部初始化为INT_MAX，不设置起点
   dp[1][1] = min(INT_MAX, INT_MAX) + grid[0][0];  // 溢出！
   ```

---

### 题目3：三角形最小路径和（LeetCode 120）

**题目链接**：
- https://leetcode.cn/problems/triangle/

**问题描述**：
- 给定一个三角形数组，找出从顶部到底部的最小路径和
- 每一步只能移动到下一行中相邻的结点

**示例**：
```
三角形：
   [2]
  [3,4]
 [6,5,7]
[4,1,8,3]

最小路径：2 → 3 → 5 → 1，和为 11
```

**核心思路**：
1. **两种DP方向** ⭐⭐⭐
   - 方法1：从上往下（需要处理边界）
   - 方法2：从下往上（推荐，代码简洁）
2. **从下往上的优势**：
   - 不需要处理左右边界
   - 答案直接是 `dp[0][0]`
   - 可以空间优化到 O(n)

**方法1：从上往下**

```cpp
// 状态定义：dp[i][j] = 从顶部到达 triangle[i][j] 的最小路径和
// 状态转移：
//   - j == 0: dp[i][j] = dp[i-1][j] + triangle[i][j]（第一列）
//   - j == i: dp[i][j] = dp[i-1][j-1] + triangle[i][j]（最后一列）
//   - 其他: dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]
// 初始化：dp[0][0] = triangle[0][0]
// 答案：min(dp[n-1][0], dp[n-1][1], ..., dp[n-1][n-1])
```

**方法2：从下往上（推荐）⭐**

```cpp
// 状态定义：dp[i][j] = 从 triangle[i][j] 到底部的最小路径和
// 状态转移：dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1])
// 初始化：dp[n-1][j] = triangle[n-1][j]（最后一行）
// 答案：dp[0][0]
// 优势：无需处理边界，代码最简洁！
```

**空间优化版本**：

```cpp
// 用一维数组滚动更新
// 从下往上计算，每次只保留下一行的数据
// 空间复杂度：O(n)
// 更新方向：从左往右（依赖右边的旧值）
```

**提交结果**：✅ AC（用户待完成）

**核心知识点**：
1. **DP方向的选择** ⭐⭐⭐
   ```
   从上往下：
   - 符合直觉（从起点出发）
   - 需要处理复杂边界（第一列、最后一列）
   - 最后需要遍历找最小值
   
   从下往上：
   - 逆向思维（从终点倒推）
   - 无需处理边界（每个位置都有两个方向）
   - 答案直接是起点
   - 代码更简洁！
   ```

2. **不规则网格的处理**
   - 三角形不是矩形，不适合用虚拟节点
   - 方法1：用 `resize` 为每行分配不同空间
   - 方法2：直接复制三角形数组

3. **空间优化的更新方向** ⭐⭐⭐
   ```
   依赖关系：dp[j] 和 dp[j+1]（右边）
   更新方向：从左往右
   原因：保证 dp[j+1] 还是旧值（下一行的值）
   
   通用规律：
   - 依赖右边 → 从左往右更新
   - 依赖左边（需要旧值）→ 从右往左更新
   - 依赖左边（允许新值）→ 从左往右更新
   ```

4. **逆向DP的应用场景**
   - 起点固定，终点多个 → 从上往下或从下往上都可以
   - 起点多个，终点固定 → 从下往上更自然
   - 有复杂边界条件 → 尝试逆向，可能更简洁

**易错点**：
1. ❌ 从上往下时忘记处理边界（第一列、最后一列）
2. ❌ 空间优化时从右往左更新（虽然这题也能过，但逻辑上应该从左往右）
3. ❌ 混淆两种DP定义（从起点到当前 vs 从当前到终点）

---

## ✅ 完成情况

| 题目 | 难度 | 状态 | 一次AC | 备注 |
|------|------|------|--------|------|
| LeetCode 931 - 下降路径最小和 | 中等 | ✅ | ⬜ | 右上方向写错，修正后AC |
| LeetCode 64 - 最小路径和 | 中等 | ✅ | ✅ | 掌握了最小值问题的虚拟节点初始化 |
| LeetCode 120 - 三角形最小路径和 | 中等 | 📝 | - | 学习了逆向DP和空间优化技巧 |

---

## 🎯 核心知识点

**今日收获**：
1. **虚拟节点的扩展应用** ⭐⭐⭐
   - Day33：多开1行1列（4方向：上、左）
   - Day34：多开1行2列（8方向：上、左、右）
   - 原理：用虚拟边界避免越界判断

2. **虚拟边界的初始化策略** ⭐⭐⭐
   ```
   场景1：路径计数（如不同路径）
   - 全部初始化为0
   - dp[1][0] = 1 或 dp[0][1] = 1（提供初始路径）
   
   场景2：求最大值（如礼物最大价值）
   - 全部初始化为0或负无穷
   - 不需要特殊设置起点（max运算天然兼容）
   
   场景3：求最小值-固定起点终点（如最小路径和）
   - 全部初始化为INT_MAX
   - dp[0][1] = dp[1][0] = 0（防止起点计算溢出）
   
   场景4：求最小值-任意起点/终点（如下降路径）
   - 虚拟行初始化为0（任意起点）
   - 虚拟列初始化为INT_MAX（边界外不可达）
   - 最后遍历最后一行找最小值
   ```
   
   **核心规律**：
   - 求最大值问题：初始化为0或负无穷，不易溢出
   - 求最小值问题：初始化为INT_MAX，需特别注意起点溢出问题！

3. **路径方向的扩展**
   - 2方向：上、左（不同路径）
   - 3方向：左上、正上、右上（下降路径）
   - 4方向：上、下、左、右（未来可能遇到）
   - 8方向：所有对角线方向（未来可能遇到）

4. **列索引映射（关键）**
   ```
   dp列：  [0]      [1]     [2]     [3]    ...  [n]     [n+1]
           ↓        ↓       ↓       ↓            ↓        ↓
   意义：  左虚拟  matrix  matrix  matrix     matrix   右虚拟
                   [x][0]  [x][1]  [x][2]     [x][n-1]
   ```

5. **DP方向的选择** ⭐⭐⭐ NEW
   ```
   从上往下（正向DP）：
   - dp[i][j] = 从起点到 (i,j) 的最优解
   - 符合直觉，从已知推未知
   - 可能需要处理复杂边界
   
   从下往上（逆向DP）：
   - dp[i][j] = 从 (i,j) 到终点的最优解
   - 逆向思维，从结果倒推
   - 常常能简化边界处理
   
   选择原则：
   - 哪个方向边界处理更简单，就选哪个
   - 三角形问题：从下往上边界最简单
   - 大多数问题：两种方向都可以，选你理解的
   ```

6. **空间优化的更新方向** ⭐⭐⭐ NEW
   ```
   核心原则：保证依赖的"旧值"不被提前覆盖
   
   判断方法：
   1. 确定状态转移依赖哪些位置
   2. 判断需要旧值还是新值
   3. 选择更新方向，保证依赖值的状态正确
   
   典型场景：
   - 依赖右边（dp[j+1]）→ 从左往右更新
   - 依赖左边且需要旧值（0-1背包）→ 从右往左更新
   - 依赖左边但允许新值（完全背包）→ 从左往右更新
   ```

---

## ⚠️ 易错点记录

1. **方向写错** ❌（LeetCode 931）
   ```cpp
   // ❌ 错误：右上方向写成了左上
   min(dp[i-1][j-1], min(dp[i-1][j], dp[i-1][j-1]))
   
   // ✅ 正确：左上、正上、右上
   min({dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]})
   ```
   **原因**：复制粘贴时疏忽，三个方向应该是j-1、j、j+1

2. **求最小值问题的虚拟节点初始化陷阱** ❌（LeetCode 64）⭐⭐⭐
   ```cpp
   // ❌ 错误：全部初始化为INT_MAX，不设置起点
   vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
   // dp[1][1] = min(INT_MAX, INT_MAX) + grid[0][0];  // 溢出！
   
   // ✅ 正确：必须设置起点相邻的虚拟节点为0
   dp[0][1] = dp[1][0] = 0;
   // dp[1][1] = min(0, 0) + grid[0][0];  // 正确
   ```
   **核心教训**：
   - 求最大值问题（如礼物最大价值）：初始化为0，不会溢出
   - 求最小值问题（如最小路径和）：初始化为INT_MAX，必须特殊处理起点！

3. **虚拟列的初始化**
   - 必须初始化为`INT_MAX`，不能是0
   - 如果是0，边界外的路径会被错误选择

4. **最后一步别忘了**（任意起点/终点问题）
   - 不是直接返回`dp[n][n]`
   - 要遍历最后一行找最小值（任意终点）

5. **DP方向选择错误** ❌（LeetCode 120）
   - 从上往下处理三角形，边界判断复杂
   - 从下往上处理，完全不需要边界判断
   - 教训：遇到复杂边界，尝试逆向思维

6. **空间优化时更新方向错误** ❌
   ```cpp
   // 三角形问题：依赖 dp[j] 和 dp[j+1]
   // ❌ 错误：从右往左更新
   for(int j = i; j >= 0; j--)  // dp[j+1]会先被更新
   
   // ✅ 正确：从左往右更新
   for(int j = 0; j <= i; j++)  // dp[j+1]还是旧值
   ```
   **教训**：分析依赖关系，保证旧值不被提前覆盖

---

## 💡 收获与反思

**学习感悟**：
1. **虚拟节点技巧的全面掌握** ⭐⭐⭐
   - Day33：基础虚拟节点（1行1列）求最大值
   - Day34前半：扩展虚拟节点（1行2列）多方向路径
   - Day34后半：求最小值问题的特殊初始化
   - 理解了虚拟节点的本质：**用空间换简洁，用技巧避免溢出**

2. **初始化策略的深刻理解** ⭐⭐⭐
   - 最大值问题：初始化为0，max运算天然兼容
   - 最小值问题：初始化为INT_MAX，需特别注意起点溢出
   - 这是今天最大的收获！

3. **从错误中学习**
   - 复制粘贴要小心检查
   - 三个方向应该是连续的：j-1、j、j+1
   - 一个小错误导致多个测试用例失败

4. **对比学习的威力**
   - Day33礼物最大价值 vs Day34最小路径和
   - 通过对比，深刻理解了初始化差异的原因
   - 同样的虚拟节点技巧，不同问题需要不同初始化

5. **下标映射越来越熟练**
   - `dp[i][j]` ↔ `matrix[i-1][j-1]`
   - 已经形成肌肉记忆

6. **逆向DP的威力** ⭐⭐⭐
   - 三角形问题：从下往上比从上往下简洁太多
   - 理解了DP方向不是固定的，可以灵活选择
   - 原则：哪个方向边界简单，就选哪个

7. **空间优化的深刻理解** ⭐⭐⭐
   - 不是简单的"把二维变一维"
   - 核心是理解依赖关系，选择正确的更新方向
   - 依赖右边→从左往右，依赖左边→看是否需要旧值
   - 这个理解对未来的背包问题很重要！

---

## 📚 知识体系更新

**DP方法论v1.2 → v1.3（预计）**：
- ✅ 新增：多列虚拟节点的应用
- ✅ 新增：任意起点/终点的路径问题
- ✅ 补充：虚拟边界初始化策略

**技能树更新**：
```
动态规划
└── 二维DP（持续深化）
    ├── 路径问题（规则网格）
    │   ├── 基础路径（2方向）✅
    │   │   ├── 不同路径 II（计数问题）✅
    │   │   ├── 礼物最大价值（最大值问题）✅
    │   │   └── 最小路径和（最小值问题）✅
    │   └── 扩展路径（3方向）✅
    │       └── 下降路径最小和（任意起点/终点）✅
    └── 路径问题（不规则网格）✅ NEW
        └── 三角形最小路径和（逆向DP）📝
```

**虚拟节点技巧完全体**：
```
虚拟节点的两大作用：
1. 避免边界判断（空间换简洁）✅
2. 统一填表逻辑（初始化技巧）✅

初始化策略完全掌握：
- 计数问题：0 + 特殊设置 ✅
- 最大值问题：0或负无穷 ✅
- 最小值问题：INT_MAX + 起点特殊处理 ✅

适用场景：
- 规则网格（矩形）✅ 完美适用
- 不规则网格（三角形）❌ 不适用，用其他方法
```

**DP进阶技巧**：
```
1. DP方向选择 ✅ NEW
   - 从上往下（正向DP）
   - 从下往上（逆向DP）
   - 原则：选择边界处理更简单的方向

2. 空间优化 ✅ NEW
   - 二维压缩到一维
   - 核心：理解依赖关系
   - 选择正确的更新方向（左往右 or 右往左）
```

---

## 🎯 下一步计划

- [x] LeetCode 64 - 最小路径和 ✅
- [ ] LeetCode 120 - 三角形最小路径和（学习完毕，待实战）
- [ ] 继续路径问题或转向其他DP模型

---

## 🏆 成长亮点

- ✅ 掌握了多列虚拟节点技巧（1行2列）
- ✅ 完全理解了虚拟边界初始化策略（4种场景）
- ✅ 从2方向扩展到3方向路径问题
- ✅ 掌握了求最小值问题的特殊初始化技巧 ⭐⭐⭐
- ✅ 通过对比学习（最大值 vs 最小值）深化理解
- ✅ 下标映射已形成肌肉记忆
- ✅ 掌握了逆向DP思想 ⭐⭐⭐ NEW
- ✅ 理解了空间优化的更新方向选择 ⭐⭐⭐ NEW

---

## 📊 今日总结

**完成题目**：2道AC + 1道学习  
- ✅ LeetCode 931 - 下降路径最小和（多列虚拟节点）
- ✅ LeetCode 64 - 最小路径和（最小值初始化技巧）
- 📝 LeetCode 120 - 三角形最小路径和（逆向DP + 空间优化）

**三大核心突破**：
1. **虚拟节点初始化策略完全掌握** ⭐⭐⭐
   - 计数问题、最大值问题、最小值问题的初始化差异
   - 求最小值时的起点溢出陷阱及解决方案
   
2. **逆向DP思想** ⭐⭐⭐
   - 理解了DP方向可以灵活选择（从上往下 or 从下往上）
   - 三角形问题：从下往上比从上往下简洁太多
   - 原则：哪个方向边界处理简单，就选哪个
   
3. **空间优化的更新方向** ⭐⭐⭐
   - 不是简单的"把二维变一维"
   - 核心是理解依赖关系，选择正确的更新方向
   - 依赖右边→从左往右，依赖左边→根据是否需要旧值决定

**今日最大收获**：
- 通过对比学习（最大值 vs 最小值），理解了初始化差异的本质
- 通过三角形问题，体会到逆向DP能极大简化边界处理
- 理解了空间优化的本质，为未来的背包问题打下基础

**知识体系完善**：
- 虚拟节点技巧：从基础应用到完全掌握 ✅
- DP方向选择：从固定思维到灵活运用 ✅
- 空间优化：从概念理解到原理掌握 ✅

**下一步方向**：
- 实战三角形问题（两种方法都要敲）
- 继续深化二维DP，或转向其他DP模型

---

> **今日状态**：二维DP从入门到进阶，三大核心技巧全部掌握！🚀💪🔥

