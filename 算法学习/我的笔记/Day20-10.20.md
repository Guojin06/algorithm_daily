# Day20 - 10.20 字符串专题

## 📚 今日学习内容

**专题**：字符串
**目标题数**：5道以上
**课程来源**：比特课程 - 算法精品课3

---

## 💡 字符串常用技巧

### 1. 双指针
- 对撞指针（两端向中间）
- 快慢指针

### 2. 中心扩散
- 回文串问题的常用方法
- 奇数长度、偶数长度分别处理

### 3. 模拟
- 按题意模拟过程
- 注意进位、借位等细节

### 4. 字符串匹配
- KMP算法
- 简单匹配

---

## 📝 今日题目

### 题目1：LeetCode 14 - 最长公共前缀 (easy)

**题目链接**：https://leetcode.cn/problems/longest-common-prefix/

**题目描述**：
编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

**解题思路**：
采用**两两比较**的方法：
1. 初始化结果为第一个字符串 `ret = strs[0]`
2. 从第二个字符串开始遍历，依次与 `ret` 比较，更新公共前缀
3. 实现辅助函数 `findCommon(s1, s2)`：
   - 用指针 `i` 从0开始，逐位比较两个字符串
   - 只要 `s1[i] == s2[i]` 且不越界就继续
   - 返回 `substr(0, i)`（前i个字符）

**关键点**：
- 循环条件需要同时检查两个字符串的边界，防止越界
- `substr(start, length)` 第二个参数是**长度**，不是结束位置
- 当循环结束时，`i` 指向第一个不匹配的位置，前 `i` 个字符是公共前缀

**我的代码**：
```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string ret = strs[0];  // 初始值为第一个字符串
        for(int i = 1; i < strs.size(); i++) {
            ret = findCommon(ret, strs[i]);
        }
        return ret;
    }
    
    string findCommon(string& s1, string& s2) {
        int i = 0;
        while(i < s1.size() && i < s2.size() && s1[i] == s2[i]) {
            i++;
        }
        return s1.substr(0, i);  // 截取前i个字符返回
    }
};
```

**提交结果**：
- 执行用时：AC
- 内存消耗：
- 通过时间：

**错误记录**：
1. **初始困惑**：不知道如何遍历 `vector<string>`，以及如何记录和更新结果字符串
   - 解决：理解 `strs[i]` 就是 `string` 类型，可以直接操作
   
2. **边界条件缺失**：最初只写了 `s1[i] != s2[i]` 作为循环条件
   - 问题：当两个字符串长度不同时，会导致越界访问
   - 解决：需要同时检查 `i < s1.size() && i < s2.size()`
   
3. **`substr` 参数理解错误**：最初以为第二个参数是结束位置，写成 `substr(0, i-1)`
   - 问题：当 `i=4` 时取了3个字符，实际应该取4个
   - 解决：`substr(start, length)` 第二个参数是长度，应该填 `i`

**总结与反思**：
- 这道题的核心是**边界条件的处理**，必须同时检查两个字符串的长度避免越界
- `substr` 的第二个参数是长度而非结束位置，这是容易混淆的点
- 辅助函数的设计让主逻辑更清晰，符合单一职责原则

**方法二：纵向比较（统一比较法）**
```cpp
string longestCommonPrefix(vector<string>& strs) {
    // 按列比较，需要设置基准比较，且要注意越界问题
    for(int i = 0; i < strs[0].size(); i++) {
        char ch = strs[0][i];  // 设置基准，ch是第0行第i列元素
        for(int j = 1; j < strs.size(); j++) {
            // 条件判断后移，注意越界情况也要讨论
            if(i >= strs[j].size() || strs[j][i] != ch) {  // 超出列边界或列中元素不等于基准
                return strs[0].substr(0, i);
            }
        }
    }
    return strs[0];
}
```

**两种方法对比**：
- 方法一（横向比较）：每次比较两个字符串，逐步缩小公共前缀
- 方法二（纵向比较）：每次检查所有字符串的同一列，发现不同即停止
- 时间复杂度都是 O(m*n)，实际效果相当
- 关键区别：索引理解要清晰，`strs[j][i]` 表示第j个字符串的第i个字符


---

### 题目2：LeetCode 5 - 最长回文子串 (medium)

**题目链接**：https://leetcode.cn/problems/longest-palindromic-substring/

**题目描述**：
给你一个字符串 s，找到 s 中最长的回文子串。

**解题思路**：
采用**中心扩散法**：
1. 回文串具有中心对称的特点，从中心往两边扩散，左右字符相同
2. 关键点：回文串分为**奇数长度**和**偶数长度**两种情况
   - 奇数长度：中心是一个字符，如 "aba" 的中心是 'b'
   - 偶数长度：中心是两个字符之间，如 "abba" 的中心是两个 'b' 之间
3. 对每个位置 i，分别以它为中心进行奇数和偶数两种扩散
4. 扩散过程：left-- 和 right++，只要边界合法且 s[left] == s[right] 就继续
5. 记录起始位置 begin 和最大长度 maxLen，最后用 substr 截取

**关键公式**：
- **长度计算**：`len = right - left - 1`
  - 循环结束时，left 和 right 已经越界或不匹配
  - 真正的回文是 [left+1, right-1]
  - 长度 = (right-1) - (left+1) + 1 = right - left - 1

- **起始位置计算**：`begin = i - (curLen - 1) / 2`
  - i 是中心位置，curLen 是回文长度
  - 向左偏移 (curLen-1)/2 个位置就是起始位置

**我的代码**：
```cpp
class Solution {
public:
    string longestPalindrome(string s) {
        // 中心扩展算法，先定一个值，left，right一个向前移动一个向后移动
        // 注意移动条件以及退出条件，需要记录更新结果
        int n = s.size();
        int begin = 0, maxlen = 1;  // 至少一个元素
        
        for(int i = 0; i < s.size(); i++) {
            // 1. 奇数长度扩散
            int left = i, right = i;
            while(left >= 0 && right < n && s[left] == s[right]) {
                left--;
                right++;
            }
            // 此时left和right已经越界，长度计算为回退一格
            // 即上一次的 right-left+1，回退就是 (right-1)-(left+1)+1 = right-left-1
            int len1 = right - left - 1;
            
            // 2. 偶数长度扩散
            left = i, right = i + 1;
            while(left >= 0 && right < n && s[left] == s[right]) {
                left--;
                right++;
            }
            int len2 = right - left - 1;
            
            // 3. 更新最大值
            int curlen = max(len1, len2);
            if(curlen > maxlen) {
                maxlen = curlen;
                begin = i - (curlen - 1) / 2;  // i减去向下取整得到的left值作为begin
            }
        }
        
        return s.substr(begin, maxlen);
    }
};
```

**提交结果**：
- 执行用时：AC
- 内存消耗：
- 通过时间：

**错误记录**：
1. **初始版本逻辑混乱**：
   - 问题1：只处理了奇数长度，漏掉了偶数长度的情况
   - 问题2：while 循环条件写错，在循环内又用 if 判断边界
   - 问题3：试图用 `max{ret, s.substr(left, right)}` 比较字符串，语法和逻辑都错
   - 问题4：没有理解应该记录起始位置和长度，而不是直接记录字符串
   
2. **核心困惑**：循环结束后指针的位置
   - 最初以为 left 和 right 指向回文的边界
   - 实际上：循环结束时它们已经越界或指向不匹配的位置
   - 真正的回文是 [left+1, right-1]

3. **起始位置计算公式的理解**：
   - `begin = i - (curlen - 1) / 2` 这个公式不是很直观
   - 理解：从中心 i 向左偏移半个长度（向下取整）

**总结与反思**：
- 这道题是**字符串专题的核心题目**，中心扩散法是处理回文串的经典方法
- **关键难点**：
  1. 必须分别处理奇数和偶数两种情况
  2. 理解循环结束后指针的位置（已越界或不匹配）
  3. 长度和起始位置的计算公式要理解透
- **字符串题的通用技巧**：记录起始位置 + 长度，最后统一用 substr 截取
- **时间复杂度**：O(n²)，每个中心扩散最多 O(n)，共 n 个中心
- 这道题理解后要记住模板，很多回文串问题都是这个套路


---

### 题目3：LeetCode 67 - 二进制求和 (easy)

**题目链接**：https://leetcode.cn/problems/add-binary/

**题目描述**：
给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。

**解题思路**：
采用**大数模拟加法**，类似Day18的链表加法（LeetCode 2 - 两数相加）：
1. 从字符串末尾开始遍历（从低位到高位）
2. 维护进位变量 `t`
3. 循环条件：`i >= 0 || j >= 0 || t`（任意一个满足就继续）
4. 每次累加当前位和进位，取模得当前位结果，除法得新进位
5. **关键区别**：
   - 十进制：`t % 10` 和 `t / 10`
   - 二进制：`t % 2` 和 `t / 2`（逢二进一）
6. 字符串是从低位到高位构建的，最后需要 `reverse()` 反转

**核心公式**：
- **字符转数字**：`ch - '0'`
  - 原理：`'5' - '0' = 53 - 48 = 5`（ASCII码相减）
- **数字转字符**：`num + '0'`
  - 原理：`5 + '0' = 5 + 48 = 53 = '5'`（加上ASCII码）
- **当前位结果**：`t % 2`（二进制取模2）
- **新进位**：`t / 2`（二进制除以2）

**我的代码**：
```cpp
class Solution {
public:
    string addBinary(string a, string b) {
        // 跟链表之和类似，都是要处理进位
        // 但链表逆序存储自然顺序正确，字符串需要手动reverse
        // 变量：进位t，遍历变量i,j，储存结果字符串ret
        string ret;
        int i = a.size() - 1, j = b.size() - 1;
        int t = 0;  // 进位
        
        while(i >= 0 || j >= 0 || t) {  // 索引合法或有进位就继续
            if(i >= 0) {
                t += a[i] - '0';  // 字符转数字
                i--;
            }
            if(j >= 0) {
                t += b[j] - '0';
                j--;
            }
            
            ret += (t % 2) + '0';  // 二进制取模2获取数字，转字符加'0'
            t /= 2;                // 二进制进位：除以2
        }
        
        // 字符串反转（从低位到高位构建的，需要反转）
        reverse(ret.begin(), ret.end());
        return ret;
    }
};
```

**提交结果**：
- 执行用时：AC
- 内存消耗：
- 通过时间：

**错误记录**：
1. **初始版本：索引判断错误** ❌
   ```cpp
   while(i || j || t) {  // ❌ 错误！
       if(i) {            // ❌ 错误！
           t += a[i] - '0';
           i--;
       }
   ```
   
   - **问题分析**：当 `i = 0` 时，`if(i)` 判断为 `false`，导致 `a[0]` 没有被处理
   - **测试用例**：`a = "11", b = "1"`
     - 预期结果：`"100"`
     - 实际输出：`"1"`（因为 `a[0]` 和 `b[0]` 都没被处理）
   
   - **根本原因**：混淆了指针判断和整数判断
     - 指针：`nullptr` 是 false，非空指针是 true ✓
     - 整数：`0` 是 false，非0是 true（但索引0是合法的！）❌
   
   - **正确写法**：`if(i >= 0)` 判断索引是否合法

2. **与Day18链表加法的对比**：
   
   | 特点 | Day18链表 | Day20字符串 |
   |------|-----------|------------|
   | 数据类型 | 指针 | 整数索引 |
   | 判断条件 | `if(cur1)` ✓ | `if(i >= 0)` ✓ |
   | 错误写法 | - | `if(i)` ❌ |
   | 原因 | 指针空值是false | 索引0也是合法的 |

**知识点补充：字符与数字转换**

1. **字符转数字**：`ch - '0'`
   ```cpp
   '0' - '0' = 48 - 48 = 0
   '1' - '0' = 49 - 48 = 1
   '5' - '0' = 53 - 48 = 5
   '9' - '0' = 57 - 48 = 9
   ```

2. **数字转字符**：`num + '0'`
   ```cpp
   0 + '0' = 0 + 48 = 48 = '0'
   1 + '0' = 1 + 48 = 49 = '1'
   5 + '0' = 5 + 48 = 53 = '5'
   9 + '0' = 9 + 48 = 57 = '9'
   ```

3. **C++中的布尔转换规则**：
   - **整数**：`0` 是 `false`，其他所有值（包括负数）都是 `true`
   - **指针**：`nullptr` 是 `false`，非空指针都是 `true`
   - **索引判断**：必须用 `i >= 0`，不能用 `if(i)`（因为0是合法索引）

**总结与反思**：
- 这道题是**大数模拟**的经典题目，核心是模拟手工加法过程
- **关键陷阱**：索引判断必须用 `>= 0`，不能像指针那样直接 `if(i)`
- **速记口诀**：
  - 字符变数字：减去 `'0'`
  - 数字变字符：加上 `'0'`
  - 索引判断：`>= 0`
  - 指针判断：直接 `if`
- **与Day18链表加法的联系**：
  - 都是处理进位的加法模拟
  - 链表用指针遍历，字符串用索引遍历
  - 链表自然逆序，字符串需要手动reverse
  - 十进制 `%10, /10` → 二进制 `%2, /2`
- 这道题理解透后，**十进制大数相加、相乘**都是同样的套路


---

### 题目4：LeetCode 43 - 字符串相乘 (medium)

**题目链接**：https://leetcode.cn/problems/multiply-strings/

**题目描述**：
给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

**注意**：
- 不能使用任何内置的大数库
- 不能直接将输入转换为整数（会溢出）

**解题思路**：
采用**大数乘法模拟**，核心是模拟竖式乘法，但采用更优雅的"直接定位法"：

**为什么不能转整数？**
- `int` 最大约21亿（10位）
- `long long` 最大约9×10^18（19位）
- 题目输入可能超过19位，任何内置类型都会溢出

**核心规律**：
1. `m` 位数 × `n` 位数 = 最多 `m + n` 位
2. `num1[i] × num2[j]` 的结果会影响 `ret[i+j]` 和 `ret[i+j+1]` 两个位置

**算法步骤**：
1. 创建长度为 `m + n` 的结果数组 `ret`，初始化为0
2. **无进位相乘**：双层循环，`num1[i] × num2[j]` 直接累加到 `ret[i+j+1]`
3. **统一处理进位**：从右往左遍历，逐位处理进位（`ret[i] = t % 10, t /= 10`）
4. 去除前导0，转为字符串返回

**关键公式**：
- 位置关系：`num1[i] × num2[j]` 累加到 `ret[i+j+1]`
- 进位处理：`ret[i] = t % 10`，`t /= 10`
- 从右往左处理（个位→十位→百位）

**我的代码**：
```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        if(num1 == "0" || num2 == "0") return "0";  // 特殊情况
        
        int m = num1.size(), n = num2.size();
        vector<int> ret(m + n, 0);

        // 步骤1：无进位相乘
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                ret[i+j+1] += (num1[i]-'0') * (num2[j]-'0');  // 累加到对应位置
            }
        }
        
        // 步骤2：统一处理进位
        int t = 0;
        for(int i = ret.size() - 1; i >= 0; i--) {  // 从右往左
            t += ret[i];        // 当前位 + 上一位的进位
            ret[i] = t % 10;    // 保留个位数字
            t /= 10;            // 十位及以上作为进位
        }
        
        // 步骤3：转字符串，跳过前导0
        string result;
        int i = 0;
        while(i < ret.size() && ret[i] == 0) i++;  // 跳过前导0
        
        for(; i < ret.size(); i++) {
            result += ret[i] + '0';  // 数字转字符
        }
        
        return result.empty() ? "0" : result;  // 处理全0情况
    }
};
```

**提交结果**：
- 执行用时：AC
- 内存消耗：
- 通过时间：

**错误记录**：

1. **Bug 1：赋值 vs 累加** ❌
   ```cpp
   // 错误写法
   ret[i+j+1] = (num1[i]-'0') * (num2[j]-'0');  // ❌ 用了 =
   
   // 正确写法
   ret[i+j+1] += (num1[i]-'0') * (num2[j]-'0'); // ✅ 用 +=
   ```
   
   - **问题分析**：同一个位置可能被多次写入
   - **例子**：`num1="12", num2="34"`
     - `i=0,j=1`: `ret[2] = 1*4 = 4`
     - `i=1,j=0`: `ret[2] = 2*3 = 6` 💥 覆盖了之前的4！
     - **应该是**：`ret[2] = 4 + 6 = 10`
   - **教训**：需要累加，不是覆盖

2. **Bug 2：数字转字符的方向错误** ❌
   ```cpp
   // 错误写法
   result += ret[i] - '0';  // ❌ 用了减法
   
   // 正确写法
   result += ret[i] + '0';  // ✅ 用加法
   ```
   
   - **问题分析**：
     - `ret[i] = 5`（数字）
     - `ret[i] - '0' = 5 - 48 = -43` 💥
     - `result += -43` → 访问负数索引，运行时错误！
   - **错误信息**：`runtime error: index -42 out of bounds`
   - **记忆口诀**：
     - 字符→数字：**减** `'0'`（`'5'-'0'=5`）
     - 数字→字符：**加** `'0'`（`5+'0'='5'`）

**知识点补充：`'0'` vs `"0"` 的区别**

这是C++基础但非常容易混淆的知识点：

| 写法 | 类型 | 内存表示 | 使用场景 |
|------|------|----------|----------|
| `'0'` | `char` | 1字节：`[48]` | 字符转换、单字符比较 |
| `"0"` | `string` | 2字节：`['0']['\0']` | 字符串比较、返回值 |

**详细对比**：

1. **字符与数字转换** → 用 `'0'`
   ```cpp
   char ch = '5';
   int num = ch - '0';  // 53 - 48 = 5 ✓
   int wrong = ch - "0"; // ❌ 编译错误！
   ```

2. **字符串比较** → 用 `"0"`
   ```cpp
   string s = "0";
   if(s == "0") { ... }  // ✓ 字符串和字符串比较
   if(s == '0') { ... }  // ❌ 类型不匹配
   ```

3. **单个字符比较** → 用 `'0'`
   ```cpp
   string s = "abc";
   if(s[0] == 'a') { ... }  // ✓ s[0] 是 char 类型
   if(s[0] == "a") { ... }  // ❌ 类型不匹配
   ```

4. **在本题中的应用**：
   ```cpp
   // 字符串比较 → "0"
   if(num1 == "0" || num2 == "0") return "0";
   
   // 字符转数字 → '0'
   ret[i+j+1] += (num1[i] - '0') * (num2[j] - '0');
   
   // 数字转字符 → '0'
   result += ret[i] + '0';
   ```

**快速判断技巧**：看左边的类型
- `string` 类型 → 用 `"0"`
- `char` 类型 → 用 `'0'`
- `s[i]` 返回 `char` → 用 `'0'`

**总结与反思**：
- 这道题是**大数乘法**的经典题目，难度较高但非常重要
- **核心难点**：
  1. 理解位置关系：`num1[i] × num2[j]` 影响 `ret[i+j]` 和 `ret[i+j+1]`
  2. 无进位相乘 + 统一处理进位的思想（避免复杂的竖式模拟）
  3. 从右往左处理进位的必要性（个位进位影响十位）
- **关键陷阱**：
  1. 必须用 `+=` 累加，不能用 `=` 赋值（同一位置多次写入）
  2. 数字转字符用 `+'0'`，不是 `-'0'`（方向容易搞反）
  3. `'0'` 和 `"0"` 的使用场景要明确
- **学习收获**：
  - 大数运算的核心思想：逐位处理 + 进位
  - 这道题掌握后，大数加法、减法、除法都是类似思路
  - 与Day18链表加法、Day20二进制求和形成了"进位处理"系列


---

### 题目5：（补充题目）

**题目链接**：

**题目描述**：


**解题思路**：


**我的代码**：
```cpp

```

**提交结果**：
- 执行用时：
- 内存消耗：
- 通过时间：

**错误记录**：


**总结与反思**：


---

## 📊 今日学习总结

### 完成情况
- [x] 题目1：最长公共前缀 (easy) - AC，掌握横向比较和纵向比较两种方法
- [x] 题目2：最长回文子串 (medium) - AC，掌握中心扩散法（奇数+偶数）
- [x] 题目3：二进制求和 (easy) - AC，理解大数模拟加法，区分指针和索引判断
- [x] 题目4：字符串相乘 (medium) - AC，掌握大数乘法（无进位相乘+统一处理进位）
- **今日完成：4道题**

### 字符串专题核心知识点

#### 1. 中心扩散法
- **适用场景**：回文串问题
- **关键点**：分奇数长度和偶数长度讨论
- **模板**：
```cpp
// 奇数长度
int left = i, right = i;
while(left >= 0 && right < n && s[left] == s[right]) {
    left--;
    right++;
}

// 偶数长度
left = i, right = i + 1;
while(left >= 0 && right < n && s[left] == s[right]) {
    left--;
    right++;
}
```

#### 2. 大数运算模拟
- **关键点**：
  - 从低位到高位处理
  - 注意进位的处理
  - 最后处理最高位的进位

#### 3. 双指针技巧
- **对撞指针**：从两端向中间
- **快慢指针**：一个走得快，一个走得慢

### 今日踩坑记录

1. **索引判断陷阱**（题目3）
   - 错误：`while(i || j || t)` 和 `if(i)`
   - 原因：索引0是合法的，但 `if(0)` 判断为false
   - 正确：`while(i >= 0 || j >= 0 || t)` 和 `if(i >= 0)`
   - **教训**：指针可以直接判断，索引必须用 `>= 0`

2. **累加 vs 赋值**（题目4）
   - 错误：`ret[i+j+1] = num1[i] * num2[j]`
   - 原因：同一位置会被多次写入，用 `=` 会覆盖
   - 正确：`ret[i+j+1] += num1[i] * num2[j]`

3. **字符与数字转换方向**（题目3、4）
   - 字符→数字：`ch - '0'`（减法）
   - 数字→字符：`num + '0'`（加法）
   - 容易搞反！导致负数索引越界

4. **`'0'` vs `"0"` 混淆**（题目4）
   - `'0'`：字符，用于转换和单字符比较
   - `"0"`：字符串，用于字符串比较和返回值
   - 看左边类型快速判断

### 今日收获与感悟

**专题串联**：
- Day18 链表加法（十进制，逢十进一，指针遍历）
- Day20 二进制求和（二进制，逢二进一，索引遍历）
- Day20 字符串相乘（十进制，无进位相乘+统一处理进位）
- **核心思想**：都是模拟手工运算，逐位处理 + 进位传递

**算法模板**：
- **中心扩散法**：回文串问题的标准解法，注意奇数/偶数分开处理
- **大数运算**：数组模拟 + 进位处理，从右往左遍历
- **字符串比较**：横向（两两比较）vs 纵向（统一比较）

**C++基础强化**：
- 字符与数字转换（ASCII码）
- `'0'` vs `"0"` 的类型区别
- 指针判断 vs 索引判断的差异
- `+=` 累加在多次写入场景的重要性

**难度梯度**：
- 题目1、3：相对简单，注重细节
- 题目2：中心扩散法需要理解，但掌握套路后不难
- 题目4：最有难度，需要理解位置关系和分步处理思想

**今日亮点**：
- 第一题主动要求学习第二种方法，学习态度认真 ✨
- 第二题独立完成，注释清晰，说明真正理解了 ✨
- 第四题虽然踩坑，但通过引导成功调试，收获扎实 ✨

### 学习用时
- 总用时：约3-4小时
- 平均每题：45-60分钟

---

## 🔗 相关链接
- [算法精品课3 - 字符串部分](../比特课程/算法精品课3.md#字符串)

