# Day28 - 10.28 递归特训3

> **主题**：验证类问题 + 哈希标记优化
> **核心收获**：N皇后的标记思想可以迁移到其他验证问题

---

## 1. LeetCode 36 - 有效的数独

### 📌 题目信息
- **难度**：Medium
- **标签**：数组、哈希表、矩阵
- **链接**：[LeetCode 36](https://leetcode.com/problems/valid-sudoku/)

---

### 📋 题目描述

判断一个 9×9 的数独是否有效。只需要**根据以下规则，验证已经填入的数字是否有效**即可。

**数独规则**：
1. 数字 `1-9` 在每一**行**只能出现一次
2. 数字 `1-9` 在每一**列**只能出现一次
3. 数字 `1-9` 在每一个以粗实线分隔的 `3×3` 宫内只能出现一次

**注意**：
- 一个有效的数独（部分已被填充）不一定是可解的
- 只需要根据以上规则，验证已经填入的数字是否有效即可
- 空白格用 `'.'` 表示

**示例**：
```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true

输入：board = 
[["8","3",".",".","7",".",".",".","."]  // 第一行第一个是8
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]  // 第四行第一个也是8（同一列冲突）
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：第0列有两个8，冲突
```

---

### 🔑 解题思路

#### **问题类型识别**

这道题和N皇后有本质区别：

| | **N皇后（LeetCode 51）** | **有效的数独（LeetCode 36）** |
|---|---|---|
| **问题类型** | 生成类（回溯） | 验证类（遍历） |
| **需要递归** | ✅ 需要 | ❌ 不需要 |
| **需要恢复现场** | ✅ 需要 | ❌ 不需要 |
| **核心操作** | 试错 + 生成 | 检查 + 标记 |
| **标记数组作用** | 剪枝（避免冲突） | 记录已出现（检测重复） |

**核心思想**：借鉴N皇后的**标记数组思想**，但不需要递归！

---

#### **算法流程**

```
1. 准备三组标记数组：
   - row[9]：记录每行出现过哪些数字
   - col[9]：记录每列出现过哪些数字
   - grid[3][3]：记录每个3×3宫格出现过哪些数字

2. 一次遍历整个棋盘 (i, j)：
   - 如果是空格 '.'，跳过
   - 如果是数字 num：
     a. 检查：row[i]、col[j]、grid[i/3][j/3] 是否已有 num
        → 如果有，返回 false（冲突）
     b. 标记：在三个标记数组中记录 num

3. 遍历结束，返回 true
```

---

#### **关键难点：3×3宫格的定位**

**棋盘坐标 `(i, j)` → 宫格坐标 `(i/3, j/3)`**

```
数独棋盘的9个宫格编号：

       列0-2       列3-5       列6-8
    ┌───────────┬───────────┬───────────┐
行0-2│ grid[0][0]│ grid[0][1]│ grid[0][2]│
    │  左上宫格  │  上中宫格  │  右上宫格  │
    ├───────────┼───────────┼───────────┤
行3-5│ grid[1][0]│ grid[1][1]│ grid[1][2]│
    │  左中宫格  │  中心宫格  │  右中宫格  │
    ├───────────┼───────────┼───────────┤
行6-8│ grid[2][0]│ grid[2][1]│ grid[2][2]│
    │  左下宫格  │  下中宫格  │  右下宫格  │
    └───────────┴───────────┴───────────┘

计算公式：
  宫格行号 = i / 3
  宫格列号 = j / 3

示例：
  棋盘坐标 (0, 0) → grid[0/3][0/3] = grid[0][0] (左上)
  棋盘坐标 (2, 8) → grid[2/3][8/3] = grid[0][2] (右上)
  棋盘坐标 (4, 4) → grid[4/3][4/3] = grid[1][1] (中心)
  棋盘坐标 (8, 0) → grid[8/3][0/3] = grid[2][0] (左下)
```

---

### ❌ 初始错误代码

```cpp
class Solution {
public:
    bool row[9][10];
    bool col[9][10];
    bool grid[3][3][10];
    
    bool isValidSudoku(vector<vector<char>>& board) {
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    
                    // 检查冲突
                    if(row[i][num] || col[j][num] || grid[i/3][j/3][num])
                        return false;
                    
                    // ❌ 错误：标记语句缺少 = true
                    row[i][num] = col[j][num] = grid[i/3][j/3][num];
                    //                                              ↑
                    //                                          没有赋值true！
                }
            }
        }
        return true;
    }
};
```

**错误分析**：

```cpp
row[i][num] = col[j][num] = grid[i/3][j/3][num];
// 相当于：
// 把 grid[i/3][j/3][num] 的值（初始是false）赋给前面三个变量
// 结果：永远都是 false，无法标记

// 正确写法：
row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
//                                                 ↑
//                                              必须有true！
```

**测试用例**：
```
输入：第0列有两个8
board[0][0] = '8'
board[3][0] = '8'

执行过程（错误代码）：
1. 遇到board[0][0]='8'：
   - 检查：col[0][8] == false（初始值）
   - 标记：col[0][8] = false（❌ 没有标记成功）

2. 遇到board[3][0]='8'：
   - 检查：col[0][8] == false（还是false）
   - 没有检测到冲突！❌
   - 返回true（错误）

期望：应该返回false
实际：返回true
```

---

### ✅ 正确代码

#### **方法1：布尔数组（最优解）**

```cpp
class Solution {
public:
    bool row[9][10];      // row[i][num]: 第i行是否出现数字num
    bool col[9][10];      // col[j][num]: 第j列是否出现数字num
    bool grid[3][3][10];  // grid[x][y][num]: 第(x,y)个宫格是否出现数字num
    
    bool isValidSudoku(vector<vector<char>>& board) {
        // 一次遍历整个棋盘
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {  // 跳过空格
                    int num = board[i][j] - '0';  // 字符转数字
                    
                    // 检查是否冲突
                    if(row[i][num] || col[j][num] || grid[i/3][j/3][num])
                        return false;  // 发现冲突，立即返回
                    
                    // 标记：在三个维度记录这个数字出现过
                    row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
                }
            }
        }
        return true;  // 所有格子都检查完，没有冲突
    }
};
```

**时间复杂度**：`O(81) = O(1)`（固定9×9棋盘）
**空间复杂度**：`O(1)`（固定大小的标记数组）

---

#### **方法2：unordered_set（标准哈希表）**

```cpp
class Solution {
public:
    unordered_set<int> row[9];      // 9个集合，记录每行出现的数字
    unordered_set<int> col[9];      // 9个集合，记录每列出现的数字
    unordered_set<int> grid[3][3];  // 3×3=9个集合，记录每个宫格出现的数字
    
    bool isValidSudoku(vector<vector<char>>& board) {
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    
                    // 检查：这个数字在三个集合中是否已存在
                    if(row[i].count(num) || col[j].count(num) || grid[i/3][j/3].count(num))
                        return false;
                    
                    // 插入：把数字加入三个集合
                    row[i].insert(num);
                    col[j].insert(num);
                    grid[i/3][j/3].insert(num);
                }
            }
        }
        return true;
    }
};
```

**优点**：
- 语义清晰：`count` 检查存在性，`insert` 插入元素
- 适用于数字范围很大的场景

**缺点**：
- 哈希表有额外开销（哈希计算、内存分配）
- 速度稍慢于布尔数组

---

#### **方法3：unordered_map（可行但浪费）**

```cpp
class Solution {
public:
    unordered_map<int, bool> row[9];
    unordered_map<int, bool> col[9];
    unordered_map<int, bool> grid[3][3];
    
    bool isValidSudoku(vector<vector<char>>& board) {
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    
                    // 检查键是否存在
                    if(row[i].count(num) || col[j].count(num) || grid[i/3][j/3].count(num))
                        return false;
                    
                    // 插入键值对
                    row[i][num] = true;
                    col[j][num] = true;
                    grid[i/3][j/3][num] = true;
                }
            }
        }
        return true;
    }
};
```

**缺点**：
- 存储键值对，比 `set` 多存一个 `bool` 值（冗余）
- 内存占用更大

---

### 📊 三种方法对比

| 方法 | 数据结构 | 检查存在 | 标记 | 适用场景 |
|---|---|---|---|---|
| **bool数组** | `bool row[9][10]` | `row[i][num]` | `row[i][num] = true` | ✅ 数字范围小（1-9） |
| **unordered_set** | `unordered_set<int> row[9]` | `row[i].count(num)` | `row[i].insert(num)` | 数字范围大、语义清晰 |
| **unordered_map** | `unordered_map<int, bool> row[9]` | `row[i].count(num)` | `row[i][num] = true` | ⚠️ 可行但浪费内存 |

**等价关系**：
```cpp
// 检查数字5是否在第0行出现过
row[0][5]           // bool数组
row[0].count(5)     // unordered_set
row[0].count(5)     // unordered_map

// 标记数字5在第0行出现过
row[0][5] = true    // bool数组
row[0].insert(5)    // unordered_set
row[0][5] = true    // unordered_map
```

**推荐**：本题用**布尔数组**最优（速度快、内存小）

---

### 🔬 核心知识点

#### **1. 数据结构深度对比**

##### **`unordered_set<int> row[9]` 的本质**

```cpp
unordered_set<int> row[9];
//                  ↑
//               这是数组，有9个元素
//  ↑
//  每个元素是一个集合

// 可视化：
row[0] → {5, 3, 7}        // 第0行出现过5, 3, 7
row[1] → {6, 1, 9}        // 第1行出现过6, 1, 9
row[2] → {9, 8}           // 第2行出现过9, 8
...
row[8] → {2, 4}           // 第8行出现过2, 4
```

**类比**：
- `row[i]` = 第i行的"签到表"（集合）
- `row[i].insert(num)` = 数字num在第i行"签到"
- `row[i].count(num)` = 查询数字num是否签到过

##### **`unordered_set<int> grid[3][3]` 的本质**

```cpp
unordered_set<int> grid[3][3];
//                      ↑  ↑
//                      3行3列
//  ↑
//  每个元素是一个集合

// 可视化：3×3=9个抽屉
       列0          列1          列2
    ┌──────────┬──────────┬──────────┐
行0 │grid[0][0]│grid[0][1]│grid[0][2]│
    │{5,3,6,9} │  {7,1}   │   {8}    │
    ├──────────┼──────────┼──────────┤
行1 │grid[1][0]│grid[1][1]│grid[1][2]│
    │  {4,8}   │ {6,3,2}  │   {}     │
    ├──────────┼──────────┼──────────┤
行2 │grid[2][0]│grid[2][1]│grid[2][2]│
    │   {}     │   {}     │  {7,9}   │
    └──────────┴──────────┴──────────┘

对应数独的9个宫格：
grid[0][0] = 左上宫格
grid[0][1] = 上中宫格
grid[0][2] = 右上宫格
grid[1][0] = 左中宫格
grid[1][1] = 中心宫格
grid[1][2] = 右中宫格
grid[2][0] = 左下宫格
grid[2][1] = 下中宫格
grid[2][2] = 右下宫格
```

**访问方式**：
```cpp
// 棋盘坐标 (i, j) → 宫格坐标 (i/3, j/3)
grid[i/3][j/3].insert(num);       // 插入
if(grid[i/3][j/3].count(num))     // 检查
```

---

#### **2. unordered_set vs unordered_map**

| 特性 | `unordered_set<T>` | `unordered_map<K, V>` |
|---|---|---|
| **存储内容** | 只存值 | 存键值对 |
| **模板参数** | 1个 | 2个 |
| **插入** | `s.insert(value)` | `m[key] = value` |
| **检查存在** | `s.count(value)` | `m.count(key)` |
| **访问元素** | ❌ 不支持 | ✅ `m[key]` |
| **本题** | ✅ 合适（只需检查存在） | ⚠️ 可行但浪费 |

**使用场景**：
- **set**：只需要知道"是否存在"（去重、检查出现）
- **map**：需要"值 → 对应信息"（计数、索引映射）

**示例**：
```cpp
// set：只关心"是否存在"
unordered_set<int> appeared;
appeared.insert(5);
if(appeared.count(5)) cout << "5出现过";

// map：需要"值 → 对应信息"
unordered_map<int, int> freq;
freq[5] = 3;  // 数字5出现了3次
cout << freq[5];  // 输出3

unordered_map<char, string> charToStr;
charToStr['2'] = "abc";  // '2' → "abc"
cout << charToStr['2'];  // 输出"abc"
```

---

#### **3. 为什么 `bool row[9][10]` 第二维是 `[10]`？**

```cpp
bool row[9][10];
//         ↑
//      数字范围1-9，为什么开10个？

int num = board[i][j] - '0';  // num可能是1-9
row[i][num] = true;           // 直接用num作为索引
//      ↑ num=9时，需要访问row[i][9]，所以至少要[10]
```

**原因**：
- 数独中数字是 `1-9`
- 数组索引从 `0` 开始
- 为了让 `num` 直接作为索引（`row[i][num]`），需要开 `[10]`
- 虽然 `row[i][0]` 不会用到，但这样更简洁（不用 `num-1`）

**对比**：
```cpp
// 方式1：开[10]，直接用num（推荐）
bool row[9][10];
row[i][num] = true;  // num=5时，用row[i][5]

// 方式2：开[9]，需要num-1
bool row[9][9];
row[i][num-1] = true;  // num=5时，用row[i][4]
```

---

#### **4. 为什么 `grid[3][3][10]` 是三维？**

```cpp
bool grid[3][3][10];
//        ↑  ↑   ↑
//        宫格行 宫格列 数字

// 第1维[3]：宫格的行号（0-2，共3行宫格）
// 第2维[3]：宫格的列号（0-2，共3列宫格）
// 第3维[10]：数字0-9
```

**需求**：
- 有 `3×3 = 9` 个宫格
- 每个宫格要记录数字 `1-9` 是否出现

**为什么不用 `grid[9][10]`？**
```cpp
// 方案1：grid[3][3][10]（实际采用）
grid[i/3][j/3][num] = true;  // 直接用除法定位

// 方案2：grid[9][10]（也可以，但多一步计算）
int gridIndex = (i/3) * 3 + (j/3);
grid[gridIndex][num] = true;
```

**结论**：`grid[3][3][10]` 更直观（直接用 `i/3` 和 `j/3`）

---

#### **5. 字符转数字：`board[i][j] - '0'`**

```cpp
char c = '5';
int num = c - '0';  // num = 5

// 原理：
'0' 的ASCII码是 48
'5' 的ASCII码是 53
'5' - '0' = 53 - 48 = 5
```

---

### 🎯 与N皇后的对比

| | **N皇后（LeetCode 51）** | **有效的数独（LeetCode 36）** |
|---|---|---|
| **问题类型** | 生成类（回溯） | 验证类（遍历） |
| **核心算法** | DFS + 回溯 | 一次遍历 + 哈希检查 |
| **需要递归** | ✅ 需要 | ❌ 不需要 |
| **需要恢复现场** | ✅ 需要 | ❌ 不需要 |
| **标记数组** | `col`, `diag1`, `diag2` | `row`, `col`, `grid` |
| **标记作用** | 剪枝（避免冲突） | 检测重复 |
| **核心技巧** | 对角线映射 `row±col` | 宫格映射 `i/3, j/3` |
| **返回值** | `void`（收集所有解） | `bool`（是否有效） |

**共同点**：
1. 都用**标记数组**避免重复检查
2. 都需要**数学映射**（对角线/宫格定位）
3. 都是**空间换时间**的优化思想

**理解关键**：
> N皇后学会了"标记数组"的思想 → 有效数独直接复用，难度大降！

---

### 💡 核心总结

#### **算法思想**
1. **哈希标记**：用标记数组记录"已出现"，O(1)检测重复
2. **数学映射**：`(i, j) → (i/3, j/3)` 定位宫格
3. **三维检查**：行、列、宫格三个维度同时检查

#### **数据结构选择**
- **数字范围小（1-9）** → `bool数组`（最优）
- **数字范围大** → `unordered_set`（灵活）
- **需要对应信息** → `unordered_map`（功能强）

#### **关键代码**
```cpp
// 核心逻辑
if(row[i][num] || col[j][num] || grid[i/3][j/3][num])
    return false;  // 检查：三个维度任一重复 → 冲突

row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;  // 标记：记录出现过
```

#### **易错点**
1. ❌ 标记语句漏写 `= true`
2. ❌ 宫格定位错误（忘记 `/3`）
3. ❌ 混淆 `unordered_set` 和 `unordered_map`

---

### 🎓 学习心得

> **"理解了N皇后的标记思想后，有效数独从Medium降为Easy！"**

**关键迁移**：
- N皇后：`col[j]`, `diag1[row-col+n]`, `diag2[row+col]`
- 有效数独：`row[i][num]`, `col[j][num]`, `grid[i/3][j/3][num]`

**本质**：都是用**数学映射**将二维位置转换为一维索引，实现O(1)冲突检查！

---

**提交时间**：2025-10-28
**状态**：✅ AC
**用时**：一次通过（理解标记思想后）

---

## 2. LeetCode 37 - 解数独

### 📌 题目信息
- **难度**：Hard ⚠️
- **标签**：数组、哈希表、回溯、矩阵
- **链接**：[LeetCode 37](https://leetcode.com/problems/sudoku-solver/)

---

### 📋 题目描述

编写一个程序，通过填充空格来解决数独问题。

**数独规则**：
1. 数字 `1-9` 在每一**行**只能出现一次
2. 数字 `1-9` 在每一**列**只能出现一次
3. 数字 `1-9` 在每一个以粗实线分隔的 `3×3` 宫内只能出现一次

**要求**：
- 空白格用 `'.'` 表示
- 你可以假设给定的数独只有唯一解
- 给定数独**永远是 9×9 形式**

**示例**：
```
输入：
board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

输出：
[["5","3","4","6","7","8","9","1","2"]
,["6","7","2","1","9","5","3","4","8"]
,["1","9","8","3","4","2","5","6","7"]
,["8","5","9","7","6","1","4","2","3"]
,["4","2","6","8","5","3","7","9","1"]
,["7","1","3","9","2","4","8","5","6"]
,["9","6","1","5","3","7","2","8","4"]
,["2","8","7","4","1","9","6","3","5"]
,["3","4","5","2","8","6","1","7","9"]]
```

---

### 🔑 解题思路

#### **问题类型识别**

根据**递归方法论体系**：

| 类型 | 集合来源 | check数组 | index参数 | for循环 | 递归参数 |
|---|---|---|---|---|---|
| **多约束排列** | 二维空间 | ✅ 需要多个 | ✅ 需要(pos) | 需要 (i=1~9) | pos+1 |

**解数独 = 多约束排列型回溯**（类似N皇后）
- 在9×9的**二维空间**中填数
- 需要**三个check数组**：`row`、`col`、`grid`
- 需要**位置参数pos**：当前填到第几个格子
- 每个空格有**9种选择**（1-9），需要`for`循环

---

#### **与有效数独的对比**

| | **有效数独（LeetCode 36）** | **解数独（LeetCode 37）** |
|---|---|---|
| **问题类型** | ✅ 验证类（遍历） | ✅ 生成类（回溯） |
| **目标** | 检查已填数字是否有效 | 填充所有空格 |
| **是否需要递归** | ❌ 不需要 | ✅ 需要（DFS） |
| **是否需要check数组** | ✅ 需要（检测重复） | ✅ 需要（剪枝） |
| **是否需要恢复现场** | ❌ 不需要 | ✅ 需要 |
| **标记数组作用** | 记录"已出现" | 检查"能否填" |
| **复杂度** | O(81) | O(9^m)，m是空格数 |
| **类比** | 监考老师检查答卷 | 学生做填空题（试错） |

**关键区别**：
- **有效数独**：只看不动，检查是否合法
- **解数独**：要填空格，试错+回溯

---

#### **算法流程**

```
1. 初始化标记数组：
   - row[9][10]：记录每行使用的数字
   - col[9][10]：记录每列使用的数字
   - grid[3][3][10]：记录每个3×3宫格使用的数字

2. 遍历棋盘，标记已填的数字：
   - 跳过空格 '.'
   - 将已填数字标记到三个数组中

3. 从第0个格子开始DFS：
   - 如果pos >= 81，所有格子都填完了，返回true
   - 计算坐标：i = pos/9, j = pos%9
   - 如果当前格子已填，跳过（递归下一个）
   - 如果当前格子是空格：
     a. 尝试填1-9
     b. 剪枝：检查三个维度是否冲突
     c. 如果不冲突：
        - 做选择：填入数字，标记
        - 递归：填下一个格子
        - 如果递归返回true，找到解了，返回true
        - 否则恢复现场，尝试下一个数字
     d. 所有数字都试过了，返回false

4. 题目保证有唯一解，DFS会找到答案
```

---

#### **关键技巧**

##### **1. 二维坐标 ↔ 一维编号**

```cpp
// 为什么用一维编号pos？
// 因为要按顺序填格子（从左到右、从上到下）

// 转换公式：
pos = i * 9 + j;    // (i, j) → pos

i = pos / 9;         // pos → i（行号）
j = pos % 9;         // pos → j（列号）

// 示例：
(0, 0) → pos = 0
(0, 8) → pos = 8
(1, 0) → pos = 9   // 9/9=1, 9%9=0
(8, 8) → pos = 80  // 80/9=8, 80%9=8
```

---

##### **2. 返回值bool vs void**

| 问题类型 | 返回值 | 原因 |
|---|---|---|
| 全排列、子集 | `void` | 需要收集**所有解** |
| N皇后 I | `void` | 需要收集**所有解** |
| N皇后 II | `void` | 只统计数量，不中断搜索 |
| **解数独** | `bool` | 只需**一个解**，找到就返回 ⭐ |

```cpp
// N皇后：收集所有解
void dfs(int row) {
    if(row == n) {
        ret.push_back(board);  // 收集解
        return;  // 继续搜索其他解
    }
    // ...
}

// 解数独：找到一个解就返回
bool dfs(int pos) {
    if(pos >= 81) {
        return true;  // 找到解，立即返回
    }
    // ...
    if(dfs(pos + 1)) {
        return true;  // 找到解，向上传递 ⭐
    }
    // ...
}
```

**关键**：
- `if(dfs(pos+1))` 检查递归是否成功
- 如果成功，立即 `return true` 向上传递
- 如果失败，继续尝试其他数字

---

##### **3. 标记数组的复用**

| | **有效数独** | **解数独** |
|---|---|---|
| **初始化** | 边遍历边标记 | 先遍历一次标记已填数字 |
| **检查** | `if(row[i][num])` 检测冲突 | `if(!row[i][num])` 检查能否填 |
| **标记** | 只标记不恢复 | 标记 + 恢复（回溯） |

```cpp
// 有效数独：只标记，不恢复
row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;

// 解数独：标记 + 恢复
// 标记
row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
// ... 递归 ...
// 恢复
row[i][num] = col[j][num] = grid[i/3][j/3][num] = false;
```

---

### ❌ 初始错误代码

```cpp
class Solution {
public:
    bool row[9][10];
    bool col[9][10];
    bool grid[3][3][10];
    
    void solveSudoku(vector<vector<char>>& board) {
        memset(row, false, sizeof(row));
        memset(col, false, sizeof(col));
        memset(grid, false, sizeof(grid));
        
        // ❌ 错误1：初始化循环条件
        for(int i = 9; i < 9; i++)  // ← i=9永远不满足i<9！
        {
            for(int j = 0; j < 9; j++)
            {
                // ❌ 错误2：空格判断
                if(board[i][j] != '0')  // ← 空格是'.'，不是'0'
                {
                    int num = board[i][j] - '0';
                    
                    // ❌ 错误6：if语句缺少大括号
                    if(row[i][num] || col[j][num] || grid[i/3][j/3][num])
                    //标记
                    row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
                    // ↑ 这行永远执行！
                }
            }
        }
        
        int pos = 0;
        dfs(board, pos);       
    }
    
    bool dfs(vector<vector<char>>& board, int pos)
    {
        if(pos >= 81)
        {
            return true;
        }
        
        // ❌ 错误3：坐标计算（致命！）
        int i = pos/i;  // ← 除以自己？应该除以9
        int j = pos/j;  // ← 除法？应该取模%

        // ❌ 错误4：赋值 vs 比较
        if(board[i][j] = '.')  // ← 这是赋值！不是比较
        {
            return dfs(board, pos+1);
        }
        
        for(int num = 1; num <= 9; num++)
        {
            // ❌ 错误5：grid数组缺少维度
            if(!row[i][num] && !col[j][num] && !grid[i/3][j/3])  // ← 缺少[num]
            {
                board[i][j] = '0' + num;
                row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;

                if(dfs(board, pos+1))
                {
                    return true;
                }

                board[i][j] = '.';
                row[i][num] = col[j][num] = grid[i/3][j/3][num] = false;
            }
        }
        
        return false;
    }
};
```

---

### ✅ 正确代码

```cpp
class Solution {
public:
    bool row[9][10];
    bool col[9][10];
    bool grid[3][3][10];
    
    void solveSudoku(vector<vector<char>>& board) {
        // 初始化标记数组
        memset(row, false, sizeof(row));
        memset(col, false, sizeof(col));
        memset(grid, false, sizeof(grid));
        
        // ✅ 遍历棋盘，标记已填的数字
        for(int i = 0; i < 9; i++) {  // ✅ 从0开始
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {  // ✅ 空格是'.'
                    int num = board[i][j] - '0';
                    // ✅ 题目保证初始无冲突，直接标记
                    row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
                }
            }
        }
        
        dfs(board, 0);  // 从第0个格子开始
    }
    
    bool dfs(vector<vector<char>>& board, int pos) {
        // 1. 递归出口
        if(pos >= 81) {
            return true;  // 所有格子都填完了
        }
        
        // 2. ✅ 计算当前格子的坐标
        int i = pos / 9;  // ✅ 行号 = pos除以9
        int j = pos % 9;  // ✅ 列号 = pos对9取模
        
        // 3. ✅ 如果当前格子已填，跳过
        if(board[i][j] != '.') {  // ✅ != 比较，不是 = 赋值
            return dfs(board, pos + 1);
        }
        
        // 4. 当前格子是空格，尝试填1-9
        for(int num = 1; num <= 9; num++) {
            // ✅ 剪枝：检查三个维度
            if(!row[i][num] && !col[j][num] && !grid[i/3][j/3][num]) {  // ✅ 加上[num]
                // 做选择
                board[i][j] = '0' + num;
                row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
                
                // 递归：填下一个格子
                if(dfs(board, pos + 1)) {
                    return true;  // 找到解了，立即返回
                }
                
                // 恢复现场（回溯）
                board[i][j] = '.';
                row[i][num] = col[j][num] = grid[i/3][j/3][num] = false;
            }
        }
        
        // 所有数字都试过了，无解
        return false;
    }
};
```

**时间复杂度**：`O(9^m)`，m是空格数（最坏情况每格试9个数字）
**空间复杂度**：`O(1)`（固定大小的标记数组 + 递归栈O(81)）

**实际运行**：由于剪枝有效，远小于理论复杂度

---

### 🔬 核心知识点

#### **1. 为什么需要pos参数？**

这是一个很好的问题！让我们对比三种情况：

| 问题类型 | **位置参数** | **check数组** | **for循环** | **原因** |
|---|---|---|---|---|
| **全排列（LeetCode 46）** | ❌ 不需要pos | ✅ 需要 | `i=0~n` | 每次都从**所有元素**中选 |
| **N皇后（LeetCode 51）** | ✅ 需要row | ✅ 需要多个 | `c=0~n` | **逐行**填，知道填到第几行 |
| **解数独（LeetCode 37）** | ✅ 需要pos | ✅ 需要多个 | `num=1~9` | **逐格**填，知道填到第几格 |

---

##### **全排列：不需要pos**

```cpp
// 全排列：每次都从所有元素中选一个没用过的
void dfs() {  // ❌ 不需要pos参数
    if(path.size() == n) {
        ret.push_back(path);
        return;
    }
    
    for(int i = 0; i < n; i++) {  // 每次遍历所有元素
        if(!check[i]) {  // 只看有没有用过
            path.push_back(nums[i]);
            check[i] = true;
            dfs();  // ← 不需要传位置
            path.pop_back();
            check[i] = false;
        }
    }
}
```

**为什么不需要pos？**
- 选择是**无序的**：每次都从所有元素中选一个没用过的
- check数组已经记录了"哪些用过"
- 不需要知道"填到哪个位置了"

**决策树**（n=3）：
```
[]
├─ 选0 → [0]
│   ├─ 选1 → [0,1]
│   │   └─ 选2 → [0,1,2] ✅
│   └─ 选2 → [0,2]
│       └─ 选1 → [0,2,1] ✅
├─ 选1 → [1]
...
每一步都是从"剩余的"中选
```

---

##### **N皇后：需要row（行号）**

```cpp
// N皇后：逐行填，知道当前是第几行
void dfs(int row) {  // ✅ 需要row参数
    if(row == n) {
        ret.push_back(board);
        return;
    }
    
    for(int c = 0; c < n; c++) {  // 当前行，遍历所有列
        if(!col[c] && !diag1[row-c+n] && !diag2[row+c]) {
            board[row][c] = 'Q';
            // 标记...
            dfs(row + 1);  // ← 填下一行
            // 恢复...
        }
    }
}
```

**为什么需要row？**
- 选择是**有序的**：第0行→第1行→...→第n-1行
- 每行必须恰好放1个皇后
- row告诉我们"当前在第几行"

**决策树**（n=4）：
```
row=0
├─ 放(0,0) → row=1
│   ├─ 放(1,2) → row=2
│   │   └─ 放(2,1) → row=3
│   │       └─ ...
...
逐行推进，row记录进度
```

---

##### **解数独：需要pos（格子编号）**

```cpp
// 解数独：逐格填，知道当前是第几个格子
bool dfs(int pos) {  // ✅ 需要pos参数
    if(pos >= 81) {
        return true;
    }
    
    int i = pos / 9;
    int j = pos % 9;
    
    if(board[i][j] != '.') {
        return dfs(pos + 1);  // 跳过已填的
    }
    
    for(int num = 1; num <= 9; num++) {  // 尝试填1-9
        if(!row[i][num] && !col[j][num] && !grid[i/3][j/3][num]) {
            // 填num...
            if(dfs(pos + 1)) return true;  // ← 填下一个格子
            // 恢复...
        }
    }
    return false;
}
```

**为什么需要pos？**
- 选择是**有序的**：格子0→格子1→...→格子80（从左到右、从上到下）
- 每个空格都要填
- pos告诉我们"当前填到第几个格子"

**决策树**（简化）：
```
pos=0: (0,0)='5' → 跳过 → pos=1
pos=1: (0,1)='3' → 跳过 → pos=2
pos=2: (0,2)='.' → 尝试1-9
  ├─ 填1 → pos=3
  │   └─ ...
  ├─ 填2 → pos=3
  ...
逐格推进，pos记录进度
```

---

##### **核心区别总结**

```
全排列：
  选择空间 = 所有未用元素（check数组控制）
  不需要位置参数（选择无序）
  
  示例：从[1,2,3]中选
    第1步：选2 → [2]
    第2步：从[1,3]中选1 → [2,1]
    第3步：从[3]中选3 → [2,1,3]
    ↑ 每次都从"剩余的"中选

N皇后：
  选择空间 = 当前行的所有列（row参数控制当前行）
  需要row参数（逐行推进）
  
  示例：4×4棋盘
    row=0：在第0行选一列 → (0,1)
    row=1：在第1行选一列 → (1,3)
    row=2：在第2行选一列 → (2,0)
    row=3：在第3行选一列 → (3,2)
    ↑ 必须按行顺序填

解数独：
  选择空间 = 当前格子的1-9（pos参数控制当前格子）
  需要pos参数（逐格推进）
  
  示例：9×9棋盘（81个格子）
    pos=0：(0,0) 已填5，跳过
    pos=1：(0,1) 已填3，跳过
    pos=2：(0,2) 是空格，尝试1-9
    pos=3：(0,3) 是空格，尝试1-9
    ...
    ↑ 必须按格子顺序填
```

**判断标准**：
- 如果是**从所有元素中选**，不需要位置参数（全排列、子集）
- 如果是**按固定顺序填**，需要位置参数（N皇后、解数独）

---

#### **2. 六大常见错误**

| 错误类型 | 错误代码 | 正确代码 |
|---|---|---|
| **1. 循环初始化** | `for(int i=9; i<9; i++)` | `for(int i=0; i<9; i++)` |
| **2. 空格判断** | `board[i][j] != '0'` | `board[i][j] != '.'` |
| **3. 坐标计算** | `i=pos/i; j=pos/j;` | `i=pos/9; j=pos%9;` |
| **4. 赋值vs比较** | `if(board[i][j] = '.')` | `if(board[i][j] != '.')` |
| **5. 数组维度** | `grid[i/3][j/3]` | `grid[i/3][j/3][num]` |
| **6. if大括号** | `if(x) 标记;` → 永远执行 | `标记;` 或 `if(x) {}`|

---

### 🎯 与N皇后的深度对比

| | **N皇后（LeetCode 51）** | **解数独（LeetCode 37）** |
|---|---|---|
| **二维空间** | n×n棋盘 | 9×9棋盘（固定） |
| **决策** | 每行放1个皇后 | 填所有空格 |
| **选择范围** | 每行n列可选 | 每格9个数字可选 |
| **约束维度** | 列、两条对角线（3个） | 行、列、宫格（3个） |
| **标记数组** | `col[n]`, `diag1[2n]`, `diag2[2n]` | `row[9][10]`, `col[9][10]`, `grid[3][3][10]` |
| **剪枝公式** | `row-col+n`, `row+col` | `i/3`, `j/3` |
| **返回值** | `void`（所有解） | `bool`（一个解） ⭐ |
| **位置参数** | `row`（行号） | `pos`（格子编号） |

**共同点**：
1. 都是**多约束排列型**回溯
2. 都需要**多个check数组**
3. 都用**数学映射**简化判断（对角线/宫格）
4. 都是**空间换时间**（标记数组）
5. 都需要**位置参数**（按固定顺序填）

**不同点**：
1. N皇后返回`void`（收集所有解），解数独返回`bool`（找到一个解就返回）
2. N皇后用`row`参数（逐行），解数独用`pos`参数（逐格）
3. N皇后约束：列+对角线，解数独约束：行+列+宫格

---

### 💡 核心总结

#### **算法思想**
1. **DFS + 回溯**：逐格尝试填数字，试错回溯
2. **剪枝优化**：用标记数组O(1)检查三个维度的冲突
3. **数学映射**：`(i, j) → pos`（一维化），`(i, j) → (i/3, j/3)`（宫格定位）
4. **提前返回**：找到解立即返回true，不继续搜索

#### **回溯模板（多约束排列型）**
```cpp
bool dfs(int pos) {
    // 1. 递归出口
    if(所有位置都填完) return true;
    
    // 2. 跳过已填的
    if(当前位置已填) return dfs(pos+1);
    
    // 3. 尝试所有选择
    for(每个可能的选择) {
        if(满足约束条件) {  // 剪枝
            做选择 + 标记;
            if(dfs(pos+1)) return true;  // 找到解，立即返回
            撤销 + 恢复;
        }
    }
    
    // 4. 所有选择都失败
    return false;
}
```

#### **易错点**
1. ❌ `for(i=9; i<9; i++)` → ✅ `for(i=0; i<9; i++)`
2. ❌ `board[i][j] != '0'` → ✅ `board[i][j] != '.'`
3. ❌ `i=pos/i; j=pos/j;` → ✅ `i=pos/9; j=pos%9;`
4. ❌ `if(x = y)` → ✅ `if(x == y)` 或 `if(x != y)`
5. ❌ `grid[i/3][j/3]` → ✅ `grid[i/3][j/3][num]`
6. ❌ 忘记 `if(dfs()) return true;` → 找到解不返回

---

### 🎓 学习心得

> **"解数独 = N皇后的标记思想 + 全排列的试错思想"**

**知识迁移**：
- **N皇后** → 学会多个check数组 + 数学映射
- **全排列** → 学会试错回溯 + 恢复现场
- **有效数独** → 学会行列宫格的标记
- **解数独** → 三者结合！

**本质**：
- **标记数组**：空间换时间，O(1)检查冲突
- **数学映射**：`pos/9`、`pos%9`、`i/3`、`j/3`
- **提前返回**：`bool`返回值 + `if(dfs()) return true`

**理解pos参数的关键**：
- 如果是"从所有元素中选"（无序） → 不需要位置参数
- 如果是"按固定顺序填"（有序） → 需要位置参数

---

**提交时间**：2025-10-28
**状态**：✅ AC
**用时**：一次通过（理解标记思想+位置参数后）
**难点**：pos坐标转换、返回值bool的正确使用

---

## 3. LeetCode 79 - 单词搜索

### 📌 题目信息
- **难度**：Medium
- **标签**：数组、回溯、矩阵
- **链接**：[LeetCode 79](https://leetcode.com/problems/word-search/)

---

### 📋 题目描述

给定一个 `m×n` 二维字符网格 `board` 和一个字符串单词 `word`。如果 `word` 存在于网格中，返回 `true`；否则，返回 `false`。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中"相邻"单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例**：
```
输入：board = [["A","B","C","E"],
              ["S","F","C","S"],
              ["A","D","E","E"]], 
     word = "ABCCED"
输出：true

输入：board = [["A","B","C","E"],
              ["S","F","C","S"],
              ["A","D","E","E"]], 
     word = "ABCB"
输出：false
```

**提示**：
- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

---

### 🔑 解题思路

#### **问题类型识别**

这道题是一种新的回溯类型：**二维网格DFS搜索型** ⭐

**与七大类型的区别**：

| 特性 | 全排列型 | **单词搜索型** |
|---|---|---|
| 搜索空间 | 一维数组 | **二维网格** |
| 决策方式 | "选哪个元素" | "走哪个方向" |
| 移动方向 | 遍历所有元素 | **上下左右4个方向** |
| 位置参数 | 不需要 | **需要(i, j)坐标** |
| check数组 | 1维 `check[n]` | **2维 `vis[m][n]`** |
| 递归方式 | for循环遍历 | **4个方向固定递归** |
| 返回值 | void（所有解） | **bool（一个解）** |

**与全排列的相似点** ⭐⭐⭐：
1. ✅ 都需要标记数组（check/vis）
2. ✅ 都是"每个位置都要用"
3. ✅ 都关心顺序（路径顺序）
4. ✅ 都在叶子节点记录/返回
5. ✅ 都需要恢复现场

**核心区别**：
- 全排列是"**选择问题**"：从所有元素中选
- 单词搜索是"**路径问题**"：在网格中移动

---

#### **算法流程**

```
1. 遍历网格的每个位置作为起点：
   - 如果 board[i][j] == word[0]，尝试从这里开始搜索

2. DFS搜索（从起点开始）：
   a. 递归出口：
      - 成功：pos == word.size()（找到完整单词）
      - 失败：越界、已访问、字符不匹配
   
   b. 标记当前位置 vis[i][j] = true
   
   c. 向四个方向探索：
      - 上：(i-1, j)
      - 下：(i+1, j)
      - 左：(i, j-1)
      - 右：(i, j+1)
   
   d. 恢复现场 vis[i][j] = false

3. 如果任何起点能找到，返回true；否则返回false
```

---

#### **关键技巧**

##### **1. 方向数组优化**

```cpp
// 方向数组：上、下、左、右
int dx[4] = {-1, 1, 0, 0};   // 行偏移
int dy[4] = {0, 0, -1, 1};   // 列偏移

// 使用
for(int k = 0; k < 4; k++) {
    int x = i + dx[k];
    int y = j + dy[k];
    // 向第k个方向探索
}
```

**优点**：
- 代码简洁
- 易于扩展（8个方向只需改数组）

---

##### **2. 两种实现方式对比**

**方式1：主函数标记起点，dfs从相邻位置开始（推荐）**

```cpp
// 主函数
for(int i = 0; i < m; i++) {
    for(int j = 0; j < n; j++) {
        if(board[i][j] == word[0]) {  // 提前过滤
            vis[i][j] = true;         // 标记起点
            if(dfs(board, i, j, word, 1)) return true;  // 从pos=1开始
            vis[i][j] = false;
        }
    }
}

// dfs：检查新位置
bool dfs(board, i, j, word, pos) {
    if(pos == word.size()) return true;
    
    // 向四个方向探索新位置(x,y)
    for(int k = 0; k < 4; k++) {
        int x = i + dx[k], y = j + dy[k];
        if(合法 && 未访问 && 匹配) {
            vis[x][y] = true;
            if(dfs(board, x, y, word, pos+1)) return true;
            vis[x][y] = false;
        }
    }
    return false;
}
```

**优点**：
- 主函数提前过滤不匹配的起点
- 效率稍高

---

**方式2：主函数不标记，dfs检查当前位置**

```cpp
// 主函数
for(int i = 0; i < m; i++) {
    for(int j = 0; j < n; j++) {
        if(dfs(board, i, j, word, 0)) return true;  // 从pos=0开始
    }
}

// dfs：检查当前位置
bool dfs(board, i, j, word, pos) {
    if(pos == word.size()) return true;
    
    // 检查当前位置
    if(越界 || 已访问 || 不匹配) return false;
    
    // 标记当前位置
    vis[i][j] = true;
    
    // 向四个方向探索
    if(dfs(i-1, j, pos+1)) return true;  // 上
    if(dfs(i+1, j, pos+1)) return true;  // 下
    if(dfs(i, j-1, pos+1)) return true;  // 左
    if(dfs(i, j+1, pos+1)) return true;  // 右
    
    // 恢复现场
    vis[i][j] = false;
    return false;
}
```

**优点**：
- 代码统一，dfs负责所有检查
- 更容易理解

---

### ❌ 初始错误代码

```cpp
class Solution {
public:
    bool vis[7][7];
    int m, n;
    
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size();
        n = board[0].size();
        memset(vis, false, sizeof(vis));
        
        // ❌ 错误1：只从(0,0)开始搜索
        dfs(board, 0, 0, word, 0);
        return false;
    }
    
    bool dfs(vector<vector<char>>& board, int i, int j, string& word, int pos) {
        if(pos >= word.size()) return true;
        
        // ❌ 错误2：缺少字符匹配检查
        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || vis[i][j])
            return false;
        
        vis[i][j] = true;
        
        if(dfs(board, i - 1, j, word, pos + 1)) return true;
        if(dfs(board, i + 1, j, word, pos + 1)) return true;
        if(dfs(board, i, j - 1, word, pos + 1)) return true;
        if(dfs(board, i, j + 1, word, pos + 1)) return true;
        
        vis[i][j] = false;
        return false;
    }
};
```

---

### ✅ 正确代码

#### **方法1：主函数标记起点（推荐）**

```cpp
class Solution {
public:
    bool vis[7][7];
    int m, n;
    int dx[4] = {-1, 1, 0, 0};   // 上、下、左、右
    int dy[4] = {0, 0, -1, 1};
    
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size();
        n = board[0].size();
        memset(vis, false, sizeof(vis));
        
        // 遍历每个位置作为起点
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(board[i][j] == word[0]) {  // 提前过滤
                    vis[i][j] = true;
                    if(dfs(board, i, j, word, 1)) return true;
                    vis[i][j] = false;
                }
            }
        }
        return false;
    }
    
    bool dfs(vector<vector<char>>& board, int i, int j, string& word, int pos) {
        // 出口：找到完整单词
        if(pos == word.size()) return true;
        
        // 向四个方向探索
        for(int k = 0; k < 4; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            
            // 检查新位置是否合法
            if(x >= 0 && x < m && y >= 0 && y < n &&
               !vis[x][y] && board[x][y] == word[pos]) {
                
                vis[x][y] = true;
                if(dfs(board, x, y, word, pos + 1)) return true;
                vis[x][y] = false;
            }
        }
        return false;
    }
};
```

---

#### **方法2：dfs检查当前位置**

```cpp
class Solution {
public:
    bool vis[7][7];
    int m, n;
    
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size();
        n = board[0].size();
        memset(vis, false, sizeof(vis));
        
        // 遍历每个位置作为起点
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(dfs(board, i, j, word, 0)) return true;
            }
        }
        return false;
    }
    
    bool dfs(vector<vector<char>>& board, int i, int j, string& word, int pos) {
        // 出口：找到完整单词
        if(pos == word.size()) return true;
        
        // 检查当前位置
        if(i < 0 || i >= m || j < 0 || j >= n) return false;   // 越界
        if(vis[i][j]) return false;                             // 已访问
        if(board[i][j] != word[pos]) return false;              // 不匹配
        
        // 标记当前位置
        vis[i][j] = true;
        
        // 向四个方向探索
        if(dfs(board, i - 1, j, word, pos + 1)) return true;  // 上
        if(dfs(board, i + 1, j, word, pos + 1)) return true;  // 下
        if(dfs(board, i, j - 1, word, pos + 1)) return true;  // 左
        if(dfs(board, i, j + 1, word, pos + 1)) return true;  // 右
        
        // 恢复现场
        vis[i][j] = false;
        return false;
    }
};
```

**时间复杂度**：`O(m*n*4^L)`，L是word长度（最坏情况每个位置都作为起点，每次有4个方向）
**空间复杂度**：`O(m*n)` + 递归栈O(L)

---

### 🔬 核心知识点

#### **1. 为什么要遍历所有起点？**

```
单词可能从任何位置开始！

示例：
board = [['A','B','C'],
         ['S','F','E'],
         ['A','D','E']]
word = "SEE"

错误：只从(0,0)开始 → 找不到
正确：遍历所有位置
  - (1,0)='S' → (1,2)='E' ❌ 不相邻
  - (1,2)='S' ≠ 'S'
  - ...
  - 最终从某个位置找到路径
```

---

#### **2. 为什么需要vis数组？**

```
避免同一个格子重复使用！

示例：
word = "ABCB"
如果(0,2)='B'被访问过，就不能再访问了

没有vis数组：
  A(0,0) → B(0,1) → C(0,2) → B(0,1) ❌ 重复使用
  
有vis数组：
  A(0,0) → B(0,1) [vis=true] → C(0,2) → B(0,1)? [vis=true] ❌
  正确返回false
```

---

#### **3. 两种方法的本质区别**

| | **方法1** | **方法2** |
|---|---|---|
| **主函数职责** | 过滤第一个字符 | 不过滤 |
| **dfs起始pos** | 1 | 0 |
| **dfs检查对象** | 检查**新位置**(x,y) | 检查**当前位置**(i,j) |
| **效率** | 稍高（提前过滤） | 稍低 |
| **理解难度** | 稍难 | 稍易 |

**核心逻辑不同**：
```
方法1：
  主函数：检查board[i][j] == word[0]，标记
  dfs：从已标记的起点出发，检查四个方向的新位置
  
方法2：
  主函数：不检查，直接调用dfs
  dfs：检查当前位置是否匹配，然后向四个方向递归
```

---

#### **4. 常见错误总结**

| 错误类型 | 错误代码 | 正确代码 |
|---|---|---|
| **1. 只从(0,0)开始** | `dfs(board, 0, 0, word, 0)` | 遍历所有位置 |
| **2. 缺少字符匹配** | `if(越界 \|\| 已访问)` | `if(越界 \|\| 已访问 \|\| 不匹配)` |
| **3. 主函数和dfs冲突** | 主函数标记，dfs从同一位置开始 | 方法1或方法2 |

---

### 🎯 与全排列的深度对比

**相似点**（为什么像全排列）：

| 特性 | 全排列 | 单词搜索 |
|---|---|---|
| **标记数组** | `check[n]` | `vis[m][n]` |
| **使用方式** | 每个元素用一次 | 每个位置用一次 |
| **关心顺序** | ✅ [1,2,3] ≠ [3,2,1] | ✅ A→B→C ≠ C→B→A |
| **记录时机** | 叶子节点 | 叶子节点 |
| **恢复现场** | ✅ 需要 | ✅ 需要 |

**不同点**（为什么是新类型）：

| 特性 | 全排列 | 单词搜索 |
|---|---|---|
| **操作** | 从集合中"选择" | 在空间中"移动" |
| **决策** | "选哪个元素" | "走哪个方向" |
| **递归方式** | for循环遍历所有可选 | 固定4个方向 |
| **搜索空间** | 一维数组 | 二维网格 |

---

### 💡 核心总结

#### **算法思想**
1. **枚举起点**：遍历每个位置作为起点
2. **DFS搜索**：从起点向四个方向探索
3. **标记+回溯**：标记已访问的位置，递归后恢复
4. **提前返回**：找到路径立即返回true

#### **回溯模板（二维网格DFS型）**
```cpp
bool dfs(int i, int j, int pos) {
    // 1. 递归出口
    if(pos == target) return true;  // 找到目标
    if(不合法) return false;         // 失败情况
    
    // 2. 标记当前位置
    vis[i][j] = true;
    
    // 3. 向多个方向探索
    for(每个方向) {
        if(dfs(新位置, pos+1)) return true;
    }
    
    // 4. 恢复现场
    vis[i][j] = false;
    return false;
}
```

#### **易错点**
1. ❌ 只从(0,0)开始 → ✅ 遍历所有起点
2. ❌ 忘记字符匹配检查 → ✅ 检查`board[i][j] == word[pos]`
3. ❌ 主函数标记后dfs从同一位置开始 → ✅ 选择方法1或方法2

---

### 🎓 学习心得

> **"单词搜索 = 在网格中探索路径的回溯问题"**

**关键理解**：
1. **类似全排列**：都需要标记、恢复现场、关心顺序
2. **不同于全排列**：操作是"移动"而非"选择"
3. **新类型**：二维网格DFS搜索型（回溯第8种类型）

**核心技巧**：
- 方向数组优化代码
- 两种实现方式的选择
- vis数组避免重复访问

**与之前的联系**：
- **N皇后、解数独** → 学会了二维空间的标记
- **全排列** → 学会了标记+回溯
- **单词搜索** → 两者结合，在二维空间中探索路径

---

**提交时间**：2025-10-28
**状态**：✅ AC
**用时**：理解问题类型后一次通过
**难点**：理解为什么要遍历所有起点、两种方法的区别

---

## 4. LeetCode 1219 - 黄金矿工

### 📌 题目信息
- **难度**：Medium
- **标签**：数组、回溯、矩阵
- **链接**：[LeetCode 1219](https://leetcode.com/problems/path-with-maximum-gold/)

---

### 📋 题目描述

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 `m×n` 的网格 `grid` 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 `0`。

为了使收益最大化，矿工需要按以下规则来开采黄金：
- 每当矿工进入一个单元格，就会收集该单元格中的所有黄金。
- 矿工每次可以从当前位置向上下左右四个方向走到相邻的单元格，但不能重复访问已经开采过的单元格。
- 不能访问无黄金的单元格，即不能访问数值为 `0` 的单元格。
- 矿工可以从网格中**任意一个**有黄金的单元格出发或停止。

**示例**：
```
输入：grid = [[0,6,0],
             [5,8,7],
             [0,9,0]]
输出：24
解释：路径为 5 → 8 → 7 → 9

输入：grid = [[1,0,7],
             [2,0,6],
             [3,4,5],
             [0,3,0],
             [9,0,20]]
输出：28
解释：路径为 1 → 2 → 3 → 4 → 5 → 6 → 7
```

**提示**：
- `1 <= grid.length, grid[i].length <= 15`
- `0 <= grid[i][j] <= 100`
- 最多 **25** 个单元格中有黄金

---

### 🔑 解题思路

#### **问题类型识别**

这道题是**二维网格DFS型**的变体：

**与单词搜索的对比**：

| 特性 | 单词搜索 | 黄金矿工 |
|---|---|---|
| **目标** | 找**一条**路径 | 找**所有**路径的最大值 |
| **返回值** | `bool`（找到就返回） | `void`（遍历所有路径） |
| **记录方式** | 找到立即返回true | 每条路径都记录，更新最大值 |
| **全局变量** | 不需要累加 | 需要`tmp`累加当前路径 |
| **递归调用** | `if(dfs()) return true` | `dfs()` 不返回 |
| **更新结果** | 只在找到时 | **每个节点**都更新 |

**核心理解** ⭐⭐⭐：
> **有全局变量记录状态 → 不需要返回值传递**

```cpp
// 单词搜索：用bool向上传递"是否找到"
bool dfs(...) {
    if(找到) return true;  // ← 向上传递状态
    if(dfs(...)) return true;  // ← 接收并继续传递
}

// 黄金矿工：用全局变量记录状态
int tmp = 0;  // 全局变量，自动记录
void dfs(...) {
    tmp += gold;  // ← 状态记录在全局变量
    ret = max(ret, tmp);  // ← 更新最大值
    dfs(...);  // ← 不需要返回值，状态已在全局变量中
    tmp -= gold;  // ← 恢复状态
}
```

---

#### **算法流程**

```
1. 遍历网格的每个位置作为起点：
   - 只从有黄金的格子开始（grid[i][j] != 0）

2. DFS搜索（遍历所有路径）：
   a. 递归出口：
      - 越界：i<0 || i>=m || j<0 || j>=n
      - 已访问：vis[i][j] == true
      - 没有黄金：grid[i][j] == 0
   
   b. 标记当前位置：
      - vis[i][j] = true
      - tmp += grid[i][j]
   
   c. 更新全局最大值：
      - ret = max(ret, tmp)  // 每个节点都可能是终点
   
   d. 向四个方向探索：
      - dfs(i-1, j)  // 上
      - dfs(i+1, j)  // 下
      - dfs(i, j-1)  // 左
      - dfs(i, j+1)  // 右
   
   e. 恢复现场：
      - vis[i][j] = false
      - tmp -= grid[i][j]

3. 返回全局最大值ret
```

---

#### **关键技巧**

##### **1. 为什么每个节点都更新ret？**

```cpp
// ✅ 正确：在标记后立即更新
vis[i][j] = true;
tmp += grid[i][j];
ret = max(ret, tmp);  // ← 每个节点都可能是终点

// ❌ 错误：只在某些条件下更新
if(四个方向都走不通) {  // 只在叶子节点更新
    ret = max(ret, tmp);
}
```

**原因**：
```
示例：
1 → 2 → 3
        ↓
        4

路径1：1 → 2 → 3 (黄金=6)
路径2：1 → 2 → 3 → 4 (黄金=10)

如果只在叶子更新：
  - 访问3时，向下能走到4，所以3不是叶子，不更新
  - 只记录了路径2的10，漏掉了路径1的6
  
正确做法：每个节点都更新
  - 访问3时：ret = max(ret, 6)
  - 访问4时：ret = max(ret, 10)
  - 两条路径都记录了！
```

---

##### **2. 为什么要恢复tmp？**

```cpp
// 错误：不恢复tmp
tmp += grid[i][j];
dfs(grid, i+1, j);  // tmp累加了这条路径
dfs(grid, i, j+1);  // tmp还包含上一条路径！❌

// 正确：恢复tmp
tmp += grid[i][j];
dfs(grid, i-1, j);
dfs(grid, i+1, j);
dfs(grid, i, j-1);
dfs(grid, i, j+1);
tmp -= grid[i][j];  // ✅ 恢复，保证兄弟节点的tmp正确
```

**可视化**：
```
      (1,0)=5
      /    \
  (2,0)=3  (2,1)=4
  
访问(2,0)：tmp = 5 + 3 = 8, ret=8
回溯后：    tmp = 5  // ✅ 恢复
访问(2,1)：tmp = 5 + 4 = 9, ret=9  // ✅ 从正确的值开始

如果不恢复：
访问(2,1)：tmp = 5 + 3 + 4 = 12  // ❌ 错误！包含了(2,0)
```

---

##### **3. bool vs void的本质区别** ⭐⭐⭐

**什么时候用bool？**
- 需要向上传递**二元状态**（是/否、找到/未找到）
- 找到一个解就停止搜索
- 典型：单词搜索、解数独

```cpp
bool dfs(...) {
    if(满足条件) return true;  // 向上传递"找到了"
    
    if(dfs(...)) return true;  // 找到就立即返回
    if(dfs(...)) return true;
    
    return false;  // 向上传递"没找到"
}
```

**什么时候用void？**
- 不需要向上传递状态（用全局变量记录）
- 需要遍历所有可能性
- 典型：全排列、子集、黄金矿工

```cpp
int ret = 0;  // 全局变量记录状态
void dfs(...) {
    ret = max(ret, tmp);  // 直接更新全局变量
    
    dfs(...);  // 不需要返回值，继续遍历
    dfs(...);
}
```

**核心理解**：
```
返回值的作用 = 向上层传递信息

bool返回值：
  子层："我找到了"或"我没找到"
  父层：根据子层的反馈决定是否继续

void + 全局变量：
  子层：直接更新全局变量
  父层：不需要子层的反馈，继续遍历
  
关键：全局变量本身就是"状态传递"的机制！
```

---

### ❌ 初始错误代码

```cpp
class Solution {
public:
    int ret = 0;
    int tmp = 0;
    bool vis[16][16];
    // ❌ 错误1：缺少m, n定义
    
    int getMaximumGold(vector<vector<int>>& grid) {
        m = grid.size();  // ❌ m未定义
        n = grid[0].size();
        memset(vis, false, sizeof(vis));
        
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                // ❌ 错误2：从所有位置开始（包括0）
                dfs(grid, i, j);
            }
        }
        return ret;
    }
    
    // ❌ 错误3：返回值类型错误
    bool dfs(vector<vector<int>>& grid, int i, int j) {
        if(i < 0 || i >= m || j < 0 || j >= n) return false;
        if(vis[i][j]) return false;
        
        // ❌ 错误4：出口2判断会越界
        if(grid[i-1][j] == 0 && grid[i+1][j] == 0 && ...) {
            tmp += grid[i][j];
            ret = max(ret, tmp);
            return true;
        }
        
        // ❌ 错误5：标记逻辑混乱
        if(grid[i][j] != 0) {
            tmp += grid[i][j];
            grid[i][j] -= //← 没写完
        }
        vis[i][j] = true;
        
        // ❌ 错误6：参数错误（复制的单词搜索）
        if(dfs(board, i - 1, j, word, pos + 1)) return true;
        
        // ❌ 错误7：恢复现场不完整
        //恢复  // ← 没写完
    }
};
```

---

### ✅ 正确代码

```cpp
class Solution {
public:
    int ret = 0;   // 全局最大值
    int tmp = 0;   // 当前路径的黄金总数
    bool vis[16][16];
    int m, n;
    
    int getMaximumGold(vector<vector<int>>& grid) {
        m = grid.size();
        n = grid[0].size();
        memset(vis, false, sizeof(vis));
        
        // 遍历每个位置作为起点
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] != 0) {  // 只从有黄金的格子开始
                    dfs(grid, i, j);
                }
            }
        }
        return ret;
    }
    
    void dfs(vector<vector<int>>& grid, int i, int j) {
        // 出口1：越界
        if(i < 0 || i >= m || j < 0 || j >= n) return;
        
        // 出口2：已访问 或 没有黄金
        if(vis[i][j] || grid[i][j] == 0) return;
        
        // 标记当前位置
        vis[i][j] = true;
        tmp += grid[i][j];
        
        // 更新全局最大值（每个节点都更新）
        ret = max(ret, tmp);
        
        // 向四个方向探索
        dfs(grid, i - 1, j);  // 上
        dfs(grid, i + 1, j);  // 下
        dfs(grid, i, j - 1);  // 左
        dfs(grid, i, j + 1);  // 右
        
        // 恢复现场
        vis[i][j] = false;
        tmp -= grid[i][j];
    }
};
```

**时间复杂度**：`O(m*n*4^k)`，k是最多25（有黄金的格子数）
**空间复杂度**：`O(m*n)` + 递归栈O(k)

---

### 🔬 核心知识点

#### **1. 不需要"叶子节点"判断**

```cpp
// ❌ 错误：判断四面都是0
if(grid[i-1][j] == 0 && grid[i+1][j] == 0 && ...) {
    ret = max(ret, tmp);  // 只在叶子更新
}

// ✅ 正确：每个节点都更新
vis[i][j] = true;
tmp += grid[i][j];
ret = max(ret, tmp);  // ← 每个节点都是潜在终点

// 原因：
// 1. 四个方向的dfs会自动处理
// 2. 到达叶子节点时，四个dfs都return，自然结束
// 3. 每个节点都可能是"最优路径的终点"
```

---

#### **2. void + 全局变量 vs bool + 返回值**

| | **void + 全局变量** | **bool + 返回值** |
|---|---|---|
| **状态传递** | 全局变量自动记录 | 返回值向上传递 |
| **搜索策略** | 遍历所有路径 | 找到一个就停止 |
| **递归调用** | `dfs()` 不返回 | `if(dfs()) return` |
| **何时使用** | 需要所有结果 | 只需一个结果 |
| **典型题目** | 全排列、子集、黄金矿工 | 单词搜索、解数独 |

**本质理解**：
```
问题：为什么需要返回值？
答案：为了向上层传递信息

如果有全局变量记录状态：
  ✅ 不需要返回值传递
  ✅ 状态已经在全局变量中
  
如果需要提前终止搜索：
  ✅ 需要bool返回值
  ✅ 告诉上层"找到了，可以停止了"
```

---

#### **3. 执行流程可视化**

```
grid = [[1,0,7],
        [2,0,6],
        [3,4,5]]

从(0,0)=1开始：
(0,0): tmp=1, ret=1
  ├─ (1,0): tmp=3, ret=3
  │   └─ (2,0): tmp=6, ret=6
  │       └─ (2,1): tmp=10, ret=10
  │           └─ (2,2): tmp=15, ret=15
  │               └─ (1,2): tmp=21, ret=21 ✅
  │                   (回溯)
  │               (回溯) tmp=15
  │           (回溯) tmp=10
  │       (回溯) tmp=6
  │   (回溯) tmp=3
  ├─ (向其他方向...)
(回溯) tmp=0

从其他起点继续尝试...

最终：ret = 最大的路径和
```

---

#### **4. 常见错误总结**

| 错误类型 | 错误代码 | 正确代码 |
|---|---|---|
| **1. 缺少m,n** | `m = grid.size()` 未定义 | `int m, n;` 成员变量 |
| **2. 起点错误** | 从所有位置开始 | 只从`grid[i][j]!=0`开始 |
| **3. 返回值错误** | `bool dfs()` | `void dfs()` |
| **4. 叶子判断越界** | `if(grid[i-1][j]==0...)` | 不需要这个判断 |
| **5. 标记逻辑** | 修改grid | 只用vis标记 |
| **6. 参数错误** | 复制单词搜索的参数 | `dfs(grid, i, j)` |
| **7. 不恢复tmp** | 只恢复vis | `tmp -= grid[i][j]` |

---

### 💡 核心总结

#### **算法思想**
1. **枚举所有起点**：从每个有黄金的格子开始
2. **DFS遍历所有路径**：不提前终止，遍历完所有可能
3. **全局变量记录状态**：tmp累加当前路径，ret记录最大值
4. **每个节点都更新**：不等到叶子节点，每个节点都可能是终点

#### **回溯模板（遍历所有路径型）**
```cpp
int ret = 0;  // 全局最大值
int tmp = 0;  // 当前路径值

void dfs(int i, int j) {
    // 1. 递归出口
    if(不合法) return;
    
    // 2. 标记 + 累加
    vis[i][j] = true;
    tmp += value;
    
    // 3. 更新全局最大值
    ret = max(ret, tmp);
    
    // 4. 向所有方向探索（不返回）
    dfs(i-1, j);
    dfs(i+1, j);
    dfs(i, j-1);
    dfs(i, j+1);
    
    // 5. 恢复现场
    vis[i][j] = false;
    tmp -= value;
}
```

#### **易错点**
1. ❌ 只从(0,0)开始 → ✅ 从所有有黄金的格子开始
2. ❌ 用bool返回值 → ✅ 用void + 全局变量
3. ❌ 只在叶子更新 → ✅ 每个节点都更新
4. ❌ 忘记恢复tmp → ✅ 恢复vis和tmp

---

### 🎓 学习心得

> **"void + 全局变量 = 遍历所有路径，bool + 返回值 = 找一条路径就停止"**

**关键理解**：
1. **返回值的作用**：向上层传递信息
2. **全局变量的作用**：自动记录状态，不需要返回值
3. **void的使用场景**：需要遍历所有可能性，记录最优解
4. **bool的使用场景**：找到一个解就停止，提前终止搜索

**与之前的联系**：
- **单词搜索** → 学会了网格DFS + bool返回值
- **全排列/子集** → 学会了void + 全局变量遍历
- **黄金矿工** → 两者结合，网格DFS + void遍历所有路径

**本质突破**：
> **"有全局变量记录状态 → 不需要返回值传递"**

这不是代码风格的选择，而是算法需求的体现：
- 需要一个解 → bool
- 需要所有解/最优解 → void + 全局变量

---

**提交时间**：2025-10-28
**状态**：✅ AC
**用时**：理解bool vs void后一次通过
**难点**：理解为什么用void、每个节点都更新、恢复tmp的重要性

---


