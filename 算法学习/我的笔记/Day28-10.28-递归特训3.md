# Day28 - 10.28 递归特训3

> **主题**：验证类问题 + 哈希标记优化
> **核心收获**：N皇后的标记思想可以迁移到其他验证问题

---

## 1. LeetCode 36 - 有效的数独

### 📌 题目信息
- **难度**：Medium
- **标签**：数组、哈希表、矩阵
- **链接**：[LeetCode 36](https://leetcode.com/problems/valid-sudoku/)

---

### 📋 题目描述

判断一个 9×9 的数独是否有效。只需要**根据以下规则，验证已经填入的数字是否有效**即可。

**数独规则**：
1. 数字 `1-9` 在每一**行**只能出现一次
2. 数字 `1-9` 在每一**列**只能出现一次
3. 数字 `1-9` 在每一个以粗实线分隔的 `3×3` 宫内只能出现一次

**注意**：
- 一个有效的数独（部分已被填充）不一定是可解的
- 只需要根据以上规则，验证已经填入的数字是否有效即可
- 空白格用 `'.'` 表示

**示例**：
```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true

输入：board = 
[["8","3",".",".","7",".",".",".","."]  // 第一行第一个是8
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]  // 第四行第一个也是8（同一列冲突）
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：false
解释：第0列有两个8，冲突
```

---

### 🔑 解题思路

#### **问题类型识别**

这道题和N皇后有本质区别：

| | **N皇后（LeetCode 51）** | **有效的数独（LeetCode 36）** |
|---|---|---|
| **问题类型** | 生成类（回溯） | 验证类（遍历） |
| **需要递归** | ✅ 需要 | ❌ 不需要 |
| **需要恢复现场** | ✅ 需要 | ❌ 不需要 |
| **核心操作** | 试错 + 生成 | 检查 + 标记 |
| **标记数组作用** | 剪枝（避免冲突） | 记录已出现（检测重复） |

**核心思想**：借鉴N皇后的**标记数组思想**，但不需要递归！

---

#### **算法流程**

```
1. 准备三组标记数组：
   - row[9]：记录每行出现过哪些数字
   - col[9]：记录每列出现过哪些数字
   - grid[3][3]：记录每个3×3宫格出现过哪些数字

2. 一次遍历整个棋盘 (i, j)：
   - 如果是空格 '.'，跳过
   - 如果是数字 num：
     a. 检查：row[i]、col[j]、grid[i/3][j/3] 是否已有 num
        → 如果有，返回 false（冲突）
     b. 标记：在三个标记数组中记录 num

3. 遍历结束，返回 true
```

---

#### **关键难点：3×3宫格的定位**

**棋盘坐标 `(i, j)` → 宫格坐标 `(i/3, j/3)`**

```
数独棋盘的9个宫格编号：

       列0-2       列3-5       列6-8
    ┌───────────┬───────────┬───────────┐
行0-2│ grid[0][0]│ grid[0][1]│ grid[0][2]│
    │  左上宫格  │  上中宫格  │  右上宫格  │
    ├───────────┼───────────┼───────────┤
行3-5│ grid[1][0]│ grid[1][1]│ grid[1][2]│
    │  左中宫格  │  中心宫格  │  右中宫格  │
    ├───────────┼───────────┼───────────┤
行6-8│ grid[2][0]│ grid[2][1]│ grid[2][2]│
    │  左下宫格  │  下中宫格  │  右下宫格  │
    └───────────┴───────────┴───────────┘

计算公式：
  宫格行号 = i / 3
  宫格列号 = j / 3

示例：
  棋盘坐标 (0, 0) → grid[0/3][0/3] = grid[0][0] (左上)
  棋盘坐标 (2, 8) → grid[2/3][8/3] = grid[0][2] (右上)
  棋盘坐标 (4, 4) → grid[4/3][4/3] = grid[1][1] (中心)
  棋盘坐标 (8, 0) → grid[8/3][0/3] = grid[2][0] (左下)
```

---

### ❌ 初始错误代码

```cpp
class Solution {
public:
    bool row[9][10];
    bool col[9][10];
    bool grid[3][3][10];
    
    bool isValidSudoku(vector<vector<char>>& board) {
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    
                    // 检查冲突
                    if(row[i][num] || col[j][num] || grid[i/3][j/3][num])
                        return false;
                    
                    // ❌ 错误：标记语句缺少 = true
                    row[i][num] = col[j][num] = grid[i/3][j/3][num];
                    //                                              ↑
                    //                                          没有赋值true！
                }
            }
        }
        return true;
    }
};
```

**错误分析**：

```cpp
row[i][num] = col[j][num] = grid[i/3][j/3][num];
// 相当于：
// 把 grid[i/3][j/3][num] 的值（初始是false）赋给前面三个变量
// 结果：永远都是 false，无法标记

// 正确写法：
row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
//                                                 ↑
//                                              必须有true！
```

**测试用例**：
```
输入：第0列有两个8
board[0][0] = '8'
board[3][0] = '8'

执行过程（错误代码）：
1. 遇到board[0][0]='8'：
   - 检查：col[0][8] == false（初始值）
   - 标记：col[0][8] = false（❌ 没有标记成功）

2. 遇到board[3][0]='8'：
   - 检查：col[0][8] == false（还是false）
   - 没有检测到冲突！❌
   - 返回true（错误）

期望：应该返回false
实际：返回true
```

---

### ✅ 正确代码

#### **方法1：布尔数组（最优解）**

```cpp
class Solution {
public:
    bool row[9][10];      // row[i][num]: 第i行是否出现数字num
    bool col[9][10];      // col[j][num]: 第j列是否出现数字num
    bool grid[3][3][10];  // grid[x][y][num]: 第(x,y)个宫格是否出现数字num
    
    bool isValidSudoku(vector<vector<char>>& board) {
        // 一次遍历整个棋盘
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {  // 跳过空格
                    int num = board[i][j] - '0';  // 字符转数字
                    
                    // 检查是否冲突
                    if(row[i][num] || col[j][num] || grid[i/3][j/3][num])
                        return false;  // 发现冲突，立即返回
                    
                    // 标记：在三个维度记录这个数字出现过
                    row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
                }
            }
        }
        return true;  // 所有格子都检查完，没有冲突
    }
};
```

**时间复杂度**：`O(81) = O(1)`（固定9×9棋盘）
**空间复杂度**：`O(1)`（固定大小的标记数组）

---

#### **方法2：unordered_set（标准哈希表）**

```cpp
class Solution {
public:
    unordered_set<int> row[9];      // 9个集合，记录每行出现的数字
    unordered_set<int> col[9];      // 9个集合，记录每列出现的数字
    unordered_set<int> grid[3][3];  // 3×3=9个集合，记录每个宫格出现的数字
    
    bool isValidSudoku(vector<vector<char>>& board) {
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    
                    // 检查：这个数字在三个集合中是否已存在
                    if(row[i].count(num) || col[j].count(num) || grid[i/3][j/3].count(num))
                        return false;
                    
                    // 插入：把数字加入三个集合
                    row[i].insert(num);
                    col[j].insert(num);
                    grid[i/3][j/3].insert(num);
                }
            }
        }
        return true;
    }
};
```

**优点**：
- 语义清晰：`count` 检查存在性，`insert` 插入元素
- 适用于数字范围很大的场景

**缺点**：
- 哈希表有额外开销（哈希计算、内存分配）
- 速度稍慢于布尔数组

---

#### **方法3：unordered_map（可行但浪费）**

```cpp
class Solution {
public:
    unordered_map<int, bool> row[9];
    unordered_map<int, bool> col[9];
    unordered_map<int, bool> grid[3][3];
    
    bool isValidSudoku(vector<vector<char>>& board) {
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    
                    // 检查键是否存在
                    if(row[i].count(num) || col[j].count(num) || grid[i/3][j/3].count(num))
                        return false;
                    
                    // 插入键值对
                    row[i][num] = true;
                    col[j][num] = true;
                    grid[i/3][j/3][num] = true;
                }
            }
        }
        return true;
    }
};
```

**缺点**：
- 存储键值对，比 `set` 多存一个 `bool` 值（冗余）
- 内存占用更大

---

### 📊 三种方法对比

| 方法 | 数据结构 | 检查存在 | 标记 | 适用场景 |
|---|---|---|---|---|
| **bool数组** | `bool row[9][10]` | `row[i][num]` | `row[i][num] = true` | ✅ 数字范围小（1-9） |
| **unordered_set** | `unordered_set<int> row[9]` | `row[i].count(num)` | `row[i].insert(num)` | 数字范围大、语义清晰 |
| **unordered_map** | `unordered_map<int, bool> row[9]` | `row[i].count(num)` | `row[i][num] = true` | ⚠️ 可行但浪费内存 |

**等价关系**：
```cpp
// 检查数字5是否在第0行出现过
row[0][5]           // bool数组
row[0].count(5)     // unordered_set
row[0].count(5)     // unordered_map

// 标记数字5在第0行出现过
row[0][5] = true    // bool数组
row[0].insert(5)    // unordered_set
row[0][5] = true    // unordered_map
```

**推荐**：本题用**布尔数组**最优（速度快、内存小）

---

### 🔬 核心知识点

#### **1. 数据结构深度对比**

##### **`unordered_set<int> row[9]` 的本质**

```cpp
unordered_set<int> row[9];
//                  ↑
//               这是数组，有9个元素
//  ↑
//  每个元素是一个集合

// 可视化：
row[0] → {5, 3, 7}        // 第0行出现过5, 3, 7
row[1] → {6, 1, 9}        // 第1行出现过6, 1, 9
row[2] → {9, 8}           // 第2行出现过9, 8
...
row[8] → {2, 4}           // 第8行出现过2, 4
```

**类比**：
- `row[i]` = 第i行的"签到表"（集合）
- `row[i].insert(num)` = 数字num在第i行"签到"
- `row[i].count(num)` = 查询数字num是否签到过

##### **`unordered_set<int> grid[3][3]` 的本质**

```cpp
unordered_set<int> grid[3][3];
//                      ↑  ↑
//                      3行3列
//  ↑
//  每个元素是一个集合

// 可视化：3×3=9个抽屉
       列0          列1          列2
    ┌──────────┬──────────┬──────────┐
行0 │grid[0][0]│grid[0][1]│grid[0][2]│
    │{5,3,6,9} │  {7,1}   │   {8}    │
    ├──────────┼──────────┼──────────┤
行1 │grid[1][0]│grid[1][1]│grid[1][2]│
    │  {4,8}   │ {6,3,2}  │   {}     │
    ├──────────┼──────────┼──────────┤
行2 │grid[2][0]│grid[2][1]│grid[2][2]│
    │   {}     │   {}     │  {7,9}   │
    └──────────┴──────────┴──────────┘

对应数独的9个宫格：
grid[0][0] = 左上宫格
grid[0][1] = 上中宫格
grid[0][2] = 右上宫格
grid[1][0] = 左中宫格
grid[1][1] = 中心宫格
grid[1][2] = 右中宫格
grid[2][0] = 左下宫格
grid[2][1] = 下中宫格
grid[2][2] = 右下宫格
```

**访问方式**：
```cpp
// 棋盘坐标 (i, j) → 宫格坐标 (i/3, j/3)
grid[i/3][j/3].insert(num);       // 插入
if(grid[i/3][j/3].count(num))     // 检查
```

---

#### **2. unordered_set vs unordered_map**

| 特性 | `unordered_set<T>` | `unordered_map<K, V>` |
|---|---|---|
| **存储内容** | 只存值 | 存键值对 |
| **模板参数** | 1个 | 2个 |
| **插入** | `s.insert(value)` | `m[key] = value` |
| **检查存在** | `s.count(value)` | `m.count(key)` |
| **访问元素** | ❌ 不支持 | ✅ `m[key]` |
| **本题** | ✅ 合适（只需检查存在） | ⚠️ 可行但浪费 |

**使用场景**：
- **set**：只需要知道"是否存在"（去重、检查出现）
- **map**：需要"值 → 对应信息"（计数、索引映射）

**示例**：
```cpp
// set：只关心"是否存在"
unordered_set<int> appeared;
appeared.insert(5);
if(appeared.count(5)) cout << "5出现过";

// map：需要"值 → 对应信息"
unordered_map<int, int> freq;
freq[5] = 3;  // 数字5出现了3次
cout << freq[5];  // 输出3

unordered_map<char, string> charToStr;
charToStr['2'] = "abc";  // '2' → "abc"
cout << charToStr['2'];  // 输出"abc"
```

---

#### **3. 为什么 `bool row[9][10]` 第二维是 `[10]`？**

```cpp
bool row[9][10];
//         ↑
//      数字范围1-9，为什么开10个？

int num = board[i][j] - '0';  // num可能是1-9
row[i][num] = true;           // 直接用num作为索引
//      ↑ num=9时，需要访问row[i][9]，所以至少要[10]
```

**原因**：
- 数独中数字是 `1-9`
- 数组索引从 `0` 开始
- 为了让 `num` 直接作为索引（`row[i][num]`），需要开 `[10]`
- 虽然 `row[i][0]` 不会用到，但这样更简洁（不用 `num-1`）

**对比**：
```cpp
// 方式1：开[10]，直接用num（推荐）
bool row[9][10];
row[i][num] = true;  // num=5时，用row[i][5]

// 方式2：开[9]，需要num-1
bool row[9][9];
row[i][num-1] = true;  // num=5时，用row[i][4]
```

---

#### **4. 为什么 `grid[3][3][10]` 是三维？**

```cpp
bool grid[3][3][10];
//        ↑  ↑   ↑
//        宫格行 宫格列 数字

// 第1维[3]：宫格的行号（0-2，共3行宫格）
// 第2维[3]：宫格的列号（0-2，共3列宫格）
// 第3维[10]：数字0-9
```

**需求**：
- 有 `3×3 = 9` 个宫格
- 每个宫格要记录数字 `1-9` 是否出现

**为什么不用 `grid[9][10]`？**
```cpp
// 方案1：grid[3][3][10]（实际采用）
grid[i/3][j/3][num] = true;  // 直接用除法定位

// 方案2：grid[9][10]（也可以，但多一步计算）
int gridIndex = (i/3) * 3 + (j/3);
grid[gridIndex][num] = true;
```

**结论**：`grid[3][3][10]` 更直观（直接用 `i/3` 和 `j/3`）

---

#### **5. 字符转数字：`board[i][j] - '0'`**

```cpp
char c = '5';
int num = c - '0';  // num = 5

// 原理：
'0' 的ASCII码是 48
'5' 的ASCII码是 53
'5' - '0' = 53 - 48 = 5
```

---

### 🎯 与N皇后的对比

| | **N皇后（LeetCode 51）** | **有效的数独（LeetCode 36）** |
|---|---|---|
| **问题类型** | 生成类（回溯） | 验证类（遍历） |
| **核心算法** | DFS + 回溯 | 一次遍历 + 哈希检查 |
| **需要递归** | ✅ 需要 | ❌ 不需要 |
| **需要恢复现场** | ✅ 需要 | ❌ 不需要 |
| **标记数组** | `col`, `diag1`, `diag2` | `row`, `col`, `grid` |
| **标记作用** | 剪枝（避免冲突） | 检测重复 |
| **核心技巧** | 对角线映射 `row±col` | 宫格映射 `i/3, j/3` |
| **返回值** | `void`（收集所有解） | `bool`（是否有效） |

**共同点**：
1. 都用**标记数组**避免重复检查
2. 都需要**数学映射**（对角线/宫格定位）
3. 都是**空间换时间**的优化思想

**理解关键**：
> N皇后学会了"标记数组"的思想 → 有效数独直接复用，难度大降！

---

### 💡 核心总结

#### **算法思想**
1. **哈希标记**：用标记数组记录"已出现"，O(1)检测重复
2. **数学映射**：`(i, j) → (i/3, j/3)` 定位宫格
3. **三维检查**：行、列、宫格三个维度同时检查

#### **数据结构选择**
- **数字范围小（1-9）** → `bool数组`（最优）
- **数字范围大** → `unordered_set`（灵活）
- **需要对应信息** → `unordered_map`（功能强）

#### **关键代码**
```cpp
// 核心逻辑
if(row[i][num] || col[j][num] || grid[i/3][j/3][num])
    return false;  // 检查：三个维度任一重复 → 冲突

row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;  // 标记：记录出现过
```

#### **易错点**
1. ❌ 标记语句漏写 `= true`
2. ❌ 宫格定位错误（忘记 `/3`）
3. ❌ 混淆 `unordered_set` 和 `unordered_map`

---

### 🎓 学习心得

> **"理解了N皇后的标记思想后，有效数独从Medium降为Easy！"**

**关键迁移**：
- N皇后：`col[j]`, `diag1[row-col+n]`, `diag2[row+col]`
- 有效数独：`row[i][num]`, `col[j][num]`, `grid[i/3][j/3][num]`

**本质**：都是用**数学映射**将二维位置转换为一维索引，实现O(1)冲突检查！

---

**提交时间**：2025-10-28
**状态**：✅ AC
**用时**：一次通过（理解标记思想后）

---

## 2. LeetCode 37 - 解数独

### 📌 题目信息
- **难度**：Hard ⚠️
- **标签**：数组、哈希表、回溯、矩阵
- **链接**：[LeetCode 37](https://leetcode.com/problems/sudoku-solver/)

---

### 📋 题目描述

编写一个程序，通过填充空格来解决数独问题。

**数独规则**：
1. 数字 `1-9` 在每一**行**只能出现一次
2. 数字 `1-9` 在每一**列**只能出现一次
3. 数字 `1-9` 在每一个以粗实线分隔的 `3×3` 宫内只能出现一次

**要求**：
- 空白格用 `'.'` 表示
- 你可以假设给定的数独只有唯一解
- 给定数独**永远是 9×9 形式**

**示例**：
```
输入：
board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

输出：
[["5","3","4","6","7","8","9","1","2"]
,["6","7","2","1","9","5","3","4","8"]
,["1","9","8","3","4","2","5","6","7"]
,["8","5","9","7","6","1","4","2","3"]
,["4","2","6","8","5","3","7","9","1"]
,["7","1","3","9","2","4","8","5","6"]
,["9","6","1","5","3","7","2","8","4"]
,["2","8","7","4","1","9","6","3","5"]
,["3","4","5","2","8","6","1","7","9"]]
```

---

### 🔑 解题思路

#### **问题类型识别**

根据**递归方法论体系**：

| 类型 | 集合来源 | check数组 | index参数 | for循环 | 递归参数 |
|---|---|---|---|---|---|
| **多约束排列** | 二维空间 | ✅ 需要多个 | ✅ 需要(pos) | 需要 (i=1~9) | pos+1 |

**解数独 = 多约束排列型回溯**（类似N皇后）
- 在9×9的**二维空间**中填数
- 需要**三个check数组**：`row`、`col`、`grid`
- 需要**位置参数pos**：当前填到第几个格子
- 每个空格有**9种选择**（1-9），需要`for`循环

---

#### **与有效数独的对比**

| | **有效数独（LeetCode 36）** | **解数独（LeetCode 37）** |
|---|---|---|
| **问题类型** | ✅ 验证类（遍历） | ✅ 生成类（回溯） |
| **目标** | 检查已填数字是否有效 | 填充所有空格 |
| **是否需要递归** | ❌ 不需要 | ✅ 需要（DFS） |
| **是否需要check数组** | ✅ 需要（检测重复） | ✅ 需要（剪枝） |
| **是否需要恢复现场** | ❌ 不需要 | ✅ 需要 |
| **标记数组作用** | 记录"已出现" | 检查"能否填" |
| **复杂度** | O(81) | O(9^m)，m是空格数 |
| **类比** | 监考老师检查答卷 | 学生做填空题（试错） |

**关键区别**：
- **有效数独**：只看不动，检查是否合法
- **解数独**：要填空格，试错+回溯

---

#### **算法流程**

```
1. 初始化标记数组：
   - row[9][10]：记录每行使用的数字
   - col[9][10]：记录每列使用的数字
   - grid[3][3][10]：记录每个3×3宫格使用的数字

2. 遍历棋盘，标记已填的数字：
   - 跳过空格 '.'
   - 将已填数字标记到三个数组中

3. 从第0个格子开始DFS：
   - 如果pos >= 81，所有格子都填完了，返回true
   - 计算坐标：i = pos/9, j = pos%9
   - 如果当前格子已填，跳过（递归下一个）
   - 如果当前格子是空格：
     a. 尝试填1-9
     b. 剪枝：检查三个维度是否冲突
     c. 如果不冲突：
        - 做选择：填入数字，标记
        - 递归：填下一个格子
        - 如果递归返回true，找到解了，返回true
        - 否则恢复现场，尝试下一个数字
     d. 所有数字都试过了，返回false

4. 题目保证有唯一解，DFS会找到答案
```

---

#### **关键技巧**

##### **1. 二维坐标 ↔ 一维编号**

```cpp
// 为什么用一维编号pos？
// 因为要按顺序填格子（从左到右、从上到下）

// 转换公式：
pos = i * 9 + j;    // (i, j) → pos

i = pos / 9;         // pos → i（行号）
j = pos % 9;         // pos → j（列号）

// 示例：
(0, 0) → pos = 0
(0, 8) → pos = 8
(1, 0) → pos = 9   // 9/9=1, 9%9=0
(8, 8) → pos = 80  // 80/9=8, 80%9=8
```

---

##### **2. 返回值bool vs void**

| 问题类型 | 返回值 | 原因 |
|---|---|---|
| 全排列、子集 | `void` | 需要收集**所有解** |
| N皇后 I | `void` | 需要收集**所有解** |
| N皇后 II | `void` | 只统计数量，不中断搜索 |
| **解数独** | `bool` | 只需**一个解**，找到就返回 ⭐ |

```cpp
// N皇后：收集所有解
void dfs(int row) {
    if(row == n) {
        ret.push_back(board);  // 收集解
        return;  // 继续搜索其他解
    }
    // ...
}

// 解数独：找到一个解就返回
bool dfs(int pos) {
    if(pos >= 81) {
        return true;  // 找到解，立即返回
    }
    // ...
    if(dfs(pos + 1)) {
        return true;  // 找到解，向上传递 ⭐
    }
    // ...
}
```

**关键**：
- `if(dfs(pos+1))` 检查递归是否成功
- 如果成功，立即 `return true` 向上传递
- 如果失败，继续尝试其他数字

---

##### **3. 标记数组的复用**

| | **有效数独** | **解数独** |
|---|---|---|
| **初始化** | 边遍历边标记 | 先遍历一次标记已填数字 |
| **检查** | `if(row[i][num])` 检测冲突 | `if(!row[i][num])` 检查能否填 |
| **标记** | 只标记不恢复 | 标记 + 恢复（回溯） |

```cpp
// 有效数独：只标记，不恢复
row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;

// 解数独：标记 + 恢复
// 标记
row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
// ... 递归 ...
// 恢复
row[i][num] = col[j][num] = grid[i/3][j/3][num] = false;
```

---

### ❌ 初始错误代码

```cpp
class Solution {
public:
    bool row[9][10];
    bool col[9][10];
    bool grid[3][3][10];
    
    void solveSudoku(vector<vector<char>>& board) {
        memset(row, false, sizeof(row));
        memset(col, false, sizeof(col));
        memset(grid, false, sizeof(grid));
        
        // ❌ 错误1：初始化循环条件
        for(int i = 9; i < 9; i++)  // ← i=9永远不满足i<9！
        {
            for(int j = 0; j < 9; j++)
            {
                // ❌ 错误2：空格判断
                if(board[i][j] != '0')  // ← 空格是'.'，不是'0'
                {
                    int num = board[i][j] - '0';
                    
                    // ❌ 错误6：if语句缺少大括号
                    if(row[i][num] || col[j][num] || grid[i/3][j/3][num])
                    //标记
                    row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
                    // ↑ 这行永远执行！
                }
            }
        }
        
        int pos = 0;
        dfs(board, pos);       
    }
    
    bool dfs(vector<vector<char>>& board, int pos)
    {
        if(pos >= 81)
        {
            return true;
        }
        
        // ❌ 错误3：坐标计算（致命！）
        int i = pos/i;  // ← 除以自己？应该除以9
        int j = pos/j;  // ← 除法？应该取模%

        // ❌ 错误4：赋值 vs 比较
        if(board[i][j] = '.')  // ← 这是赋值！不是比较
        {
            return dfs(board, pos+1);
        }
        
        for(int num = 1; num <= 9; num++)
        {
            // ❌ 错误5：grid数组缺少维度
            if(!row[i][num] && !col[j][num] && !grid[i/3][j/3])  // ← 缺少[num]
            {
                board[i][j] = '0' + num;
                row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;

                if(dfs(board, pos+1))
                {
                    return true;
                }

                board[i][j] = '.';
                row[i][num] = col[j][num] = grid[i/3][j/3][num] = false;
            }
        }
        
        return false;
    }
};
```

---

### ✅ 正确代码

```cpp
class Solution {
public:
    bool row[9][10];
    bool col[9][10];
    bool grid[3][3][10];
    
    void solveSudoku(vector<vector<char>>& board) {
        // 初始化标记数组
        memset(row, false, sizeof(row));
        memset(col, false, sizeof(col));
        memset(grid, false, sizeof(grid));
        
        // ✅ 遍历棋盘，标记已填的数字
        for(int i = 0; i < 9; i++) {  // ✅ 从0开始
            for(int j = 0; j < 9; j++) {
                if(board[i][j] != '.') {  // ✅ 空格是'.'
                    int num = board[i][j] - '0';
                    // ✅ 题目保证初始无冲突，直接标记
                    row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
                }
            }
        }
        
        dfs(board, 0);  // 从第0个格子开始
    }
    
    bool dfs(vector<vector<char>>& board, int pos) {
        // 1. 递归出口
        if(pos >= 81) {
            return true;  // 所有格子都填完了
        }
        
        // 2. ✅ 计算当前格子的坐标
        int i = pos / 9;  // ✅ 行号 = pos除以9
        int j = pos % 9;  // ✅ 列号 = pos对9取模
        
        // 3. ✅ 如果当前格子已填，跳过
        if(board[i][j] != '.') {  // ✅ != 比较，不是 = 赋值
            return dfs(board, pos + 1);
        }
        
        // 4. 当前格子是空格，尝试填1-9
        for(int num = 1; num <= 9; num++) {
            // ✅ 剪枝：检查三个维度
            if(!row[i][num] && !col[j][num] && !grid[i/3][j/3][num]) {  // ✅ 加上[num]
                // 做选择
                board[i][j] = '0' + num;
                row[i][num] = col[j][num] = grid[i/3][j/3][num] = true;
                
                // 递归：填下一个格子
                if(dfs(board, pos + 1)) {
                    return true;  // 找到解了，立即返回
                }
                
                // 恢复现场（回溯）
                board[i][j] = '.';
                row[i][num] = col[j][num] = grid[i/3][j/3][num] = false;
            }
        }
        
        // 所有数字都试过了，无解
        return false;
    }
};
```

**时间复杂度**：`O(9^m)`，m是空格数（最坏情况每格试9个数字）
**空间复杂度**：`O(1)`（固定大小的标记数组 + 递归栈O(81)）

**实际运行**：由于剪枝有效，远小于理论复杂度

---

### 🔬 核心知识点

#### **1. 为什么需要pos参数？**

这是一个很好的问题！让我们对比三种情况：

| 问题类型 | **位置参数** | **check数组** | **for循环** | **原因** |
|---|---|---|---|---|
| **全排列（LeetCode 46）** | ❌ 不需要pos | ✅ 需要 | `i=0~n` | 每次都从**所有元素**中选 |
| **N皇后（LeetCode 51）** | ✅ 需要row | ✅ 需要多个 | `c=0~n` | **逐行**填，知道填到第几行 |
| **解数独（LeetCode 37）** | ✅ 需要pos | ✅ 需要多个 | `num=1~9` | **逐格**填，知道填到第几格 |

---

##### **全排列：不需要pos**

```cpp
// 全排列：每次都从所有元素中选一个没用过的
void dfs() {  // ❌ 不需要pos参数
    if(path.size() == n) {
        ret.push_back(path);
        return;
    }
    
    for(int i = 0; i < n; i++) {  // 每次遍历所有元素
        if(!check[i]) {  // 只看有没有用过
            path.push_back(nums[i]);
            check[i] = true;
            dfs();  // ← 不需要传位置
            path.pop_back();
            check[i] = false;
        }
    }
}
```

**为什么不需要pos？**
- 选择是**无序的**：每次都从所有元素中选一个没用过的
- check数组已经记录了"哪些用过"
- 不需要知道"填到哪个位置了"

**决策树**（n=3）：
```
[]
├─ 选0 → [0]
│   ├─ 选1 → [0,1]
│   │   └─ 选2 → [0,1,2] ✅
│   └─ 选2 → [0,2]
│       └─ 选1 → [0,2,1] ✅
├─ 选1 → [1]
...
每一步都是从"剩余的"中选
```

---

##### **N皇后：需要row（行号）**

```cpp
// N皇后：逐行填，知道当前是第几行
void dfs(int row) {  // ✅ 需要row参数
    if(row == n) {
        ret.push_back(board);
        return;
    }
    
    for(int c = 0; c < n; c++) {  // 当前行，遍历所有列
        if(!col[c] && !diag1[row-c+n] && !diag2[row+c]) {
            board[row][c] = 'Q';
            // 标记...
            dfs(row + 1);  // ← 填下一行
            // 恢复...
        }
    }
}
```

**为什么需要row？**
- 选择是**有序的**：第0行→第1行→...→第n-1行
- 每行必须恰好放1个皇后
- row告诉我们"当前在第几行"

**决策树**（n=4）：
```
row=0
├─ 放(0,0) → row=1
│   ├─ 放(1,2) → row=2
│   │   └─ 放(2,1) → row=3
│   │       └─ ...
...
逐行推进，row记录进度
```

---

##### **解数独：需要pos（格子编号）**

```cpp
// 解数独：逐格填，知道当前是第几个格子
bool dfs(int pos) {  // ✅ 需要pos参数
    if(pos >= 81) {
        return true;
    }
    
    int i = pos / 9;
    int j = pos % 9;
    
    if(board[i][j] != '.') {
        return dfs(pos + 1);  // 跳过已填的
    }
    
    for(int num = 1; num <= 9; num++) {  // 尝试填1-9
        if(!row[i][num] && !col[j][num] && !grid[i/3][j/3][num]) {
            // 填num...
            if(dfs(pos + 1)) return true;  // ← 填下一个格子
            // 恢复...
        }
    }
    return false;
}
```

**为什么需要pos？**
- 选择是**有序的**：格子0→格子1→...→格子80（从左到右、从上到下）
- 每个空格都要填
- pos告诉我们"当前填到第几个格子"

**决策树**（简化）：
```
pos=0: (0,0)='5' → 跳过 → pos=1
pos=1: (0,1)='3' → 跳过 → pos=2
pos=2: (0,2)='.' → 尝试1-9
  ├─ 填1 → pos=3
  │   └─ ...
  ├─ 填2 → pos=3
  ...
逐格推进，pos记录进度
```

---

##### **核心区别总结**

```
全排列：
  选择空间 = 所有未用元素（check数组控制）
  不需要位置参数（选择无序）
  
  示例：从[1,2,3]中选
    第1步：选2 → [2]
    第2步：从[1,3]中选1 → [2,1]
    第3步：从[3]中选3 → [2,1,3]
    ↑ 每次都从"剩余的"中选

N皇后：
  选择空间 = 当前行的所有列（row参数控制当前行）
  需要row参数（逐行推进）
  
  示例：4×4棋盘
    row=0：在第0行选一列 → (0,1)
    row=1：在第1行选一列 → (1,3)
    row=2：在第2行选一列 → (2,0)
    row=3：在第3行选一列 → (3,2)
    ↑ 必须按行顺序填

解数独：
  选择空间 = 当前格子的1-9（pos参数控制当前格子）
  需要pos参数（逐格推进）
  
  示例：9×9棋盘（81个格子）
    pos=0：(0,0) 已填5，跳过
    pos=1：(0,1) 已填3，跳过
    pos=2：(0,2) 是空格，尝试1-9
    pos=3：(0,3) 是空格，尝试1-9
    ...
    ↑ 必须按格子顺序填
```

**判断标准**：
- 如果是**从所有元素中选**，不需要位置参数（全排列、子集）
- 如果是**按固定顺序填**，需要位置参数（N皇后、解数独）

---

#### **2. 六大常见错误**

| 错误类型 | 错误代码 | 正确代码 |
|---|---|---|
| **1. 循环初始化** | `for(int i=9; i<9; i++)` | `for(int i=0; i<9; i++)` |
| **2. 空格判断** | `board[i][j] != '0'` | `board[i][j] != '.'` |
| **3. 坐标计算** | `i=pos/i; j=pos/j;` | `i=pos/9; j=pos%9;` |
| **4. 赋值vs比较** | `if(board[i][j] = '.')` | `if(board[i][j] != '.')` |
| **5. 数组维度** | `grid[i/3][j/3]` | `grid[i/3][j/3][num]` |
| **6. if大括号** | `if(x) 标记;` → 永远执行 | `标记;` 或 `if(x) {}`|

---

### 🎯 与N皇后的深度对比

| | **N皇后（LeetCode 51）** | **解数独（LeetCode 37）** |
|---|---|---|
| **二维空间** | n×n棋盘 | 9×9棋盘（固定） |
| **决策** | 每行放1个皇后 | 填所有空格 |
| **选择范围** | 每行n列可选 | 每格9个数字可选 |
| **约束维度** | 列、两条对角线（3个） | 行、列、宫格（3个） |
| **标记数组** | `col[n]`, `diag1[2n]`, `diag2[2n]` | `row[9][10]`, `col[9][10]`, `grid[3][3][10]` |
| **剪枝公式** | `row-col+n`, `row+col` | `i/3`, `j/3` |
| **返回值** | `void`（所有解） | `bool`（一个解） ⭐ |
| **位置参数** | `row`（行号） | `pos`（格子编号） |

**共同点**：
1. 都是**多约束排列型**回溯
2. 都需要**多个check数组**
3. 都用**数学映射**简化判断（对角线/宫格）
4. 都是**空间换时间**（标记数组）
5. 都需要**位置参数**（按固定顺序填）

**不同点**：
1. N皇后返回`void`（收集所有解），解数独返回`bool`（找到一个解就返回）
2. N皇后用`row`参数（逐行），解数独用`pos`参数（逐格）
3. N皇后约束：列+对角线，解数独约束：行+列+宫格

---

### 💡 核心总结

#### **算法思想**
1. **DFS + 回溯**：逐格尝试填数字，试错回溯
2. **剪枝优化**：用标记数组O(1)检查三个维度的冲突
3. **数学映射**：`(i, j) → pos`（一维化），`(i, j) → (i/3, j/3)`（宫格定位）
4. **提前返回**：找到解立即返回true，不继续搜索

#### **回溯模板（多约束排列型）**
```cpp
bool dfs(int pos) {
    // 1. 递归出口
    if(所有位置都填完) return true;
    
    // 2. 跳过已填的
    if(当前位置已填) return dfs(pos+1);
    
    // 3. 尝试所有选择
    for(每个可能的选择) {
        if(满足约束条件) {  // 剪枝
            做选择 + 标记;
            if(dfs(pos+1)) return true;  // 找到解，立即返回
            撤销 + 恢复;
        }
    }
    
    // 4. 所有选择都失败
    return false;
}
```

#### **易错点**
1. ❌ `for(i=9; i<9; i++)` → ✅ `for(i=0; i<9; i++)`
2. ❌ `board[i][j] != '0'` → ✅ `board[i][j] != '.'`
3. ❌ `i=pos/i; j=pos/j;` → ✅ `i=pos/9; j=pos%9;`
4. ❌ `if(x = y)` → ✅ `if(x == y)` 或 `if(x != y)`
5. ❌ `grid[i/3][j/3]` → ✅ `grid[i/3][j/3][num]`
6. ❌ 忘记 `if(dfs()) return true;` → 找到解不返回

---

### 🎓 学习心得

> **"解数独 = N皇后的标记思想 + 全排列的试错思想"**

**知识迁移**：
- **N皇后** → 学会多个check数组 + 数学映射
- **全排列** → 学会试错回溯 + 恢复现场
- **有效数独** → 学会行列宫格的标记
- **解数独** → 三者结合！

**本质**：
- **标记数组**：空间换时间，O(1)检查冲突
- **数学映射**：`pos/9`、`pos%9`、`i/3`、`j/3`
- **提前返回**：`bool`返回值 + `if(dfs()) return true`

**理解pos参数的关键**：
- 如果是"从所有元素中选"（无序） → 不需要位置参数
- 如果是"按固定顺序填"（有序） → 需要位置参数

---

**提交时间**：2025-10-28
**状态**：✅ AC
**用时**：一次通过（理解标记思想+位置参数后）
**难点**：pos坐标转换、返回值bool的正确使用

---


