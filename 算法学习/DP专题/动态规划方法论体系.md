# 动态规划方法论体系 v1.6

> **目标**：建立系统的动态规划思维模型，掌握DP解题套路

**更新日期**：2025年11月5日  
**当前版本**：v1.6 - 多状态DP模型（基于Day36进阶学习）

---

## 📋 目录

1. [动态规划的本质理解](#1-动态规划的本质理解)
2. [DP四步解题法](#2-dp四步解题法)
3. [DP模型分类](#3-dp模型分类)
4. [DP优化技巧](#4-dp优化技巧)
   - 4.1 空间优化：滚动变量
   - 4.2 取模运算技巧
   - 4.3 边界条件处理
   - 4.4 虚拟节点技巧
   - 4.5 DP方向选择（正向 vs 逆向）⭐ NEW
   - 4.6 空间优化的更新方向 ⭐ NEW
5. [DP常见错误与避坑](#5-dp常见错误与避坑)
6. [学习路线与题目推荐](#6-学习路线与题目推荐)

---

## 1. 动态规划的本质理解

### 1.1 什么是动态规划？

```
动态规划 = 递归优化 = 避免重复计算

核心思想：
1. 把大问题拆解成小问题
2. 小问题的解可以推导大问题的解
3. 存储中间结果，避免重复计算
```

### 1.2 DP三要素

```
1. 最优子结构
   - 大问题的最优解包含小问题的最优解
   
2. 重叠子问题
   - 同一个子问题被重复计算多次
   
3. 无后效性
   - 当前状态只依赖前面的状态，不依赖后面的状态
```

**举例：爬楼梯**
```
问题：爬到第10阶有多少种方法？

分解：
- 爬到第10阶 = 从第9阶爬1步 + 从第8阶爬2步
- 爬到第9阶 = 从第8阶爬1步 + 从第7阶爬2步
- ...

重复子问题：
- 计算第10阶时需要第9阶和第8阶
- 计算第9阶时也需要第8阶
- 第8阶被重复计算了！→ 需要用DP存储结果
```

---

### 1.3 DP vs 递归

**递归（自顶向下）**：
```cpp
// 斐波那契数列 - 递归实现
int fib(int n) {
    if(n <= 1) return n;
    return fib(n-1) + fib(n-2);  // 重复计算！
}
// 时间复杂度：O(2^n) - 指数级
```

**动态规划（自底向上）**：
```cpp
// 斐波那契数列 - DP实现
int fib(int n) {
    if(n <= 1) return n;
    vector<int> dp(n+1);
    dp[0] = 0, dp[1] = 1;
    for(int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // 每个状态只计算一次
    }
    return dp[n];
}
// 时间复杂度：O(n)
```

**关键区别**：

| 特性 | 递归 | 动态规划 |
|------|------|----------|
| **方向** | 自顶向下 | 自底向上 |
| **重复计算** | 大量重复 | 避免重复 |
| **时间复杂度** | 指数级 O(2^n) | 线性/多项式 O(n) |
| **空间复杂度** | 递归栈 | DP数组 |
| **实现难度** | 简单直观 | 需要思考状态 |

**记忆化搜索（Memoization）**：
```
递归 + 缓存 = 记忆化搜索
- 保持递归的写法
- 加入哈希表/数组存储已计算的结果
- 时间复杂度降到O(n)
```

---

## 2. DP四步解题法

### 核心框架 ⭐⭐⭐

**每道DP题都按这四步思考**：

```
Step 1：状态表示 (State Definition)
- dp[i] 表示什么？
- 明确问题的子问题是什么

Step 2：状态转移方程 (State Transition)
- dp[i] 如何从前面的状态推导？
- 找到递推关系

Step 3：初始化 (Initialization)
- dp[0] 或 dp[1] 等于多少？
- 哪些状态无法通过转移方程得到？

Step 4：填表顺序 (Iteration Order)
- 从左往右？从右往左？
- 二维DP：从上到下？对角线？
```

---

### 2.1 第1步：状态表示

**核心问题**：`dp[i]` 表示什么？

**常见状态定义**：
```
1. 计数问题：dp[i] = 到达状态i的方案数
   示例：爬到第i阶的方法数

2. 最优问题：dp[i] = 到达状态i的最优解（最大/最小值）
   示例：爬到第i阶的最小花费

3. 存在性问题：dp[i] = 是否能到达状态i（true/false）
   示例：是否能凑成金额i
```

**实例分析**：

| 题目 | 状态定义 | 类型 |
|------|----------|------|
| 爬楼梯 | `dp[i] = 爬到第i阶的方法数` | 计数 |
| 最小花费爬楼梯 | `dp[i] = 爬到第i阶的最小花费` | 最优 |
| 泰波那契数列 | `dp[i] = 第i个泰波那契数` | 计数 |

---

### 2.2 第2步：状态转移方程

**核心问题**：`dp[i]` 如何从前面的状态推导？

**找转移方程的思路**：
```
1. 列举当前状态的来源
2. 写出每种来源的贡献
3. 合并所有来源
```

**示例：爬楼梯**
```
问：dp[i] 怎么来的？
答：要爬到第i阶，有两种方式：
    1. 从第i-1阶爬1步
    2. 从第i-2阶爬2步

所以：dp[i] = dp[i-1] + dp[i-2]
```

**常见转移类型**：

| 类型 | 转移方程 | 示例 |
|------|----------|------|
| **加法原理** | `dp[i] = dp[i-1] + dp[i-2]` | 爬楼梯、斐波那契 |
| **最优化** | `dp[i] = min(dp[i-1], dp[i-2])` | 最小花费爬楼梯 |
| **三项递推** | `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]` | 泰波那契、三步问题 |

---

### 2.3 第3步：初始化

**核心问题**：哪些状态需要手动初始化？

**初始化原则**：
```
1. 找到无法通过转移方程得到的状态
2. 这些状态需要手动赋值
3. 通常是dp[0], dp[1], dp[2]等
```

**示例对比**：

| 题目 | 状态转移 | 初始化 |
|------|----------|--------|
| 斐波那契 | `dp[i] = dp[i-1] + dp[i-2]` | `dp[0]=0, dp[1]=1` |
| 泰波那契 | `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]` | `dp[0]=0, dp[1]=1, dp[2]=1` |
| 爬楼梯 | `dp[i] = dp[i-1] + dp[i-2]` | `dp[1]=1, dp[2]=2` |
| 三步问题 | `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]` | `dp[1]=1, dp[2]=2, dp[3]=4` |

**观察**：
```
- 泰波那契和三步问题的转移方程完全相同
- 但初始化不同，导致结果序列不同
- 初始化决定了DP的起点！
```

---

### 2.4 第4步：填表顺序

**核心问题**：从哪个方向填表？

**一维DP**：
```
通常从左往右：for(int i = start; i <= n; i++)

原因：dp[i] 依赖 dp[i-1], dp[i-2] 等前面的状态
```

**二维DP**：
```
常见填表顺序：
1. 逐行填充（从上到下，每行从左到右）
2. 对角线填充（某些区间DP）
3. 逆序填充（背包问题的空间优化）
```

---

### 2.5 DP四步法完整示例

**题目**：爬楼梯（LeetCode 70）

```cpp
class Solution {
public:
    int climbStairs(int n) {
        // Step 1：状态表示
        // dp[i] = 爬到第i阶的方法数
        
        // Step 2：状态转移方程
        // dp[i] = dp[i-1] + dp[i-2]
        
        // Step 3：初始化
        if(n == 1) return 1;
        if(n == 2) return 2;
        
        vector<int> dp(n + 1);
        dp[1] = 1, dp[2] = 2;
        
        // Step 4：填表顺序（从左往右）
        for(int i = 3; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[n];
    }
};
```

---

## 3. DP模型分类

### 模型1：斐波那契模型 ⭐⭐⭐

**适用场景**：Day31已掌握

**特征识别**：
```
✓ 当前状态只依赖前面1-3个状态
✓ 状态转移是简单的加法或min/max
✓ 一维DP数组
✓ 线性递推关系
```

**核心模式**：

#### **类型1：二项递推**
```cpp
// 模板：dp[i] = dp[i-1] + dp[i-2]
// 应用：斐波那契数列、爬楼梯

int solve(int n) {
    if(n <= 2) return /* 边界值 */;
    vector<int> dp(n + 1);
    dp[1] = /* 初始值1 */;
    dp[2] = /* 初始值2 */;
    
    for(int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

#### **类型2：三项递推**
```cpp
// 模板：dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
// 应用：泰波那契数列、三步问题

int solve(int n) {
    if(n <= 3) return /* 边界值 */;
    vector<int> dp(n + 1);
    dp[1] = /* 初始值1 */;
    dp[2] = /* 初始值2 */;
    dp[3] = /* 初始值3 */;
    
    for(int i = 4; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
    }
    return dp[n];
}
```

**已解决题目**（Day31）：
```
1. LeetCode 1137 - 泰波那契数列（三项递推）
2. 三步问题 - 爬楼梯变种（三项递推 + 取模）
```

---

### 模型2：选或不选DP（打家劫舍模型）⭐⭐⭐ NEW

**适用场景**：Day36掌握

**特征识别**：
```
✓ 每个元素有"选"或"不选"两种选择
✓ 选择之间有约束（如相邻不能同时选）
✓ 求最优解（最大值/最小值）
✓ 需要追踪"选择状态"
```

---

#### **思维流程：从看到题目到写出代码** ⭐⭐⭐

**Step 1：识别DP类型**
```
题目关键词：
✅ "每个元素可选可不选"
✅ "相邻元素不能同时选"（或类似约束）
✅ "最大化/最小化"（求最优）

信号：约束 + 最优 + 选择 → "选或不选"DP
```

**Step 2：设计状态定义（关键！）**
```
❌ 错误：dp[i] = 前i个元素的最优解
   问题：信息不够，不知道第i个是否被选

✅ 正确：双状态DP
   f[i]：前i个元素中，选择第i个的最优解
   g[i]：前i个元素中，不选择第i个的最优解

关键思维：
- 状态定义要包含"决策信息"（选或不选）
- 不仅记录"最优值"，还记录"达到最优值的方式"
- 后续转移需要什么信息？→ 需要知道"前一个的选择状态"
```

**Step 3：推导状态转移**
```
推导技巧：问自己3个问题

对于f[i]（选择第i个）：
问题1：选第i个，有什么约束？
问题2：那从哪个状态转移？
问题3：转移方程是什么？

对于g[i]（不选第i个）：
问题1：不选第i个，有什么约束？
问题2：那从哪个状态转移？
问题3：转移方程是什么？
```

---

#### **经典案例：打家劫舍/按摩师** ⭐⭐⭐

**问题描述**：
```
给定数组nums，每个元素代表价值
约束：不能选择相邻的元素
目标：求最大价值和
```

**状态定义**：
```cpp
f[i]：前i个元素中，选择第i个的最大价值
g[i]：前i个元素中，不选择第i个的最大价值
```

**状态转移推导**：
```
f[i]（选择第i个）：
- 约束：第i-1个不能选
- 转移：只能从g[i-1]
- 方程：f[i] = g[i-1] + nums[i]

g[i]（不选择第i个）：
- 约束：无（第i-1个可选可不选）
- 转移：可以从f[i-1]或g[i-1]
- 方程：g[i] = max(f[i-1], g[i-1])
```

**代码模板**：
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        
        // 1. 创建两个dp表
        vector<int> f(n);  // 选第i个
        vector<int> g(n);  // 不选第i个
        
        // 2. 初始化
        f[0] = nums[0];    // 选第0个
        g[0] = 0;          // 不选第0个
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            f[i] = g[i-1] + nums[i];      // 选i，i-1不能选
            g[i] = max(f[i-1], g[i-1]);   // 不选i，i-1随意
        }
        
        // 4. 返回值
        return max(f[n-1], g[n-1]);  // 最后一个可选可不选
    }
};
```

**空间优化（O(1)）**：
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;
        
        int f = nums[0], g = 0;  // 滚动变量
        
        for(int i = 1; i < n; i++) {
            int new_f = g + nums[i];
            int new_g = max(f, g);
            f = new_f;
            g = new_g;
        }
        
        return max(f, g);
    }
};
```

---

#### **为什么双状态DP是正确的？** ⭐⭐⭐

**核心原理**：
```
1. 状态定义完整
   - f[i]：明确第i个被选
   - g[i]：明确第i个没被选
   - 两种状态覆盖所有可能

2. 转移逻辑严密
   - 选第i个 → 必须从"不选i-1"转移（f[i]=g[i-1]+nums[i]）
   - 不选第i个 → 可以从任意状态转移（g[i]=max(f[i-1],g[i-1])）

3. 保留足够信息
   - 同时维护两种状态
   - 后续转移时，能根据约束选择正确的前驱状态

4. 最优子结构
   - f[i]的最优 = g[i-1]的最优 + nums[i]
   - g[i]的最优 = max(f[i-1], g[i-1])
```

**图示理解**：
```
数组：[2, 7, 9, 3]

i=0:
f[0]=2 ← 选0，得2
g[0]=0 ← 不选0，得0

i=1:
f[1]=g[0]+7=7 ← 选1（不能选0）
g[1]=max(2,0)=2 ← 不选1（保持之前最优）

i=2:
f[2]=g[1]+9=11 ← 选2（之前不选1，选了0）
g[2]=max(7,2)=7 ← 不选2（之前选了1）

i=3:
f[3]=g[2]+3=10 ← 选3
g[3]=max(11,7)=11 ← 不选3（保持f[2]）

答案：max(10,11)=11
方案：选0，不选1，选2，不选3 → 2+9=11 ✅
```

---

#### **与单数组DP的对比**

```
单数组写法：dp[i] = max(dp[i-1], dp[i-2] + nums[i])

双状态写法：f[i] = g[i-1] + nums[i]
           g[i] = max(f[i-1], g[i-1])

对比：
| 特性 | 单数组DP | 双状态DP |
|-----|---------|---------|
| 状态定义 | 前i个最优（抽象） | 明确"选"和"不选" |
| 思路清晰度 | 需要理解技巧 | 非常直观 ✅ |
| 代码简洁度 | 更简洁 ✅ | 稍长 |
| 扩展性 | 基础情况 | 容易扩展到多状态 ✅ |
| 学习阶段 | 适合熟练后 | 适合学习理解 ✅ |
```

---

#### **核心思维总结**

```
"选或不选"DP的核心思维：

1. 状态要"细化"
   - 不只记录"最优值"
   - 还要记录"选择方式"
   
2. 从约束推导转移
   - 列出当前选择
   - 分析约束条件
   - 确定可转移的前驱状态
   
3. 验证状态完备性
   - 所有可能的情况都被覆盖
   - 第i个只有"选"和"不选"两种
   
4. 保留足够信息
   - 后续转移需要知道"前一个的选择"
   - 所以必须同时维护两种状态
```

**口诀**：
```
1. 识别模型：约束+最优+选择
2. 设计状态：包含决策信息
3. 推导转移：根据约束分析
4. 初始化：第一个元素两种选择
5. 填表返回：从前往后，最后取max
```

---

#### **环形数组问题扩展** ⭐⭐⭐ NEW

**问题场景**：打家劫舍II - 环形数组

**核心约束**：
```
线性数组：第0个和第n-1个不相邻
环形数组：第0个和第n-1个相邻（首尾相连）
```

**解决思路：问题转化** ⭐⭐⭐

```
环形约束的本质：第0个和第n-1个不能同时选

转化方法：
Step 1：识别首尾约束
Step 2：枚举第0个的选择
        - 选第0个 → 第n-1个不能选 → 问题变成 [0, n-2]
        - 不选第0个 → 第n-1个可以选 → 问题变成 [1, n-1]
Step 3：两个子问题都是线性数组，用打家劫舍I解决
Step 4：答案 = max(子问题1, 子问题2)

关键：环形问题 → 枚举边界 → 线性问题
```

**代码实现**：
```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return nums[0];
        if(n == 2) return max(nums[0], nums[1]);
        
        // 情况1：选0，不选n-1
        int res1 = robRange(nums, 0, n-2);
        // 情况2：不选0，可选n-1
        int res2 = robRange(nums, 1, n-1);
        
        return max(res1, res2);
    }
    
    // 打家劫舍I的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if(start > end) return 0;
        if(start == end) return nums[start];
        
        int len = end - start + 1;  // 长度计算
        vector<int> f(len), g(len);
        
        f[0] = nums[start];
        g[0] = 0;
        
        for(int i = 1; i < len; i++) {
            f[i] = g[i-1] + nums[start + i];  // 索引映射
            g[i] = max(f[i-1], g[i-1]);
        }
        
        return max(f[len-1], g[len-1]);
    }
};
```

**关键技巧**：

1. **长度计算**
   ```cpp
   int len = end - start + 1;  // [start, end]的长度
   ```

2. **索引映射**
   ```cpp
   // dp数组索引i 对应 原数组索引 start+i
   f[i] = g[i-1] + nums[start + i];
   ```

3. **边界处理**
   ```cpp
   if(n == 1) return nums[0];
   if(n == 2) return max(nums[0], nums[1]);
   ```

**思维扩展**：
```
环形数组的通用解法：
- 环形最大子数组和（LeetCode 918）
- 环形房屋涂色
- 环形任务调度

核心思想：枚举边界 + 问题转化
```

---

#### **已解决题目**（Day36 - 基础）
```
1. 面试题 17.16 - 按摩师（双状态DP基础）
2. LeetCode 198 - 打家劫舍（同按摩师）
3. LeetCode 213 - 打家劫舍 II（环形数组转化）⭐⭐⭐
4. LeetCode 740 - 删除并获得点数（问题转化）⭐⭐⭐
```

---

### 模型2.5：多状态DP（状态扩展）⭐⭐⭐ NEW

**适用场景**：Day36进阶

**核心思想**：
```
双状态DP：2个状态（选/不选）
多状态DP：k个状态（k种选择）

本质：
- 双状态是多状态的特例（k=2）
- 状态数量由"选择的种类"决定
- 转移方程由"约束条件"决定
```

---

#### **从双状态到多状态的演变** ⭐⭐⭐

```
打家劫舍：2个状态
├─ f[i]：选第i个
└─ g[i]：不选第i个

粉刷房子：3个状态
├─ dp[i][0]：第i个房子刷红色
├─ dp[i][1]：第i个房子刷蓝色
└─ dp[i][2]：第i个房子刷绿色

股票问题：多个状态
├─ f[i]：第i天持有股票
├─ g[i]：第i天不持有且不在冷冻期
└─ h[i]：第i天不持有且在冷冻期
```

**关键观察**：
```
状态数量 = 有效的选择数量

打家劫舍：选 or 不选 → 2个状态
粉刷房子：红 or 蓝 or 绿 → 3个状态
粉刷房子II：k种颜色 → k个状态
股票问题：持有/不持有/冷冻 → 根据约束设计
```

---

#### **经典案例1：粉刷房子（三状态DP）** ⭐⭐⭐

**问题描述**：
```
n个房子，每个可以刷红/蓝/绿三种颜色
约束：相邻房子不能同色
目标：最小化总成本
```

**状态定义**：
```cpp
dp[i][0] = 第i个房子刷红色的最小成本
dp[i][1] = 第i个房子刷蓝色的最小成本
dp[i][2] = 第i个房子刷绿色的最小成本
```

**状态转移推导**：
```
第i个房子刷红色（颜色0）：
- 约束：第i-1个房子不能刷红色
- 可选：蓝色或绿色
- 转移：dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2])

第i个房子刷蓝色（颜色1）：
- 约束：第i-1个房子不能刷蓝色
- 可选：红色或绿色
- 转移：dp[i][1] = costs[i][1] + min(dp[i-1][0], dp[i-1][2])

第i个房子刷绿色（颜色2）：
- 约束：第i-1个房子不能刷绿色
- 可选：红色或蓝色
- 转移：dp[i][2] = costs[i][2] + min(dp[i-1][0], dp[i-1][1])

规律：
dp[i][j] = costs[i][j] + min(dp[i-1][其他两个颜色])
```

**代码模板**：
```cpp
class Solution {
public:
    int minCost(vector<vector<int>>& costs) {
        int n = costs.size();
        if(n == 0) return 0;
        
        // 1. 创建dp表（n × 3）
        vector<vector<int>> dp(n, vector<int>(3));
        
        // 2. 初始化
        dp[0][0] = costs[0][0];
        dp[0][1] = costs[0][1];
        dp[0][2] = costs[0][2];
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2]);
            dp[i][1] = costs[i][1] + min(dp[i-1][0], dp[i-1][2]);
            dp[i][2] = costs[i][2] + min(dp[i-1][0], dp[i-1][1]);
        }
        
        // 4. 返回答案（3种颜色的最小值）
        return min({dp[n-1][0], dp[n-1][1], dp[n-1][2]});
    }
};
```

**空间优化（O(1)）**：
```cpp
class Solution {
public:
    int minCost(vector<vector<int>>& costs) {
        int n = costs.size();
        if(n == 0) return 0;
        
        // 只用6个变量（上一个房子3个，当前房子3个）
        int prev_0 = costs[0][0];
        int prev_1 = costs[0][1];
        int prev_2 = costs[0][2];
        
        for(int i = 1; i < n; i++) {
            int curr_0 = costs[i][0] + min(prev_1, prev_2);
            int curr_1 = costs[i][1] + min(prev_0, prev_2);
            int curr_2 = costs[i][2] + min(prev_0, prev_1);
            
            prev_0 = curr_0;
            prev_1 = curr_1;
            prev_2 = curr_2;
        }
        
        return min({prev_0, prev_1, prev_2});
    }
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(1)（优化后）

---

#### **经典案例2：买卖股票含冷冻期（多状态DP）** ⭐⭐⭐

**问题描述**：
```
可以多次买卖股票
约束：卖出后的第二天不能买入（冷冻期）
目标：最大化利润
```

**状态定义**：
```cpp
f[i] = 第i天持有股票的最大利润
g[i] = 第i天不持有股票且不在冷冻期的最大利润
h[i] = 第i天不持有股票且在冷冻期的最大利润（今天卖出）
```

**状态转移推导**：
```
f[i]（持有股票）：
- 来源1：昨天就持有，今天不操作 → f[i-1]
- 来源2：昨天不在冷冻期，今天买入 → g[i-1] - prices[i]
  （注意：不能从h买入，因为h是冷冻期！）
- 转移：f[i] = max(f[i-1], g[i-1] - prices[i])

h[i]（在冷冻期，今天卖出）：
- 来源：昨天持有，今天卖出 → f[i-1] + prices[i]
- 转移：h[i] = f[i-1] + prices[i]

g[i]（不在冷冻期，可以买入）：
- 来源1：昨天也不在冷冻期 → g[i-1]
- 来源2：昨天在冷冻期，今天结束 → h[i-1]
- 转移：g[i] = max(g[i-1], h[i-1])
```

**关键理解** ⭐⭐⭐：
```
冷冻期的定义：
- 冷冻期 = 卖出后的第二天
- 限制：冷冻期当天不能买入（不是不能卖！）

h[i]的含义：
- 第i天在冷冻期 = 第i天卖出股票
- 第i+1天才是真正的冷冻期（不能买入）
```

**代码模板**：
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        
        // 1. 创建dp表
        vector<int> f(n);  // 持有股票
        vector<int> g(n);  // 不持有且不在冷冻期
        vector<int> h(n);  // 不持有且在冷冻期
        
        // 2. 初始化
        f[0] = -prices[0];  // 第0天买入，花费prices[0]
        g[0] = 0;            // 第0天不操作
        h[0] = 0;            // 第0天不可能在冷冻期
        
        // 3. 填表
        for(int i = 1; i < n; i++) {
            f[i] = max(f[i-1], g[i-1] - prices[i]);  // 持有
            h[i] = f[i-1] + prices[i];                // 卖出（进入冷冻期）
            g[i] = max(g[i-1], h[i-1]);               // 不在冷冻期
        }
        
        // 4. 返回答案（最后一天不持有股票的最大利润）
        return max(g[n-1], h[n-1]);
    }
};
```

**空间优化（O(1)）**：
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        if(n == 0) return 0;
        
        int f = -prices[0];  // 持有
        int g = 0;            // 不持有不在冷冻期
        int h = 0;            // 不持有在冷冻期
        
        for(int i = 1; i < n; i++) {
            int new_f = max(f, g - prices[i]);
            int new_h = f + prices[i];
            int new_g = max(g, h);
            
            f = new_f;
            h = new_h;
            g = new_g;
        }
        
        return max(g, h);
    }
};
```

**时间复杂度**：O(n)  
**空间复杂度**：O(1)（优化后）

---

#### **多状态DP的统一模板** ⭐⭐⭐

**Step 1：识别状态数量**
```
问题：
- 打家劫舍：选/不选 → 2个状态
- 粉刷房子：3种颜色 → 3个状态
- 粉刷房子II：k种颜色 → k个状态
- 股票问题：根据约束设计 → 3+个状态

规律：有几种有效的选择 → 就需要几个状态
```

**Step 2：定义状态含义**
```cpp
// 一维DP（位置决定状态）
f[i] = 第i个位置，选择状态A的最优解
g[i] = 第i个位置，选择状态B的最优解
h[i] = 第i个位置，选择状态C的最优解

// 二维DP（位置×选择）
dp[i][j] = 第i个位置，选择第j种状态的最优解
```

**Step 3：分析状态转移**
```
对于每个状态，问3个问题：
1. 这个状态有什么约束？
2. 可以从哪些前驱状态转移？
3. 转移方程是什么？

通用形式：
dp[i][j] = 当前成本/价值 + 前面允许的状态的最优解
```

**Step 4：初始化和答案**
```
初始化：dp[0][所有状态]
答案：max/min(dp[n-1][所有状态])
```

---

#### **与双状态DP的对比**

| 特性 | 双状态DP | 多状态DP |
|------|---------|---------|
| 状态数量 | 2个（选/不选） | k个（k种选择） |
| 状态定义 | f[i]选, g[i]不选 | dp[i][0..k-1] |
| 转移复杂度 | 简单（2→2） | 复杂（k→k） |
| 空间 | O(n) 或 O(1) | O(n×k) 或 O(k) |
| 适用场景 | 二元选择 | 多元选择 |

**共同点**：
- 都需要维护多个状态
- 都根据约束进行转移
- 都可以空间优化（滚动变量）

**递进关系**：
```
双状态DP（k=2）
    ↓
三状态DP（k=3，粉刷房子）
    ↓
k状态DP（粉刷房子II）
    ↓
复杂多状态DP（股票问题，状态之间有复杂转换）
```

---

#### **核心思维总结**

**1. 状态设计的原则**
```
原则1：状态要完备
- 覆盖所有可能的选择
- 粉刷房子：3种颜色 → 3个状态

原则2：状态要区分
- 不同状态有明确区别
- 股票问题：持有/不持有/冷冻期

原则3：状态要包含足够信息
- 后续转移需要知道"当前选择"
- 不能只记录最优值，还要记录选择
```

**2. 转移分析的方法**
```
对于dp[i][j]：
Step 1：明确状态j的含义
Step 2：列出状态j的约束条件
Step 3：找出可以转移到状态j的前驱状态
Step 4：写出转移方程

例子（粉刷房子）：
- dp[i][0]：第i个房子刷红色
- 约束：第i-1个房子不能刷红色
- 可选：蓝色(1)或绿色(2)
- 转移：dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2])
```

**3. 空间优化的通用方法**
```
观察：如果dp[i]只依赖dp[i-1]
优化：用2组变量滚动

// k个状态
prev[0], prev[1], ..., prev[k-1]  // 上一个位置
curr[0], curr[1], ..., curr[k-1]  // 当前位置

// 每轮更新后
prev = curr
```

---

#### **已解决题目**（Day36 - 进阶）
```
5. LeetCode 256 - 粉刷房子（三状态DP）⭐⭐⭐
6. LeetCode 309 - 买卖股票含冷冻期（多状态DP）⭐⭐⭐
```

---

### 模型3：背包问题

（待补充）

---

### 模型4：线性DP

（待补充）

---

### 模型5：区间DP

（待补充）

---

### 模型6：树形DP

（待补充）

---

### 模型7：状态压缩DP

（待补充）

---

## 4. DP优化技巧

### 4.1 空间优化：滚动变量 ⭐⭐⭐

**适用场景**：`dp[i]` 只依赖前面固定的几个状态

**优化原理**：
```
原始：dp[0], dp[1], dp[2], ..., dp[n]  // 需要n+1个空间

优化：只用固定的几个变量滚动
     a      b      c      d
    ↓      ↓      ↓      ↓
  dp[i-3] dp[i-2] dp[i-1] dp[i]
```

---

#### **示例1：斐波那契数列（2个变量）**

**未优化版本**：
```cpp
int fib(int n) {
    if(n <= 1) return n;
    vector<int> dp(n + 1);  // O(n) 空间
    dp[0] = 0, dp[1] = 1;
    for(int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

**优化版本**：
```cpp
int fib(int n) {
    if(n <= 1) return n;
    int a = 0, b = 1, c = 0;  // O(1) 空间
    for(int i = 2; i <= n; i++) {
        c = a + b;
        a = b;  // 滚动
        b = c;
    }
    return c;
}
```

---

#### **示例2：泰波那契数列（3个变量）**

**未优化版本**：
```cpp
int tribonacci(int n) {
    if(n == 0) return 0;
    if(n == 1 || n == 2) return 1;
    vector<int> dp(n + 1);  // O(n) 空间
    dp[0] = 0, dp[1] = dp[2] = 1;
    for(int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
    }
    return dp[n];
}
```

**优化版本**：
```cpp
int tribonacci(int n) {
    if(n == 0) return 0;
    if(n == 1 || n == 2) return 1;
    int a = 0, b = 1, c = 1, d = 0;  // O(1) 空间
    for(int i = 3; i <= n; i++) {
        d = a + b + c;
        a = b;  // 滚动操作
        b = c;
        c = d;
    }
    return d;
}
```

**滚动过程图解**：
```
i=3: a=0, b=1, c=1  →  d=0+1+1=2  →  a=1, b=1, c=2
i=4: a=1, b=1, c=2  →  d=1+1+2=4  →  a=1, b=2, c=4
i=5: a=1, b=2, c=4  →  d=1+2+4=7  →  a=2, b=4, c=7
...
```

---

#### **优化步骤总结**

```
Step 1：观察依赖关系
- 找出 dp[i] 依赖哪几个状态
- 示例：dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
         → 依赖前3个状态

Step 2：确定变量个数
- 依赖k个状态 → 需要k+1个变量
- 依赖2个 → 3个变量（a, b, c）
- 依赖3个 → 4个变量（a, b, c, d）

Step 3：替换数组访问
- dp[i-3] → a
- dp[i-2] → b
- dp[i-1] → c
- dp[i]   → d

Step 4：滚动更新
每次计算完d后：
a = b;
b = c;
c = d;
```

---

### 4.2 取模运算技巧 ⭐⭐⭐

**场景**：结果可能很大，需要对 `1e9+7` 取模

**常见错误**：
```cpp
// ❌ 错误：先加再取模（可能溢出）
dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % MOD;
```

**正确做法**：
```cpp
// ✅ 正确：分步取模（避免溢出）
dp[i] = ((dp[i-1] + dp[i-2]) % MOD + dp[i-3]) % MOD;
```

---

#### **取模原理**

```
模运算的加法性质：
(a + b + c) % MOD = ((a + b) % MOD + c) % MOD

优势：
- 避免中间结果溢出
- 每次加法后立即取模，保持结果在int范围内
```

---

#### **实际应用：三步问题**

```cpp
class Solution {
public:
    int waysToStep(int n) {
        const int MOD = 1e9 + 7;
        
        if(n == 1 || n == 2) return n;
        if(n == 3) return 4;
        
        vector<int> dp(n + 1);
        dp[1] = 1, dp[2] = 2, dp[3] = 4;
        
        for(int i = 4; i <= n; i++) {
            // 分步取模，避免溢出
            dp[i] = ((dp[i-1] + dp[i-2]) % MOD + dp[i-3]) % MOD;
        }
        
        return dp[n];
    }
};
```

---

#### **取模注意事项**

```
1. 及时取模
   - 每次加法后立即取模
   - 不要等到最后才取模

2. 注意减法
   - 减法可能出现负数
   - 正确写法：(a - b + MOD) % MOD

3. 乘法取模
   - 大数相乘：(1LL * a * b) % MOD
   - 先转long long，再取模

4. 除法取模
   - 需要用逆元
   - (a / b) % MOD ≠ (a % MOD) / (b % MOD)
```

---

### 4.3 边界条件处理

**两种处理方式**：

#### **方法1：提前返回**
```cpp
int solve(int n) {
    if(n == 1 || n == 2) return n;
    if(n == 3) return 4;
    
    vector<int> dp(n + 1);
    dp[1] = 1, dp[2] = 2, dp[3] = 4;
    // ...
}
```

**优点**：简洁清晰  
**缺点**：多个if语句

---

#### **方法2：统一初始化**
```cpp
int solve(int n) {
    vector<int> dp(n + 1);
    if(n >= 1) dp[1] = 1;
    if(n >= 2) dp[2] = 2;
    if(n >= 3) dp[3] = 4;
    
    for(int i = 4; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
    }
    return dp[n];
}
```

**优点**：统一处理  
**缺点**：需要判断n的范围

---

**选择建议**：
```
- 边界条件简单（1-2个）→ 方法1（提前返回）
- 边界条件复杂（3+个）→ 方法2（统一初始化）
```

---

### 4.4 虚拟节点技巧（哨兵节点）⭐⭐⭐

**Day32新增：解码方法（LeetCode 91）核心技巧**

#### **什么是虚拟节点？**

```
在dp数组的开头额外添加一个位置dp[0]，不对应实际数据，
作为"空状态"，用于简化边界条件的处理。
```

---

#### **为什么需要虚拟节点？**

**问题场景**：字符串DP中，状态转移可能依赖"前面没有字符"的情况

**示例**：解码方法（LeetCode 91）

```
s = "12"

如果"12"可以组合解码为"L"，这种方法应该加到哪里？
→ 应该加上"前面0个字符时的方法数"
→ 需要dp[0]来表示这个状态
```

---

#### **虚拟节点的初始化**

**关键问题**：`dp[0]` 应该赋什么值？

```
答案：根据状态转移方程，dp[0]的值要保证后续填表正确
```

**示例1：解码方法**
```cpp
vector<int> dp(n + 1);
dp[0] = 1;  // 空字符串有1种解码方法

为什么是1？
- 当前两个字符可以组合时：dp[2] += dp[0]
- 如果dp[0]=0，组合解码的方法就丢失了
- dp[0]=1 表示"整体组合时，前面没字符的情况贡献1种方法"
```

**示例2：最小花费爬楼梯**
```cpp
vector<int> dp(n + 1);
dp[0] = 0;  // 起点不需要花费
dp[1] = 0;  // 也可以从位置1开始
```

---

#### **索引映射关系** ⭐⭐⭐

使用虚拟节点后，**dp数组索引**和**数据索引**不一致：

```
数据（字符串/数组）：s[0]    s[1]    s[2]    ...  s[n-1]
                      ↓       ↓       ↓            ↓
dp数组索引：         dp[1]   dp[2]   dp[3]   ...  dp[n]
                     ↑
                 dp[0]（虚拟节点）

关键映射：
dp[i] 对应 s[i-1]
dp[i] 表示前i个元素的结果
```

---

#### **代码模板对比**

**无虚拟节点（dp[n]）**：
```cpp
int solve(string s) {
    int n = s.size();
    vector<int> dp(n);
    
    // 需要特殊处理dp[0]和dp[1]
    dp[0] = ...;
    if(n > 1) dp[1] = ...;
    
    for(int i = 2; i < n; i++) {
        dp[i] = f(dp[i-1], dp[i-2]);
    }
    return dp[n-1];
}
```

**有虚拟节点（dp[n+1]）**：
```cpp
int solve(string s) {
    int n = s.size();
    vector<int> dp(n + 1);
    
    // 初始化虚拟节点
    dp[0] = 1;  // 根据问题确定
    dp[1] = s[0] != '0';
    
    for(int i = 2; i <= n; i++) {  // 注意：i <= n
        // 注意索引映射：访问s时用s[i-1]
        if(s[i-1] != '0') 
            dp[i] += dp[i-1];
        // ...
    }
    return dp[n];
}
```

---

#### **对比总结**

| 特性 | 无虚拟节点 | 有虚拟节点 |
|------|-----------|-----------|
| **数组大小** | `dp(n)` | `dp(n+1)` |
| **dp[0]含义** | 第1个元素 | 空状态（虚拟） |
| **循环范围** | `i < n` | `i <= n` |
| **索引映射** | `dp[i] = s[i]` | `dp[i] = s[i-1]` |
| **返回值** | `dp[n-1]` | `dp[n]` |
| **边界处理** | 需要特判 | 逻辑统一 |
| **代码复杂度** | 较高 | 简洁 |

**推荐**：使用虚拟节点，代码更优雅！

---

#### **虚拟节点的通用场景**

| 问题类型 | 虚拟节点作用 | 初始化 | 示例题目 |
|---------|------------|-------|---------|
| **字符串DP** | 表示空字符串 | `dp[0]=1` | 解码方法、最长公共子序列 |
| **路径问题** | 起点的虚拟位置 | `dp[0]=0` | 最小花费爬楼梯 |
| **背包问题** | 容量为0的状态 | `dp[0]=0或1` | 0-1背包、完全背包 |
| **二维DP** | 虚拟行和虚拟列 | `dp[1][0]=1` | 不同路径、编辑距离 |

---

#### **虚拟节点在二维DP中的应用** ⭐⭐⭐ NEW

**Day33新增：二维DP虚拟节点技巧**

##### **一维 vs 二维虚拟节点对比**

```
一维DP：
数据：       arr[0]  arr[1]  arr[2]  ...  arr[n-1]
             ↓       ↓       ↓            ↓
dp数组：    dp[1]   dp[2]   dp[3]   ...  dp[n]
           ↑
        dp[0]（虚拟节点）

二维DP：
原始网格：  grid[0][0]  grid[0][1]  ...  grid[0][n-1]
            grid[1][0]  grid[1][1]  ...  grid[1][n-1]
            ...
            grid[m-1][0] ... grid[m-1][n-1]

dp数组（多开一行一列）：
           dp[0][0]  dp[0][1]  dp[0][2]  ...  dp[0][n]   ← 虚拟行
           dp[1][0]  dp[1][1]  dp[1][2]  ...  dp[1][n]
              ↑                ↓                ↓
            虚拟列          grid[0][0]      grid[0][1]
           dp[2][0]  dp[2][1]  dp[2][2]  ...  dp[2][n]
                                ↓                ↓
                            grid[1][0]      grid[1][1]
           ...
           dp[m][0]  dp[m][1]  ...           dp[m][n]
                                               ↓
                                          grid[m-1][n-1]
```

##### **索引映射关系** ⚠️

```
关键映射：
dp[i][j] 对应 grid[i-1][j-1]
dp[i][j] 表示从起点到 grid[i-1][j-1] 的结果
```

**常见错误**：
```cpp
// ❌ 错误1：两个维度都写成j
if(grid[j-1][j-1] == 0)  

// ❌ 错误2：忘记-1
if(grid[i][j] == 0)

// ✅ 正确
if(grid[i-1][j-1] == 0)
```

##### **初始化技巧** ⭐⭐⭐

**问题**：二维DP的虚拟节点 `dp[0][x]` 和 `dp[x][0]` 如何初始化？

**答案**：根据问题类型和状态转移，选择合适的初始化策略

---

**场景1：路径计数问题**
```cpp
// 例如：不同路径（LeetCode 62）
vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
dp[1][0] = 1;  // 或者 dp[0][1] = 1

// 目标：dp[1][1] = dp[0][1] + dp[1][0] = 0 + 1 = 1  ✅
// 两种都可以，只需保证其中一个为1即可！
```

**场景2：求最大值问题**
```cpp
// 例如：礼物最大价值（LCR 166）
vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
// 不需要特殊设置！max运算天然兼容0
```

**场景3：求最小值问题 - 固定起点/终点** ⭐ NEW
```cpp
// 例如：最小路径和（LeetCode 64）
vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
dp[0][1] = dp[1][0] = 0;  // 必须特殊设置！

// 为什么？
// 不设置：dp[1][1] = min(INT_MAX, INT_MAX) + grid[0][0]  ❌ 溢出！
// 设置后：dp[1][1] = min(0, 0) + grid[0][0]  ✅ 正确！
```

**场景4：求最小值问题 - 任意起点/终点** ⭐ NEW
```cpp
// 例如：下降路径最小和（LeetCode 931）
vector<vector<int>> dp(n+1, vector<int>(n+2, INT_MAX));
for(int j = 0; j < n+2; j++) dp[0][j] = 0;  // 虚拟行为0
// 虚拟列保持INT_MAX（边界外不可达）
```

**初始化策略总结**：

| 问题类型 | 初始化策略 | 起点特殊处理 | 典型题目 |
|---------|----------|------------|---------|
| **计数问题** | 全部=0 | `dp[1][0]=1` 或 `dp[0][1]=1` | 不同路径 II |
| **求最大值** | 全部=0 | 不需要 ✅ | 礼物最大价值 |
| **求最小值（固定起终点）** | 全部=INT_MAX | `dp[0][1]=dp[1][0]=0` ❗ | 最小路径和 |
| **求最小值（任意起终点）** | 虚拟行=0，虚拟列=INT_MAX | 不需要 | 下降路径最小和 |

##### **代码模板**

**无虚拟节点（复杂）**：
```cpp
int solve(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    
    // 需要特殊处理第一行和第一列
    dp[0][0] = grid[0][0];
    for(int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
    for(int j = 1; j < n; j++) dp[0][j] = dp[0][j-1] + grid[0][j];
    
    // 填表
    for(int i = 1; i < m; i++) {
        for(int j = 1; j < n; j++) {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
        }
    }
    return dp[m-1][n-1];
}
```

**有虚拟节点（优雅）**：
```cpp
int solve(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> dp(m+1, vector<int>(n+1));  // ⭐ 多开一行一列
    
    dp[1][0] = 1;  // 或 dp[0][1] = 1
    
    // 填表：注意范围是 1 to m, 1 to n
    for(int i = 1; i <= m; i++) {  // ⭐ i <= m
        for(int j = 1; j <= n; j++) {  // ⭐ j <= n
            // ⚠️ 关键：访问原数组时用 grid[i-1][j-1]
            if(grid[i-1][j-1] == 0) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    return dp[m][n];  // ⭐ 返回dp[m][n]
}
```

##### **代码对比总结**

| 特性 | 无虚拟节点 | 有虚拟节点 |
|------|-----------|-----------|
| **数组大小** | `dp(m, vector<int>(n))` | `dp(m+1, vector<int>(n+1))` |
| **dp[0][0]含义** | `grid[0][0]` | 虚拟节点 |
| **循环范围** | `i < m, j < n` | `i <= m, j <= n` |
| **索引映射** | `dp[i][j] = grid[i][j]` | `dp[i][j] ↔ grid[i-1][j-1]` |
| **返回值** | `dp[m-1][n-1]` | `dp[m][n]` |
| **边界处理** | 需要特殊处理第一行第一列 | 逻辑统一，无需特判 |
| **代码复杂度** | 高（需要额外的初始化循环） | 低（一个双重循环搞定） |

**强烈推荐**：二维DP使用虚拟节点，避免大量边界判断！

##### **常见题目**

| 题目 | 虚拟节点初始化 | 索引映射 |
|------|--------------|---------|
| **不同路径 II（LeetCode 63）** | `dp[1][0]=1` | `dp[i][j]` ↔ `ob[i-1][j-1]` |
| **最小路径和（LeetCode 64）** | `dp[1][0]=0, dp[0][1]=0` | `dp[i][j]` ↔ `grid[i-1][j-1]` |
| **编辑距离（LeetCode 72）** | `dp[0][j]=j, dp[i][0]=i` | `dp[i][j]` ↔ `s1[i-1], s2[j-1]` |

---

#### **实战示例：解码方法**

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n + 1);
        
        // 虚拟节点初始化
        dp[0] = 1;  // 空字符串有1种方法
        dp[1] = s[0] != '0';  // 第1个字符
        
        for(int i = 2; i <= n; i++) {
            // 单独解码（注意：访问s[i-1]）
            if(s[i-1] != '0')
                dp[i] += dp[i-1];
            
            // 组合解码（注意：访问s[i-2]和s[i-1]）
            int t = (s[i-2] - '0') * 10 + s[i-1] - '0';
            if(t >= 10 && t <= 26)
                dp[i] += dp[i-2];
        }
        
        return dp[n];
    }
};
```

**关键点**：
1. `dp(n+1)`：数组大小
2. `dp[0]=1`：技术性初始化
3. `s[i-1]`：索引映射
4. `i<=n`：循环包含n

---

### 4.5 DP方向选择（正向 vs 逆向）⭐⭐⭐

#### **什么是DP方向？**

```
DP可以有两种计算方向：

1. 正向DP（从上往下/从前往后）：
   - dp[i][j] = 从起点到 (i,j) 的最优解/状态
   - 从已知的起点推导未知的终点
   - 累积型计算（适合路径和、计数问题）
   
2. 逆向DP（从下往上/从后往前）：
   - dp[i][j] = 从 (i,j) 到终点的最优解/需求
   - 从已知的终点倒推到起点
   - 倒推型计算（适合需求推导、特定约束问题）
```

#### **为什么要选择DP方向？**

```
不同的DP方向，有两种考虑：

1. 优化性选择：两种方向都对，选边界处理更简单的
   示例：三角形最小路径和（Day34）
   
2. 必要性选择：只有一个方向正确，另一个方向根本错误
   示例：地下城游戏（Day35）⭐⭐⭐

关键判断：正向DP能否追踪题目要求的核心约束？
```

---

#### **逆向DP的必要性判断** ⭐⭐⭐ NEW (Day35)

**什么时候必须用逆向DP？**

```
判断标准：
1. 正向DP无法追踪关键约束
2. 终点状态是确定的，起点状态不确定
3. 需要保证全程满足某种约束

关键信号：
- 题目要求"最小初始值"（起点不确定）
- 题目有"全程约束"（如血量任何时刻>0）
- 正向累积计算无法反推初始需求
```

**对比分析：优化性 vs 必要性**

| 特性 | 优化性逆向DP | 必要性逆向DP |
|-----|------------|------------|
| **正向DP** | ✅ 可以做，但边界复杂 | ❌ 根本不对 |
| **逆向DP** | ✅ 可以做，边界简单 | ✅ 唯一正确方法 |
| **选择原因** | 简化边界处理 | 算法正确性要求 |
| **典型题目** | 三角形最小路径和 | 地下城游戏 |

---

#### **案例1：地下城游戏（必须逆向）** ⭐⭐⭐ NEW

**问题描述**：
```
骑士从左上角到右下角救公主
- 每个格子有正负整数（补血/扣血）
- 任何时刻血量必须 > 0
- 求最小初始血量
```

**正向DP为什么错误？** ❌

```
尝试定义：dp[i][j] = 到达(i,j)时的最大剩余血量

反例：
格子1  格子2  格子3
 -1     -2     -3
  ↓      ↓      ↓
路径A: -1 → -2 (需要初始血量3，到格子2时剩余0)
路径B: -1 → -3 (需要初始血量4，到格子2时剩余0)

问题：两条路径到达格子2时都剩余0血量
但路径A只需要初始血量3，路径B需要初始血量4！

正向DP记录"当前最大血量"，无法追踪"最小初始血量"！
```

**本质问题**：
```
正向DP记录的是"到达当前位置的状态"
但题目要求的是"从起点到终点全程合法的最小初始血量"

当前最大血量 ≠ 最小初始血量
正向DP无法处理"全程约束"（任意时刻血量>0）
```

**逆向DP为什么正确？** ✅

```
状态定义：dp[i][j] = 从(i,j)到终点所需的最小血量

为什么逆向可行：
1. 终点是确定的：到达终点后血量必须>0
2. 逆向推导是唯一的：
   - 知道"到达终点需要X血量"
   - 可以唯一确定"到达上一格需要Y血量"
3. 自动满足全程约束：
   - 每一步都确保"到达下一格有足够血量"
   - 自然保证"任意时刻血量>0"

状态转移：
dp[i][j] = min(dp[i+1][j], dp[i][j+1]) - grid[i][j]
dp[i][j] = max(1, dp[i][j])  // 保证血量>=1

初始化：
dp[m][n-1] = dp[m-1][n] = 1  // 终点相邻的虚拟节点
其他虚拟节点 = INT_MAX  // 越界位置
```

**代码实现**：
```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& d) {
        int m = d.size(), n = d[0].size();
        
        // 1. 创建dp表：多开一行一列
        vector<vector<int>> dp(m+1, vector<int>(n+1, INT_MAX));
        
        // 2. 初始化：终点相邻的虚拟节点为1
        dp[m][n-1] = 1;
        dp[m-1][n] = 1;
        
        // 3. 从右下往左上填表
        for(int i = m-1; i >= 0; i--) {
            for(int j = n-1; j >= 0; j--) {
                // 选择需要血量更少的路径
                dp[i][j] = min(dp[i+1][j], dp[i][j+1]) - d[i][j];
                // 保证血量至少为1
                dp[i][j] = max(1, dp[i][j]);
            }
        }
        
        // 4. 返回起点所需的最小血量
        return dp[0][0];
    }
};
```

**关键技巧**：

1. **max(1, dp[i][j]) 的深刻理解** ⭐⭐⭐
   ```
   不是简单的"保证非负"，而是：
   
   - 血量的物理意义：任何时刻必须>=1
   - 计算出负数的含义：当前格子补血很多，只需1滴血进入即可
   - 为什么不是max(0, ...)：因为血量必须>0，最小值是1
   - 必须每一步都检查：不能只在最后检查
   
   示例：
   当前格子+5（补血），下一步需要3滴血
   计算：dp[i][j] = 3 - 5 = -2
   修正：dp[i][j] = max(1, -2) = 1
   含义：进入时只需1滴血，补血后有6滴，足够后续使用
   ```

2. **虚拟节点初始化为1的原因** ⭐⭐⭐
   ```
   dp[m-1][n-1]（终点）的计算：
   dp[m-1][n-1] = min(dp[m][n-1], dp[m-1][n]) - d[m-1][n-1]
   dp[m-1][n-1] = max(1, dp[m-1][n-1])
   
   如果d[m-1][n-1]=-5（扣血）：
   dp = min(1,1) - (-5) = 6  ✅ 需要6滴血进入终点
   
   如果d[m-1][n-1]=+5（补血）：
   dp = min(1,1) - 5 = -4
   dp = max(1,-4) = 1  ✅ 只需1滴血进入终点
   
   初始化为1，确保终点计算正确！
   ```

---

#### **案例2：三角形问题（选择性逆向）** ⭐⭐⭐ (Day34回顾)

**三角形问题特点**：
```
     2
    3 4
   6 5 7
  4 1 8 3
```

正向DP和逆向DP都能正确计算，但边界处理复杂度不同。

**方法1：正向DP（从上往下）**

```cpp
// 状态定义：dp[i][j] = 从顶部到达 triangle[i][j] 的最小路径和

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<vector<int>> dp = triangle;
        
        // 从第1行开始填表
        for(int i = 1; i < n; i++) {
            for(int j = 0; j <= i; j++) {
                // 需要处理三种边界情况！
                if(j == 0) {
                    // 第一列：只能从上一行第一个元素来
                    dp[i][j] = dp[i-1][j] + triangle[i][j];
                } 
                else if(j == i) {
                    // 最后一列：只能从上一行最后一个元素来
                    dp[i][j] = dp[i-1][j-1] + triangle[i][j];
                } 
                else {
                    // 中间位置：可以从左上或正上来
                    dp[i][j] = min(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j];
                }
            }
        }
        
        // 需要遍历最后一行找最小值
        int ret = dp[n-1][0];
        for(int j = 1; j < n; j++) {
            ret = min(ret, dp[n-1][j]);
        }
        return ret;
    }
};
```

**缺点**：
- 需要处理三种边界情况（第一列、最后一列、中间）
- 最后需要遍历整行找最小值
- 代码复杂，容易出错

---

**方法2：逆向DP（从下往上）** ⭐ 推荐

```cpp
// 状态定义：dp[i][j] = 从 triangle[i][j] 到底部的最小路径和

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<vector<int>> dp = triangle;
        
        // 从倒数第二行开始往上填表
        for(int i = n-2; i >= 0; i--) {
            for(int j = 0; j <= i; j++) {
                // 完全不需要处理边界！每个位置都有两个下一步选择
                dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1]);
            }
        }
        
        // 答案直接就是顶部
        return dp[0][0];
    }
};
```

**优点**：
- 无需处理任何边界情况
- 状态转移统一
- 答案直接返回，不需要遍历
- 代码最简洁！

---

---

#### **DP方向选择原则总结** ⭐⭐⭐

**判断流程**：
```
Step 1：判断是否必须逆向
- 题目要求"最小初始值"且有全程约束？ → 必须逆向
- 正向DP无法追踪核心约束？ → 必须逆向
- 示例：地下城游戏（Day35）

Step 2：如果不是必须，选择边界简单的方向
- 两种方向都尝试分析边界处理
- 选择边界条件更简单的方向
- 示例：三角形问题（Day34）

Step 3：默认选择
- 大多数路径问题：从上往下（正向DP）
- 符合直觉，容易理解
```

**选择原则表**：

| 场景 | 推荐方向 | 原因 | 典型题目 |
|-----|---------|------|---------|
| **必须逆向** | 从下往上 ✅✅ | 算法正确性 | 地下城游戏 |
| **边界简单** | 优先选择 | 代码简洁 | 三角形（选逆向） |
| **起点多个，终点固定** | 从下往上 ✅ | 自然倒推 | 下降路径最小和 |
| **起点固定，终点多个** | 都可以 | 看边界 | 不同路径 |
| **大多数路径问题** | 从上往下 | 符合直觉 | 最小路径和 |

---

#### **核心思想总结**

```
逆向DP的两种应用场景：

1. 必要性逆向DP（Day35）⭐⭐⭐
   - 正向DP根本不对
   - 无法追踪核心约束
   - 题目特征：最小初始值 + 全程约束
   - 地下城游戏：当前最大血量 ≠ 最小初始血量

2. 优化性逆向DP（Day34）⭐⭐
   - 正向DP可以做，但边界复杂
   - 逆向DP简化边界处理
   - 三角形问题：逆向无需处理三种边界

关键洞察：
- 状态定义决定算法正确性
- 正向定义："到达当前的状态"（累积型）
- 逆向定义："从当前到终点的需求"（倒推型）
- 选择定义时，考虑题目核心约束
```

---

### 4.6 空间优化的更新方向 ⭐⭐⭐ NEW

#### **什么是更新方向问题？**

```
当我们把二维DP压缩成一维DP时，会遇到一个关键问题：

从左往右更新 or 从右往左更新？

这不是随意选择的，选错会导致错误答案！
```

#### **核心原理：避免"旧值"被覆盖**

```
一维数组滚动更新时，新值会覆盖旧值。

关键问题：在使用旧值之前，它还没被覆盖吗？

原则：保证依赖的"旧值"不被提前覆盖
```

---

#### **情况1：依赖"当前"和"右边"的旧值**

**典型例子：三角形最小路径和**

```cpp
// 二维版本的状态转移
dp[i][j] = triangle[i][j] + min(dp[i+1][j], dp[i+1][j+1]);
//                                 ↑           ↑
//                              当前位置      右边位置
//                           (下一行的j)   (下一行的j+1)
```

**空间优化分析**：

```
需要用到：dp[j]（旧值）和 dp[j+1]（旧值）

从左往右更新：✅
- 更新dp[0]时：用dp[0]旧值、dp[1]旧值 ✅
- 更新dp[1]时：用dp[1]旧值、dp[2]旧值 ✅
- dp[j+1]永远在dp[j]右边，还没被更新，是旧值 ✅

从右往左更新：⚠️
- 更新dp[2]时：用dp[2]旧值、dp[3]旧值 ✅
- 更新dp[1]时：用dp[1]旧值、dp[2]新值 ⚠️
- dp[j+1]已经被更新成新值了
```

**代码实现**：

```cpp
// 空间优化版本（必须从左往右）
vector<int> dp = triangle[n-1];  // 初始化为最后一行

for(int i = n-2; i >= 0; i--) {
    for(int j = 0; j <= i; j++) {  // 从左往右更新
        dp[j] = triangle[i][j] + min(dp[j], dp[j+1]);
    }
}

return dp[0];
```

**结论**：
```
状态转移：dp[j] = ... + min(dp[j], dp[j+1])
依赖关系：当前位置 + 右边（都需要旧值）

✅ 从左往右更新
❌ 从右往左更新（会提前覆盖dp[j+1]）
```

---

#### **情况2：依赖"当前"和"左边"的旧值**

**典型例子：0-1背包问题**

```cpp
// 二维版本的状态转移
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);
//              ↑               ↑
//           当前位置         左边位置
//         (上一行的j)    (上一行的j-w[i])
```

**空间优化分析**：

```
需要用到：dp[j]（旧值）和 dp[j-w[i]]（旧值）

从右往左更新：✅
- 更新dp[10]时：用dp[10]旧值、dp[7]旧值 ✅
- 更新dp[9]时： 用dp[9]旧值、 dp[6]旧值 ✅
- dp[j-w[i]]永远在dp[j]左边，还没被更新，是旧值 ✅

从左往右更新：❌
- 更新dp[3]时： 用dp[3]旧值、 dp[0]旧值 ✅
- 更新dp[6]时： 用dp[6]旧值、 dp[3]新值 ❌（重复使用物品！）
- dp[j-w[i]]已经被更新成新值了
```

**代码实现**：

```cpp
// 0-1背包空间优化（必须从右往左）
vector<int> dp(capacity + 1, 0);

for(int i = 0; i < n; i++) {
    // 必须从右往左！
    for(int j = capacity; j >= w[i]; j--) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

**结论**：
```
状态转移：dp[j] = max(dp[j], dp[j-w[i]] + v[i])
依赖关系：当前位置 + 左边（都需要旧值）

❌ 从左往右更新（会重复使用物品）
✅ 从右往左更新
```

---

#### **情况3：依赖"当前"和"左边"的新值**

**典型例子：完全背包问题**

```cpp
// 二维版本的状态转移
dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]);
//              ↑               ↑
//           上一行         当前行（新值！）
//         (不能重复)    (允许重复使用物品i)
```

**空间优化分析**：

```
需要用到：dp[j]（旧值）和 dp[j-w[i]]（新值！）

从左往右更新：✅
- 更新dp[3]时： 用dp[3]旧值、 dp[0]新值 ✅
- 更新dp[6]时： 用dp[6]旧值、 dp[3]新值 ✅（可以重复用物品i）
- 正是我们想要的！允许重复使用物品

从右往左更新：❌
- 更新dp[9]时： 用dp[9]旧值、 dp[6]旧值 ❌
- 用的是上一行的值，相当于0-1背包了
```

**代码实现**：

```cpp
// 完全背包空间优化（必须从左往右）
vector<int> dp(capacity + 1, 0);

for(int i = 0; i < n; i++) {
    // 必须从左往右！
    for(int j = w[i]; j <= capacity; j++) {
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
```

**结论**：
```
状态转移：dp[j] = max(dp[j], dp[j-w[i]] + v[i])
依赖关系：当前位置（旧值）+ 左边（新值，允许重复）

✅ 从左往右更新
❌ 从右往左更新（会变成0-1背包）
```

---

#### **判断方法：四步走**

```
Step 1：确定原始的状态转移方程
例如：dp[i][j] = ... + dp[i+1][j] + dp[i+1][j+1]

Step 2：确定哪个维度要压缩
例如：压缩第一维（行）

Step 3：分析依赖关系
dp[j] 需要用到：
- dp[j]（下一行的值，是旧值）
- dp[j+1]（下一行的值，是旧值）
依赖关系：当前位置 + 右边，都需要旧值

Step 4：确定更新方向
需要的位置在右边（j+1, j+2, ...）：
→ 从左往右更新（保证右边还是旧值）

需要的位置在左边（j-1, j-2, ...）且需要旧值：
→ 从右往左更新（保证左边还是旧值）

需要的位置在左边但允许用新值：
→ 从左往右更新（允许重复使用）
```

---

#### **典型问题对比表**

| 问题类型 | 状态转移 | 依赖关系 | 更新方向 | 原因 |
|---------|---------|---------|---------|------|
| **三角形最小路径和** | `dp[j] = min(dp[j], dp[j+1])` | 当前+右边（旧值） | 从左往右 ✅ | 保证右边是旧值 |
| **0-1背包** | `dp[j] = max(dp[j], dp[j-w]+v)` | 当前+左边（旧值） | 从右往左 ✅ | 保证左边是旧值 |
| **完全背包** | `dp[j] = max(dp[j], dp[j-w]+v)` | 当前+左边（新值） | 从左往右 ✅ | 需要左边是新值 |
| **最小路径和** | `dp[j] = min(dp[j], dp[j-1])` | 当前+左边（旧值） | 从左往右 ⚠️ | 需要额外变量 |

---

#### **记忆口诀**

```
依赖右边从左走，  ← 三角形、最大正方形
依赖左边从右走，  ← 0-1背包
左边可重从左走，  ← 完全背包
一维问题看方向。  ← 爬楼梯、打家劫舍
```

---

#### **核心思想总结**

```
空间优化的本质：
- 用一维数组模拟二维数组的"滚动更新"
- 关键是保证：用到的旧值还没被覆盖

判断方法：
1. 看状态转移依赖哪些位置
2. 判断需要旧值还是新值
3. 选择更新方向，保证依赖的值"状态正确"

记住：不是所有DP都能简单地空间优化！
有些问题需要额外变量保存旧值。
```

---

## 5. DP常见错误与避坑

### 5.1 状态定义不清

**错误示例**：
```cpp
// ❌ 不清楚dp[i]的含义
int dp[n];
for(int i = 0; i < n; i++) {
    dp[i] = dp[i-1] + dp[i-2];  // dp[i]到底表示什么？
}
```

**正确做法**：
```cpp
// ✅ 明确状态定义
// dp[i] 表示：爬到第i阶的方法数
vector<int> dp(n + 1);
dp[1] = 1, dp[2] = 2;
for(int i = 3; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2];
}
```

**避坑指南**：
```
Step 1：先写清楚dp[i]的含义（用注释）
Step 2：根据定义写转移方程
Step 3：验证转移方程是否符合定义
```

---

### 5.2 初始化错误

**错误示例1：漏初始化**
```cpp
// ❌ dp[1]和dp[2]未初始化
vector<int> dp(n + 1);
for(int i = 3; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2];  // dp[1]和dp[2]是0！
}
```

**错误示例2：初始化错误**
```cpp
// ❌ 三步问题初始化错误
dp[1] = 1, dp[2] = 2, dp[3] = 3;  // dp[3]应该是4！
```

**正确做法**：
```cpp
// ✅ 手动推导边界值
// n=1: 1种方法（1）
// n=2: 2种方法（1+1, 2）
// n=3: 4种方法（1+1+1, 1+2, 2+1, 3）
dp[1] = 1, dp[2] = 2, dp[3] = 4;
```

**避坑指南**：
```
1. 列出前几项的值，手动计算
2. 验证转移方程能否得到这些值
3. 无法通过转移方程得到的值需要初始化
```

---

### 5.3 数组越界

**错误示例**：
```cpp
// ❌ i-3可能越界
for(int i = 0; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];  // i=0,1,2时越界！
}
```

**正确做法**：
```cpp
// ✅ 从正确的起点开始
for(int i = 4; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
}
```

---

### 5.4 忘记取模

**错误示例**：
```cpp
// ❌ 结果太大，溢出
for(int i = 3; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];  // 可能溢出
}
```

**正确做法**：
```cpp
// ✅ 分步取模
const int MOD = 1e9 + 7;
for(int i = 3; i <= n; i++) {
    dp[i] = ((dp[i-1] + dp[i-2]) % MOD + dp[i-3]) % MOD;
}
```

---

### 5.5 DP vs 递归混淆

**问题**：什么时候用DP，什么时候用递归？

**选择指南**：

| 场景 | 选择 | 原因 |
|------|------|------|
| 有重叠子问题 | DP | 避免重复计算 |
| 需要记录路径 | 递归/记忆化 | 更方便回溯 |
| 空间受限 | DP（滚动优化） | 空间O(1) |
| 思路不清晰 | 递归 | 更直观 |

---

## 6. 学习路线与题目推荐

### Day31：斐波那契模型（已完成）✅

**核心掌握**：
- DP四步法
- 空间优化（滚动变量）
- 取模技巧

**题目**：
- ✅ LeetCode 1137 - 泰波那契数列
- ✅ 三步问题 - 爬楼梯变种
- ✅ LeetCode 746 - 使用最小花费爬楼梯

---

### Day32：字符串DP（已完成）✅

**核心掌握**：
- 虚拟节点技巧（一维）
- 索引映射关系
- 字符串DP的状态转移

**题目**：
- ✅ LeetCode 91 - 解码方法
- ✅ LeetCode 62 - 不同路径（基础版）

---

### Day33：二维DP路径问题（已完成）✅

**核心掌握**：
- 二维DP虚拟节点技巧 ⭐
- 二维索引映射关系（`grid[i-1][j-1]`）
- 障碍物处理

**题目**：
- ✅ LeetCode 63 - 不同路径 II

**关键突破**：
- 从一维虚拟节点扩展到二维
- 掌握最易错的下标映射问题

---

### Day34：路径问题进阶（已完成）✅

**推荐题目**：
- ✅ LeetCode 931 - 下降路径最小和（多列虚拟节点）
- ✅ LeetCode 64 - 最小路径和（最小值初始化技巧）
- 📝 LeetCode 120 - 三角形最小路径和（逆向DP + 空间优化）

**核心学习内容**：
1. **多列虚拟节点技巧** ⭐⭐⭐
   - 从1列扩展到2列虚拟边界
   - 3方向路径问题（左上、正上、右上）
   
2. **最小值问题的初始化陷阱** ⭐⭐⭐
   - 最大值问题：初始化为0，不易溢出
   - 最小值问题：初始化为INT_MAX，起点需特殊处理
   - `dp[0][1] = dp[1][0] = 0` 防止起点溢出
   
3. **逆向DP思想** ⭐⭐⭐
   - 从上往下 vs 从下往上
   - 三角形问题：逆向DP简化边界处理
   - 选择原则：哪个方向边界简单选哪个
   
4. **空间优化的更新方向** ⭐⭐⭐
   - 依赖关系分析
   - 从左往右 vs 从右往左的选择依据
   - 为背包问题打下基础

---

### Day35：逆向DP必要性（已完成）✅

**核心掌握**：
- 逆向DP的必要性判断 ⭐⭐⭐
- 正向DP vs 逆向DP的本质区别
- 状态定义对算法正确性的决定性影响
- 约束条件在DP中的处理

**题目**：
- ✅ LeetCode 174 - 地下城游戏（困难）

**关键突破**：
1. **逆向DP的必要性** ⭐⭐⭐
   - 地下城问题：正向DP根本不对
   - 当前最大血量 ≠ 最小初始血量
   - 全程约束：任意时刻血量>0
   
2. **状态定义的深刻理解**
   - 正向："到达当前的状态"（可能不够）
   - 逆向："从当前到终点的需求"（更本质）
   - 选择定义时，考虑题目核心约束
   
3. **max(1, dp[i][j])的物理意义**
   - 不是简单的边界处理
   - 是题目约束的体现（血量>=1）
   - 计算出负数的含义：补血足够，只需1滴血进入
   
4. **虚拟节点初始化灵活性**
   - 终点相邻虚拟节点=1（表示"下一步不需要血量"）
   - 其他虚拟节点=INT_MAX（表示越界）

**对比Day34**：
- Day34三角形：逆向是为了简化边界（选择性）
- Day35地下城：逆向是必需的（必要性）
- 理解了逆向DP的两种应用场景

---

### Day36："选或不选"DP模型（已完成）✅

**核心掌握**：
- "选或不选"DP的思维流程 ⭐⭐⭐
- 双状态DP的设计方法
- 从约束推导状态转移
- 状态定义要包含"决策信息"
- **环形数组问题转化** ⭐⭐⭐ NEW

**题目**：
- ✅ 面试题 17.16 - 按摩师（简单）
- ✅ LeetCode 198 - 打家劫舍（同按摩师）
- ✅ LeetCode 213 - 打家劫舍 II（环形数组）

**关键突破**：
1. **思维流程建立** ⭐⭐⭐
   - 从看到题目到写出代码的完整流程
   - 识别DP类型 → 设计状态 → 推导转移 → 代码实现
   
2. **状态定义的深刻理解**
   - 不只记录"最优值"，还记录"达到最优值的方式"
   - 双状态DP：f[i]选、g[i]不选
   - 状态信息要足够支撑后续转移
   
3. **从约束推导转移方程**
   - 问自己3个问题：约束是什么？从哪转移？方程是什么？
   - f[i]=g[i-1]+nums[i]（选i，i-1不能选）
   - g[i]=max(f[i-1],g[i-1])（不选i，i-1随意）
   
4. **为什么双状态DP是正确的**
   - 状态定义完整（覆盖所有可能）
   - 转移逻辑严密（符合约束）
   - 保留足够信息（支撑后续转移）
   - 最优子结构（符合DP性质）

5. **环形数组问题转化** ⭐⭐⭐ NEW
   - 识别首尾约束（第0个和第n-1个不能同时选）
   - 枚举边界元素的选择（选0或不选0）
   - 转化为两个线性子问题（[0,n-2]和[1,n-1]）
   - 索引映射技巧（dp[i] ← nums[start+i]）

**与之前知识的对比**：
- 路径DP（Day31-35）：状态是"位置"
- 选或不选DP（Day36）：状态是"选择"
- 环形数组：问题转化思想
- 共同点：都需要设计合适的状态定义

---

### Day37：股票问题（待学习）

（待补充）

---

## 7. 版本更新记录

### v1.6 (2025-11-05)
- 🎯 **重大更新：多状态DP模型系统建立** ⭐⭐⭐ NEW
- 🎯 **从双状态到多状态的演变路径** ⭐⭐⭐ NEW
- 🎯 **完整的多状态DP统一模板**
- ✅ 三状态DP案例（粉刷房子）
- ✅ 复杂多状态DP案例（买卖股票含冷冻期）
- ✅ 冷冻期概念的深度理解

**基于题目**：
1. LeetCode 256 - 粉刷房子（三状态DP）
2. LeetCode 309 - 买卖股票最佳时机含冷冻期（多状态DP）
3. LeetCode 740 - 删除并获得点数（问题转化）

**核心新增**：
- **模型2.5：多状态DP（状态扩展）** ⭐⭐⭐ NEW
  - 从双状态到多状态的演变
  - 状态数量 = 有效的选择数量
  - k个状态的设计原则
  - 状态转移的统一分析方法
  - 空间优化的通用模板
  
- **经典案例1：粉刷房子（三状态DP）**
  - 3种颜色 → 3个状态
  - 相邻不能同色约束
  - dp[i][j] = costs[i][j] + min(dp[i-1][其他颜色])
  - 空间优化到O(1)（6个变量）
  
- **经典案例2：买卖股票含冷冻期（多状态DP）**
  - 持有/不持有/冷冻期 → 3个状态
  - 冷冻期概念的正确理解 ⭐⭐⭐
  - 状态之间的复杂转换
  - f[i] = max(f[i-1], g[i-1] - prices[i])
  - h[i] = f[i-1] + prices[i]（今天卖出）
  - g[i] = max(g[i-1], h[i-1])（不在冷冻期）

**关键洞察**：
1. **状态扩展的系统方法** ⭐⭐⭐
   - 双状态（k=2）→ 三状态（k=3）→ k状态
   - 状态完备性：覆盖所有可能的选择
   - 状态区分性：不同状态有明确区别
   - 状态信息量：包含后续转移所需的全部信息
   
2. **冷冻期的正确理解** ⭐⭐⭐
   - 冷冻期 = 卖出后的第二天
   - 限制：冷冻期不能买入（不是不能卖！）
   - h[i]含义：第i天卖出（进入冷冻期状态）
   - 第i+1天才是真正的冷冻期
   
3. **多状态DP的统一思维**
   - Step 1：识别状态数量（几种有效选择）
   - Step 2：定义状态含义（每个状态代表什么）
   - Step 3：分析状态转移（约束→前驱→方程）
   - Step 4：初始化和答案（第0个状态，最后取最优）
   
4. **与双状态DP的递进关系**
   - 双状态是多状态的特例
   - 思路完全一致，只是状态数量不同
   - 空间优化方法通用（滚动变量）

**学习感悟**：
- 从2个状态到k个状态，本质不变
- 状态设计的三个原则：完备、区分、包含足够信息
- 问题转化能力提升（删除并获得点数→打家劫舍）
- 理解"冷冻期"等复杂约束的正确建模

**方法论成长**：
- 从"双状态DP"到"多状态DP"
- 从"简单约束"到"复杂约束"（冷冻期）
- 从"数组问题"到"股票问题"
- 建立了完整的多状态DP思维体系

---

### v1.5 (2025-11-05)
- 🎯 **重大更新："选或不选"DP模型系统建立** ⭐⭐⭐
- 🎯 **环形数组问题转化方法** ⭐⭐⭐ NEW
- 🎯 完整的思维流程：从看到题目到写出代码
- ✅ 打家劫舍系列完整解析（双状态DP + 环形数组）
- ✅ 状态定义的深刻理解（包含决策信息）
- ✅ 从约束推导转移方程的方法

**基于题目**：
1. 面试题 17.16 - 按摩师（打家劫舍变种）
2. LeetCode 198 - 打家劫舍（同按摩师）
3. LeetCode 213 - 打家劫舍 II（环形数组）

**核心新增**：
- **模型2："选或不选"DP（打家劫舍模型）**
  - 特征识别：约束+最优+选择
  - 思维流程：识别→设计→推导→实现
  - 状态设计：f[i]选、g[i]不选
  - 转移推导：从约束分析前驱状态
  - 正确性证明：4个维度分析
  - 代码模板：双状态DP + 空间优化
  
- **环形数组问题扩展** ⭐⭐⭐ NEW
  - 识别首尾约束
  - 枚举边界元素选择
  - 转化为两个线性子问题
  - 索引映射技巧（dp[i] ← nums[start+i]）
  - 长度计算（end - start + 1）
  
**关键洞察**：
1. **状态定义要"细化"** ⭐⭐⭐
   - 不只记录"最优值"
   - 还要记录"达到最优值的方式"（选或不选）
   - 后续转移需要知道"前一个的选择状态"
   
2. **从约束推导转移**
   - 问3个问题：约束？从哪转移？方程？
   - f[i]=g[i-1]+nums[i]（选i，i-1不能选）
   - g[i]=max(f[i-1],g[i-1])（不选i，i-1随意）
   
3. **双状态DP的优势**
   - 思路清晰（明确"选"和"不选"）
   - 易于理解（符合直觉）
   - 容易扩展（多状态问题）
   - 不易出错（逻辑严密）

**学习感悟**：
- 理解了DP的核心：状态定义决定一切
- 状态要包含"足够的信息"支撑后续转移
- "选或不选"是非常基础且重要的DP模型
- 从约束推导转移方程是系统性方法
- **问题转化思想**：复杂约束→简化约束（环形→线性）⭐⭐⭐

**方法论成长**：
- 从"背模板"到"理解本质"
- 从"记转移方程"到"推导转移方程"
- 从"单一状态"到"多维状态"
- 从"线性问题"到"环形问题"
- 建立了完整的思维流程

**核心技能**：
- 双状态DP设计
- 从约束推导转移
- 环形数组转化
- 索引映射处理

---

### v1.4 (2025-11-04)
- 🎯 **重大更新：逆向DP必要性深度剖析** ⭐⭐⭐
- 🎯 区分逆向DP的两种应用场景：必要性vs优化性
- ✅ 地下城游戏完整解析（正向DP错误原因 + 逆向DP正确性证明）
- ✅ max(1, dp[i][j])的物理意义深度剖析
- ✅ 虚拟节点初始化为1的原因详解

**基于题目**：
1. LeetCode 174 - 地下城游戏（困难，必须逆向）

**核心新增**：
- **4.5章节扩展：逆向DP的必要性判断**
  - 什么时候必须用逆向DP（判断标准）
  - 对比分析：优化性逆向DP vs 必要性逆向DP
  - 地下城问题：正向DP为什么错误的深度分析
  - 地下城问题：逆向DP为什么正确的证明
  - 关键技巧：
    1. max(1, dp[i][j])不是简单边界，是物理约束
    2. 虚拟节点初始化为1的数学推导
    3. 状态定义对算法正确性的决定性影响

**核心洞察**：
1. **逆向DP不只是优化，有时是必需的** ⭐⭐⭐
   - Day34三角形：逆向是为了简化（选择性）
   - Day35地下城：逆向是必需的（必要性）
   - 关键判断：正向DP能否追踪核心约束？
   
2. **状态定义决定一切**
   - 正向定义："到达当前的状态"（累积型）
   - 逆向定义："从当前到终点的需求"（倒推型）
   - 地下城展示：当前最大血量 ≠ 最小初始血量
   
3. **约束条件的DP处理**
   - 全程约束（任意时刻血量>0）必须融入状态转移
   - max(1, dp[i][j])体现物理约束
   - 不能只在边界处理，每一步都要检查

**学习感悟**：
- 地下城问题完美展示了"为什么有些问题必须用逆向DP"
- 正向DP无法追踪"最小初始血量"，因为当前状态≠初始需求
- 逆向DP从终点倒推，唯一确定每一步的需求
- 理解了DP方向选择的深层次原因

**方法论成长**：
- 从"DP可以逆向"到"DP有时必须逆向"
- 从"边界处理技巧"到"算法正确性判断"
- 从"优化选择"到"必要性理解"

---

### v1.3 (2025-11-03)
- 🎯 新增DP方向选择技巧（正向 vs 逆向）⭐⭐⭐
- 🎯 新增空间优化的更新方向分析 ⭐⭐⭐
- ✅ 完善虚拟节点初始化策略（最小值问题）
- ✅ 完成路径问题进阶（3题）

**基于题目**：
1. LeetCode 931 - 下降路径最小和（多列虚拟节点）
2. LeetCode 64 - 最小路径和（最小值初始化）
3. LeetCode 120 - 三角形最小路径和（逆向DP + 空间优化）

**核心新增**：
- **4.5 DP方向选择（正向 vs 逆向）**
  - 什么是正向/逆向DP
  - 三角形问题：两种方向的代码对比
  - DP方向选择原则和判断流程
  
- **4.6 空间优化的更新方向**
  - 核心原理：避免旧值被覆盖
  - 三种情况详解：
    1. 依赖当前+右边（从左往右）
    2. 依赖当前+左边旧值（从右往左）- 0-1背包
    3. 依赖当前+左边新值（从左往右）- 完全背包
  - 判断方法四步走
  - 典型问题对比表 + 记忆口诀

**关键突破**：
1. 虚拟节点初始化策略完全掌握：
   - 计数问题、最大值问题、最小值问题的差异
   - 最小值问题的起点溢出陷阱及解决方案
   
2. 逆向DP思想：
   - 理解DP方向可以灵活选择
   - 三角形问题展示逆向DP如何简化边界处理
   
3. 空间优化深度理解：
   - 不是简单的"把二维变一维"
   - 理解依赖关系，选择正确更新方向
   - 为背包问题打下坚实基础

**学习感悟**：
- 通过对比学习（最大值 vs 最小值）理解初始化差异
- 通过三角形问题体会逆向DP的威力
- 空间优化的本质是管理"旧值"和"新值"

---

### v1.2 (2025-11-02)
- 🎯 新增二维DP虚拟节点技巧 ⭐⭐⭐
- ✅ 掌握二维DP下标映射关系（最易错点）
- ✅ 掌握二维DP初始化技巧
- ✅ 完成路径问题模型（1题）

**基于题目**：
1. LeetCode 63 - 不同路径 II

**核心新增**：
- 二维DP虚拟节点的定义和应用
- `dp[i][j]` ↔ `grid[i-1][j-1]` 索引映射关系
- 常见错误：`grid[j-1][j-1]`（两个维度都是j）
- 有/无虚拟节点的代码对比（二维版）
- 二维DP虚拟节点速查表

**关键突破**：
- 从一维虚拟节点扩展到二维虚拟节点
- 理解虚拟节点统一边界处理的威力

---

### v1.1 (2025-11-01)
- 🎯 新增虚拟节点技巧（哨兵节点）⭐⭐⭐
- ✅ 掌握索引映射关系
- ✅ 掌握字符串DP的状态转移
- ✅ 完成字符串DP模型（1题）

**基于题目**：
1. LeetCode 91 - 解码方法

**核心新增**：
- 虚拟节点的定义和使用场景
- dp[0]初始化的技巧（技术性初始化）
- dp数组索引和字符串索引的映射关系
- 有/无虚拟节点的代码对比

---

### v1.0 (2025-10-31)
- 🎯 建立DP方法论基础框架
- ✅ 掌握DP四步法
- ✅ 掌握空间优化技巧（滚动变量）
- ✅ 掌握取模运算技巧
- ✅ 完成斐波那契模型（3题）

**基于题目**：
1. LeetCode 1137 - 泰波那契数列
2. 三步问题 - 爬楼梯变种
3. LeetCode 746 - 使用最小花费爬楼梯

---

**待完善部分**：
- [ ] 背包问题模型
- [ ] 线性DP模型
- [ ] 区间DP模型
- [ ] 树形DP模型
- [ ] 状态压缩DP模型
- [ ] 路径问题模型
- [ ] 更多优化技巧

---

## 💡 快速查询

### DP四步法速查

```
1. 状态表示：dp[i] 表示什么？
2. 状态转移：dp[i] = f(dp[i-1], dp[i-2], ...)
3. 初始化：dp[0] = ?, dp[1] = ?
4. 填表顺序：从左往右/从右往左
```

### 空间优化速查

```
依赖2个状态 → 3个变量（a, b, c）
依赖3个状态 → 4个变量（a, b, c, d）

滚动模板：
d = f(a, b, c);
a = b; b = c; c = d;
```

### 取模速查

```cpp
const int MOD = 1e9 + 7;

// 加法
dp[i] = ((a + b) % MOD + c) % MOD;

// 减法
dp[i] = (a - b + MOD) % MOD;

// 乘法
dp[i] = (1LL * a * b) % MOD;
```

### 虚拟节点速查 ⭐⭐⭐

#### **一维DP虚拟节点**

```cpp
// 数组大小：比数据长度多1
vector<int> dp(n + 1);

// 初始化：根据问题确定dp[0]的值
dp[0] = 1;  // 或 0，保证后续填表正确

// 循环：注意i <= n
for(int i = 2; i <= n; i++) {
    // 索引映射：访问数据时用data[i-1]
    if(data[i-1] != ...) {
        dp[i] += dp[i-1];
    }
}

// 返回：dp[n]
return dp[n];
```

**记忆口诀**：
```
1. dp(n+1) - 数组多开1
2. dp[0]=? - 技术性初始化
3. data[i-1] - 索引映射-1
4. i<=n - 循环包含n
```

---

#### **二维DP虚拟节点** NEW

```cpp
// 数组大小：行列都多开1
vector<vector<int>> dp(m+1, vector<int>(n+1));

// 初始化：根据问题确定虚拟边界
dp[1][0] = 1;  // 或 dp[0][1] = 1

// 循环：注意i <= m, j <= n
for(int i = 1; i <= m; i++) {
    for(int j = 1; j <= n; j++) {
        // ⚠️ 关键：访问原数组时用grid[i-1][j-1]
        if(grid[i-1][j-1] == 0) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
}

// 返回：dp[m][n]
return dp[m][n];
```

**记忆口诀**：
```
1. dp(m+1, n+1) - 行列都多开1
2. dp[1][0]=1 - 虚拟边界初始化
3. grid[i-1][j-1] - 二维索引都映射-1 ⚠️
4. i<=m, j<=n - 循环都包含边界
```

**常见错误** ❌：
```cpp
grid[j-1][j-1]  // ❌ 两个维度都是j
grid[i][j]      // ❌ 忘记-1
grid[i-1][j-1]  // ✅ 正确
```

---

**持续更新中...**

