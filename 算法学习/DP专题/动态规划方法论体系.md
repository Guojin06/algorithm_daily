# 动态规划方法论体系 v1.2

> **目标**：建立系统的动态规划思维模型，掌握DP解题套路

**更新日期**：2025年11月2日  
**当前版本**：v1.2 - 二维DP虚拟节点技巧（基于Day33学习）

---

## 📋 目录

1. [动态规划的本质理解](#1-动态规划的本质理解)
2. [DP四步解题法](#2-dp四步解题法)
3. [DP模型分类](#3-dp模型分类)
4. [DP优化技巧](#4-dp优化技巧)
5. [DP常见错误与避坑](#5-dp常见错误与避坑)

---

## 1. 动态规划的本质理解

### 1.1 什么是动态规划？

```
动态规划 = 递归优化 = 避免重复计算

核心思想：
1. 把大问题拆解成小问题
2. 小问题的解可以推导大问题的解
3. 存储中间结果，避免重复计算
```

### 1.2 DP三要素

```
1. 最优子结构
   - 大问题的最优解包含小问题的最优解
   
2. 重叠子问题
   - 同一个子问题被重复计算多次
   
3. 无后效性
   - 当前状态只依赖前面的状态，不依赖后面的状态
```

**举例：爬楼梯**
```
问题：爬到第10阶有多少种方法？

分解：
- 爬到第10阶 = 从第9阶爬1步 + 从第8阶爬2步
- 爬到第9阶 = 从第8阶爬1步 + 从第7阶爬2步
- ...

重复子问题：
- 计算第10阶时需要第9阶和第8阶
- 计算第9阶时也需要第8阶
- 第8阶被重复计算了！→ 需要用DP存储结果
```

---

### 1.3 DP vs 递归

**递归（自顶向下）**：
```cpp
// 斐波那契数列 - 递归实现
int fib(int n) {
    if(n <= 1) return n;
    return fib(n-1) + fib(n-2);  // 重复计算！
}
// 时间复杂度：O(2^n) - 指数级
```

**动态规划（自底向上）**：
```cpp
// 斐波那契数列 - DP实现
int fib(int n) {
    if(n <= 1) return n;
    vector<int> dp(n+1);
    dp[0] = 0, dp[1] = 1;
    for(int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // 每个状态只计算一次
    }
    return dp[n];
}
// 时间复杂度：O(n)
```

**关键区别**：

| 特性 | 递归 | 动态规划 |
|------|------|----------|
| **方向** | 自顶向下 | 自底向上 |
| **重复计算** | 大量重复 | 避免重复 |
| **时间复杂度** | 指数级 O(2^n) | 线性/多项式 O(n) |
| **空间复杂度** | 递归栈 | DP数组 |
| **实现难度** | 简单直观 | 需要思考状态 |

**记忆化搜索（Memoization）**：
```
递归 + 缓存 = 记忆化搜索
- 保持递归的写法
- 加入哈希表/数组存储已计算的结果
- 时间复杂度降到O(n)
```

---

## 2. DP四步解题法

### 核心框架 ⭐⭐⭐

**每道DP题都按这四步思考**：

```
Step 1：状态表示 (State Definition)
- dp[i] 表示什么？
- 明确问题的子问题是什么

Step 2：状态转移方程 (State Transition)
- dp[i] 如何从前面的状态推导？
- 找到递推关系

Step 3：初始化 (Initialization)
- dp[0] 或 dp[1] 等于多少？
- 哪些状态无法通过转移方程得到？

Step 4：填表顺序 (Iteration Order)
- 从左往右？从右往左？
- 二维DP：从上到下？对角线？
```

---

### 2.1 第1步：状态表示

**核心问题**：`dp[i]` 表示什么？

**常见状态定义**：
```
1. 计数问题：dp[i] = 到达状态i的方案数
   示例：爬到第i阶的方法数

2. 最优问题：dp[i] = 到达状态i的最优解（最大/最小值）
   示例：爬到第i阶的最小花费

3. 存在性问题：dp[i] = 是否能到达状态i（true/false）
   示例：是否能凑成金额i
```

**实例分析**：

| 题目 | 状态定义 | 类型 |
|------|----------|------|
| 爬楼梯 | `dp[i] = 爬到第i阶的方法数` | 计数 |
| 最小花费爬楼梯 | `dp[i] = 爬到第i阶的最小花费` | 最优 |
| 泰波那契数列 | `dp[i] = 第i个泰波那契数` | 计数 |

---

### 2.2 第2步：状态转移方程

**核心问题**：`dp[i]` 如何从前面的状态推导？

**找转移方程的思路**：
```
1. 列举当前状态的来源
2. 写出每种来源的贡献
3. 合并所有来源
```

**示例：爬楼梯**
```
问：dp[i] 怎么来的？
答：要爬到第i阶，有两种方式：
    1. 从第i-1阶爬1步
    2. 从第i-2阶爬2步

所以：dp[i] = dp[i-1] + dp[i-2]
```

**常见转移类型**：

| 类型 | 转移方程 | 示例 |
|------|----------|------|
| **加法原理** | `dp[i] = dp[i-1] + dp[i-2]` | 爬楼梯、斐波那契 |
| **最优化** | `dp[i] = min(dp[i-1], dp[i-2])` | 最小花费爬楼梯 |
| **三项递推** | `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]` | 泰波那契、三步问题 |

---

### 2.3 第3步：初始化

**核心问题**：哪些状态需要手动初始化？

**初始化原则**：
```
1. 找到无法通过转移方程得到的状态
2. 这些状态需要手动赋值
3. 通常是dp[0], dp[1], dp[2]等
```

**示例对比**：

| 题目 | 状态转移 | 初始化 |
|------|----------|--------|
| 斐波那契 | `dp[i] = dp[i-1] + dp[i-2]` | `dp[0]=0, dp[1]=1` |
| 泰波那契 | `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]` | `dp[0]=0, dp[1]=1, dp[2]=1` |
| 爬楼梯 | `dp[i] = dp[i-1] + dp[i-2]` | `dp[1]=1, dp[2]=2` |
| 三步问题 | `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]` | `dp[1]=1, dp[2]=2, dp[3]=4` |

**观察**：
```
- 泰波那契和三步问题的转移方程完全相同
- 但初始化不同，导致结果序列不同
- 初始化决定了DP的起点！
```

---

### 2.4 第4步：填表顺序

**核心问题**：从哪个方向填表？

**一维DP**：
```
通常从左往右：for(int i = start; i <= n; i++)

原因：dp[i] 依赖 dp[i-1], dp[i-2] 等前面的状态
```

**二维DP**：
```
常见填表顺序：
1. 逐行填充（从上到下，每行从左到右）
2. 对角线填充（某些区间DP）
3. 逆序填充（背包问题的空间优化）
```

---

### 2.5 DP四步法完整示例

**题目**：爬楼梯（LeetCode 70）

```cpp
class Solution {
public:
    int climbStairs(int n) {
        // Step 1：状态表示
        // dp[i] = 爬到第i阶的方法数
        
        // Step 2：状态转移方程
        // dp[i] = dp[i-1] + dp[i-2]
        
        // Step 3：初始化
        if(n == 1) return 1;
        if(n == 2) return 2;
        
        vector<int> dp(n + 1);
        dp[1] = 1, dp[2] = 2;
        
        // Step 4：填表顺序（从左往右）
        for(int i = 3; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        
        return dp[n];
    }
};
```

---

## 3. DP模型分类

### 模型1：斐波那契模型 ⭐⭐⭐

**适用场景**：Day31已掌握

**特征识别**：
```
✓ 当前状态只依赖前面1-3个状态
✓ 状态转移是简单的加法或min/max
✓ 一维DP数组
✓ 线性递推关系
```

**核心模式**：

#### **类型1：二项递推**
```cpp
// 模板：dp[i] = dp[i-1] + dp[i-2]
// 应用：斐波那契数列、爬楼梯

int solve(int n) {
    if(n <= 2) return /* 边界值 */;
    vector<int> dp(n + 1);
    dp[1] = /* 初始值1 */;
    dp[2] = /* 初始值2 */;
    
    for(int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

#### **类型2：三项递推**
```cpp
// 模板：dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
// 应用：泰波那契数列、三步问题

int solve(int n) {
    if(n <= 3) return /* 边界值 */;
    vector<int> dp(n + 1);
    dp[1] = /* 初始值1 */;
    dp[2] = /* 初始值2 */;
    dp[3] = /* 初始值3 */;
    
    for(int i = 4; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
    }
    return dp[n];
}
```

**已解决题目**（Day31）：
```
1. LeetCode 1137 - 泰波那契数列（三项递推）
2. 三步问题 - 爬楼梯变种（三项递推 + 取模）
```

---

### 模型2：背包问题

（待补充）

---

### 模型3：线性DP

（待补充）

---

### 模型4：区间DP

（待补充）

---

### 模型5：树形DP

（待补充）

---

### 模型6：状态压缩DP

（待补充）

---

## 4. DP优化技巧

### 4.1 空间优化：滚动变量 ⭐⭐⭐

**适用场景**：`dp[i]` 只依赖前面固定的几个状态

**优化原理**：
```
原始：dp[0], dp[1], dp[2], ..., dp[n]  // 需要n+1个空间

优化：只用固定的几个变量滚动
     a      b      c      d
    ↓      ↓      ↓      ↓
  dp[i-3] dp[i-2] dp[i-1] dp[i]
```

---

#### **示例1：斐波那契数列（2个变量）**

**未优化版本**：
```cpp
int fib(int n) {
    if(n <= 1) return n;
    vector<int> dp(n + 1);  // O(n) 空间
    dp[0] = 0, dp[1] = 1;
    for(int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
```

**优化版本**：
```cpp
int fib(int n) {
    if(n <= 1) return n;
    int a = 0, b = 1, c = 0;  // O(1) 空间
    for(int i = 2; i <= n; i++) {
        c = a + b;
        a = b;  // 滚动
        b = c;
    }
    return c;
}
```

---

#### **示例2：泰波那契数列（3个变量）**

**未优化版本**：
```cpp
int tribonacci(int n) {
    if(n == 0) return 0;
    if(n == 1 || n == 2) return 1;
    vector<int> dp(n + 1);  // O(n) 空间
    dp[0] = 0, dp[1] = dp[2] = 1;
    for(int i = 3; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
    }
    return dp[n];
}
```

**优化版本**：
```cpp
int tribonacci(int n) {
    if(n == 0) return 0;
    if(n == 1 || n == 2) return 1;
    int a = 0, b = 1, c = 1, d = 0;  // O(1) 空间
    for(int i = 3; i <= n; i++) {
        d = a + b + c;
        a = b;  // 滚动操作
        b = c;
        c = d;
    }
    return d;
}
```

**滚动过程图解**：
```
i=3: a=0, b=1, c=1  →  d=0+1+1=2  →  a=1, b=1, c=2
i=4: a=1, b=1, c=2  →  d=1+1+2=4  →  a=1, b=2, c=4
i=5: a=1, b=2, c=4  →  d=1+2+4=7  →  a=2, b=4, c=7
...
```

---

#### **优化步骤总结**

```
Step 1：观察依赖关系
- 找出 dp[i] 依赖哪几个状态
- 示例：dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
         → 依赖前3个状态

Step 2：确定变量个数
- 依赖k个状态 → 需要k+1个变量
- 依赖2个 → 3个变量（a, b, c）
- 依赖3个 → 4个变量（a, b, c, d）

Step 3：替换数组访问
- dp[i-3] → a
- dp[i-2] → b
- dp[i-1] → c
- dp[i]   → d

Step 4：滚动更新
每次计算完d后：
a = b;
b = c;
c = d;
```

---

### 4.2 取模运算技巧 ⭐⭐⭐

**场景**：结果可能很大，需要对 `1e9+7` 取模

**常见错误**：
```cpp
// ❌ 错误：先加再取模（可能溢出）
dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % MOD;
```

**正确做法**：
```cpp
// ✅ 正确：分步取模（避免溢出）
dp[i] = ((dp[i-1] + dp[i-2]) % MOD + dp[i-3]) % MOD;
```

---

#### **取模原理**

```
模运算的加法性质：
(a + b + c) % MOD = ((a + b) % MOD + c) % MOD

优势：
- 避免中间结果溢出
- 每次加法后立即取模，保持结果在int范围内
```

---

#### **实际应用：三步问题**

```cpp
class Solution {
public:
    int waysToStep(int n) {
        const int MOD = 1e9 + 7;
        
        if(n == 1 || n == 2) return n;
        if(n == 3) return 4;
        
        vector<int> dp(n + 1);
        dp[1] = 1, dp[2] = 2, dp[3] = 4;
        
        for(int i = 4; i <= n; i++) {
            // 分步取模，避免溢出
            dp[i] = ((dp[i-1] + dp[i-2]) % MOD + dp[i-3]) % MOD;
        }
        
        return dp[n];
    }
};
```

---

#### **取模注意事项**

```
1. 及时取模
   - 每次加法后立即取模
   - 不要等到最后才取模

2. 注意减法
   - 减法可能出现负数
   - 正确写法：(a - b + MOD) % MOD

3. 乘法取模
   - 大数相乘：(1LL * a * b) % MOD
   - 先转long long，再取模

4. 除法取模
   - 需要用逆元
   - (a / b) % MOD ≠ (a % MOD) / (b % MOD)
```

---

### 4.3 边界条件处理

**两种处理方式**：

#### **方法1：提前返回**
```cpp
int solve(int n) {
    if(n == 1 || n == 2) return n;
    if(n == 3) return 4;
    
    vector<int> dp(n + 1);
    dp[1] = 1, dp[2] = 2, dp[3] = 4;
    // ...
}
```

**优点**：简洁清晰  
**缺点**：多个if语句

---

#### **方法2：统一初始化**
```cpp
int solve(int n) {
    vector<int> dp(n + 1);
    if(n >= 1) dp[1] = 1;
    if(n >= 2) dp[2] = 2;
    if(n >= 3) dp[3] = 4;
    
    for(int i = 4; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
    }
    return dp[n];
}
```

**优点**：统一处理  
**缺点**：需要判断n的范围

---

**选择建议**：
```
- 边界条件简单（1-2个）→ 方法1（提前返回）
- 边界条件复杂（3+个）→ 方法2（统一初始化）
```

---

### 4.4 虚拟节点技巧（哨兵节点）⭐⭐⭐

**Day32新增：解码方法（LeetCode 91）核心技巧**

#### **什么是虚拟节点？**

```
在dp数组的开头额外添加一个位置dp[0]，不对应实际数据，
作为"空状态"，用于简化边界条件的处理。
```

---

#### **为什么需要虚拟节点？**

**问题场景**：字符串DP中，状态转移可能依赖"前面没有字符"的情况

**示例**：解码方法（LeetCode 91）

```
s = "12"

如果"12"可以组合解码为"L"，这种方法应该加到哪里？
→ 应该加上"前面0个字符时的方法数"
→ 需要dp[0]来表示这个状态
```

---

#### **虚拟节点的初始化**

**关键问题**：`dp[0]` 应该赋什么值？

```
答案：根据状态转移方程，dp[0]的值要保证后续填表正确
```

**示例1：解码方法**
```cpp
vector<int> dp(n + 1);
dp[0] = 1;  // 空字符串有1种解码方法

为什么是1？
- 当前两个字符可以组合时：dp[2] += dp[0]
- 如果dp[0]=0，组合解码的方法就丢失了
- dp[0]=1 表示"整体组合时，前面没字符的情况贡献1种方法"
```

**示例2：最小花费爬楼梯**
```cpp
vector<int> dp(n + 1);
dp[0] = 0;  // 起点不需要花费
dp[1] = 0;  // 也可以从位置1开始
```

---

#### **索引映射关系** ⭐⭐⭐

使用虚拟节点后，**dp数组索引**和**数据索引**不一致：

```
数据（字符串/数组）：s[0]    s[1]    s[2]    ...  s[n-1]
                      ↓       ↓       ↓            ↓
dp数组索引：         dp[1]   dp[2]   dp[3]   ...  dp[n]
                     ↑
                 dp[0]（虚拟节点）

关键映射：
dp[i] 对应 s[i-1]
dp[i] 表示前i个元素的结果
```

---

#### **代码模板对比**

**无虚拟节点（dp[n]）**：
```cpp
int solve(string s) {
    int n = s.size();
    vector<int> dp(n);
    
    // 需要特殊处理dp[0]和dp[1]
    dp[0] = ...;
    if(n > 1) dp[1] = ...;
    
    for(int i = 2; i < n; i++) {
        dp[i] = f(dp[i-1], dp[i-2]);
    }
    return dp[n-1];
}
```

**有虚拟节点（dp[n+1]）**：
```cpp
int solve(string s) {
    int n = s.size();
    vector<int> dp(n + 1);
    
    // 初始化虚拟节点
    dp[0] = 1;  // 根据问题确定
    dp[1] = s[0] != '0';
    
    for(int i = 2; i <= n; i++) {  // 注意：i <= n
        // 注意索引映射：访问s时用s[i-1]
        if(s[i-1] != '0') 
            dp[i] += dp[i-1];
        // ...
    }
    return dp[n];
}
```

---

#### **对比总结**

| 特性 | 无虚拟节点 | 有虚拟节点 |
|------|-----------|-----------|
| **数组大小** | `dp(n)` | `dp(n+1)` |
| **dp[0]含义** | 第1个元素 | 空状态（虚拟） |
| **循环范围** | `i < n` | `i <= n` |
| **索引映射** | `dp[i] = s[i]` | `dp[i] = s[i-1]` |
| **返回值** | `dp[n-1]` | `dp[n]` |
| **边界处理** | 需要特判 | 逻辑统一 |
| **代码复杂度** | 较高 | 简洁 |

**推荐**：使用虚拟节点，代码更优雅！

---

#### **虚拟节点的通用场景**

| 问题类型 | 虚拟节点作用 | 初始化 | 示例题目 |
|---------|------------|-------|---------|
| **字符串DP** | 表示空字符串 | `dp[0]=1` | 解码方法、最长公共子序列 |
| **路径问题** | 起点的虚拟位置 | `dp[0]=0` | 最小花费爬楼梯 |
| **背包问题** | 容量为0的状态 | `dp[0]=0或1` | 0-1背包、完全背包 |
| **二维DP** | 虚拟行和虚拟列 | `dp[1][0]=1` | 不同路径、编辑距离 |

---

#### **虚拟节点在二维DP中的应用** ⭐⭐⭐ NEW

**Day33新增：二维DP虚拟节点技巧**

##### **一维 vs 二维虚拟节点对比**

```
一维DP：
数据：       arr[0]  arr[1]  arr[2]  ...  arr[n-1]
             ↓       ↓       ↓            ↓
dp数组：    dp[1]   dp[2]   dp[3]   ...  dp[n]
           ↑
        dp[0]（虚拟节点）

二维DP：
原始网格：  grid[0][0]  grid[0][1]  ...  grid[0][n-1]
            grid[1][0]  grid[1][1]  ...  grid[1][n-1]
            ...
            grid[m-1][0] ... grid[m-1][n-1]

dp数组（多开一行一列）：
           dp[0][0]  dp[0][1]  dp[0][2]  ...  dp[0][n]   ← 虚拟行
           dp[1][0]  dp[1][1]  dp[1][2]  ...  dp[1][n]
              ↑                ↓                ↓
            虚拟列          grid[0][0]      grid[0][1]
           dp[2][0]  dp[2][1]  dp[2][2]  ...  dp[2][n]
                                ↓                ↓
                            grid[1][0]      grid[1][1]
           ...
           dp[m][0]  dp[m][1]  ...           dp[m][n]
                                               ↓
                                          grid[m-1][n-1]
```

##### **索引映射关系** ⚠️

```
关键映射：
dp[i][j] 对应 grid[i-1][j-1]
dp[i][j] 表示从起点到 grid[i-1][j-1] 的结果
```

**常见错误**：
```cpp
// ❌ 错误1：两个维度都写成j
if(grid[j-1][j-1] == 0)  

// ❌ 错误2：忘记-1
if(grid[i][j] == 0)

// ✅ 正确
if(grid[i-1][j-1] == 0)
```

##### **初始化技巧**

**问题**：二维DP的虚拟节点 `dp[0][x]` 和 `dp[x][0]` 如何初始化？

**答案**：根据状态转移，让 `dp[1][1]` 的值正确

**示例：不同路径**
```cpp
// 目标：dp[1][1] = dp[0][1] + dp[1][0]
//             = 0 + 1 = 1  ✅

dp[1][0] = 1;  // 左边虚拟节点
dp[0][1] = 0;  // 上边虚拟节点（默认就是0）

或者：
dp[0][1] = 1;  // 上边虚拟节点
dp[1][0] = 0;  // 左边虚拟节点（默认就是0）

两种都可以，只需保证其中一个为1即可！
```

##### **代码模板**

**无虚拟节点（复杂）**：
```cpp
int solve(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    
    // 需要特殊处理第一行和第一列
    dp[0][0] = grid[0][0];
    for(int i = 1; i < m; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
    for(int j = 1; j < n; j++) dp[0][j] = dp[0][j-1] + grid[0][j];
    
    // 填表
    for(int i = 1; i < m; i++) {
        for(int j = 1; j < n; j++) {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
        }
    }
    return dp[m-1][n-1];
}
```

**有虚拟节点（优雅）**：
```cpp
int solve(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> dp(m+1, vector<int>(n+1));  // ⭐ 多开一行一列
    
    dp[1][0] = 1;  // 或 dp[0][1] = 1
    
    // 填表：注意范围是 1 to m, 1 to n
    for(int i = 1; i <= m; i++) {  // ⭐ i <= m
        for(int j = 1; j <= n; j++) {  // ⭐ j <= n
            // ⚠️ 关键：访问原数组时用 grid[i-1][j-1]
            if(grid[i-1][j-1] == 0) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    return dp[m][n];  // ⭐ 返回dp[m][n]
}
```

##### **代码对比总结**

| 特性 | 无虚拟节点 | 有虚拟节点 |
|------|-----------|-----------|
| **数组大小** | `dp(m, vector<int>(n))` | `dp(m+1, vector<int>(n+1))` |
| **dp[0][0]含义** | `grid[0][0]` | 虚拟节点 |
| **循环范围** | `i < m, j < n` | `i <= m, j <= n` |
| **索引映射** | `dp[i][j] = grid[i][j]` | `dp[i][j] ↔ grid[i-1][j-1]` |
| **返回值** | `dp[m-1][n-1]` | `dp[m][n]` |
| **边界处理** | 需要特殊处理第一行第一列 | 逻辑统一，无需特判 |
| **代码复杂度** | 高（需要额外的初始化循环） | 低（一个双重循环搞定） |

**强烈推荐**：二维DP使用虚拟节点，避免大量边界判断！

##### **常见题目**

| 题目 | 虚拟节点初始化 | 索引映射 |
|------|--------------|---------|
| **不同路径 II（LeetCode 63）** | `dp[1][0]=1` | `dp[i][j]` ↔ `ob[i-1][j-1]` |
| **最小路径和（LeetCode 64）** | `dp[1][0]=0, dp[0][1]=0` | `dp[i][j]` ↔ `grid[i-1][j-1]` |
| **编辑距离（LeetCode 72）** | `dp[0][j]=j, dp[i][0]=i` | `dp[i][j]` ↔ `s1[i-1], s2[j-1]` |

---

#### **实战示例：解码方法**

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n = s.size();
        vector<int> dp(n + 1);
        
        // 虚拟节点初始化
        dp[0] = 1;  // 空字符串有1种方法
        dp[1] = s[0] != '0';  // 第1个字符
        
        for(int i = 2; i <= n; i++) {
            // 单独解码（注意：访问s[i-1]）
            if(s[i-1] != '0')
                dp[i] += dp[i-1];
            
            // 组合解码（注意：访问s[i-2]和s[i-1]）
            int t = (s[i-2] - '0') * 10 + s[i-1] - '0';
            if(t >= 10 && t <= 26)
                dp[i] += dp[i-2];
        }
        
        return dp[n];
    }
};
```

**关键点**：
1. `dp(n+1)`：数组大小
2. `dp[0]=1`：技术性初始化
3. `s[i-1]`：索引映射
4. `i<=n`：循环包含n

---

## 5. DP常见错误与避坑

### 5.1 状态定义不清

**错误示例**：
```cpp
// ❌ 不清楚dp[i]的含义
int dp[n];
for(int i = 0; i < n; i++) {
    dp[i] = dp[i-1] + dp[i-2];  // dp[i]到底表示什么？
}
```

**正确做法**：
```cpp
// ✅ 明确状态定义
// dp[i] 表示：爬到第i阶的方法数
vector<int> dp(n + 1);
dp[1] = 1, dp[2] = 2;
for(int i = 3; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2];
}
```

**避坑指南**：
```
Step 1：先写清楚dp[i]的含义（用注释）
Step 2：根据定义写转移方程
Step 3：验证转移方程是否符合定义
```

---

### 5.2 初始化错误

**错误示例1：漏初始化**
```cpp
// ❌ dp[1]和dp[2]未初始化
vector<int> dp(n + 1);
for(int i = 3; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2];  // dp[1]和dp[2]是0！
}
```

**错误示例2：初始化错误**
```cpp
// ❌ 三步问题初始化错误
dp[1] = 1, dp[2] = 2, dp[3] = 3;  // dp[3]应该是4！
```

**正确做法**：
```cpp
// ✅ 手动推导边界值
// n=1: 1种方法（1）
// n=2: 2种方法（1+1, 2）
// n=3: 4种方法（1+1+1, 1+2, 2+1, 3）
dp[1] = 1, dp[2] = 2, dp[3] = 4;
```

**避坑指南**：
```
1. 列出前几项的值，手动计算
2. 验证转移方程能否得到这些值
3. 无法通过转移方程得到的值需要初始化
```

---

### 5.3 数组越界

**错误示例**：
```cpp
// ❌ i-3可能越界
for(int i = 0; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];  // i=0,1,2时越界！
}
```

**正确做法**：
```cpp
// ✅ 从正确的起点开始
for(int i = 4; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
}
```

---

### 5.4 忘记取模

**错误示例**：
```cpp
// ❌ 结果太大，溢出
for(int i = 3; i <= n; i++) {
    dp[i] = dp[i-1] + dp[i-2] + dp[i-3];  // 可能溢出
}
```

**正确做法**：
```cpp
// ✅ 分步取模
const int MOD = 1e9 + 7;
for(int i = 3; i <= n; i++) {
    dp[i] = ((dp[i-1] + dp[i-2]) % MOD + dp[i-3]) % MOD;
}
```

---

### 5.5 DP vs 递归混淆

**问题**：什么时候用DP，什么时候用递归？

**选择指南**：

| 场景 | 选择 | 原因 |
|------|------|------|
| 有重叠子问题 | DP | 避免重复计算 |
| 需要记录路径 | 递归/记忆化 | 更方便回溯 |
| 空间受限 | DP（滚动优化） | 空间O(1) |
| 思路不清晰 | 递归 | 更直观 |

---

## 6. 学习路线与题目推荐

### Day31：斐波那契模型（已完成）✅

**核心掌握**：
- DP四步法
- 空间优化（滚动变量）
- 取模技巧

**题目**：
- ✅ LeetCode 1137 - 泰波那契数列
- ✅ 三步问题 - 爬楼梯变种
- ✅ LeetCode 746 - 使用最小花费爬楼梯

---

### Day32：字符串DP（已完成）✅

**核心掌握**：
- 虚拟节点技巧（一维）
- 索引映射关系
- 字符串DP的状态转移

**题目**：
- ✅ LeetCode 91 - 解码方法
- ✅ LeetCode 62 - 不同路径（基础版）

---

### Day33：二维DP路径问题（已完成）✅

**核心掌握**：
- 二维DP虚拟节点技巧 ⭐
- 二维索引映射关系（`grid[i-1][j-1]`）
- 障碍物处理

**题目**：
- ✅ LeetCode 63 - 不同路径 II

**关键突破**：
- 从一维虚拟节点扩展到二维
- 掌握最易错的下标映射问题

---

### Day34：路径问题进阶（待学习）

**推荐题目**：
- LeetCode 64 - 最小路径和
- LeetCode 120 - 三角形最小路径和
- LeetCode 931 - 下降路径最小和

---

### Day35：打家劫舍系列（待学习）

（待补充）

---

### Day36：股票问题（待学习）

（待补充）

---

## 7. 版本更新记录

### v1.2 (2025-11-02)
- 🎯 新增二维DP虚拟节点技巧 ⭐⭐⭐
- ✅ 掌握二维DP下标映射关系（最易错点）
- ✅ 掌握二维DP初始化技巧
- ✅ 完成路径问题模型（1题）

**基于题目**：
1. LeetCode 63 - 不同路径 II

**核心新增**：
- 二维DP虚拟节点的定义和应用
- `dp[i][j]` ↔ `grid[i-1][j-1]` 索引映射关系
- 常见错误：`grid[j-1][j-1]`（两个维度都是j）
- 有/无虚拟节点的代码对比（二维版）
- 二维DP虚拟节点速查表

**关键突破**：
- 从一维虚拟节点扩展到二维虚拟节点
- 理解虚拟节点统一边界处理的威力

---

### v1.1 (2025-11-01)
- 🎯 新增虚拟节点技巧（哨兵节点）⭐⭐⭐
- ✅ 掌握索引映射关系
- ✅ 掌握字符串DP的状态转移
- ✅ 完成字符串DP模型（1题）

**基于题目**：
1. LeetCode 91 - 解码方法

**核心新增**：
- 虚拟节点的定义和使用场景
- dp[0]初始化的技巧（技术性初始化）
- dp数组索引和字符串索引的映射关系
- 有/无虚拟节点的代码对比

---

### v1.0 (2025-10-31)
- 🎯 建立DP方法论基础框架
- ✅ 掌握DP四步法
- ✅ 掌握空间优化技巧（滚动变量）
- ✅ 掌握取模运算技巧
- ✅ 完成斐波那契模型（3题）

**基于题目**：
1. LeetCode 1137 - 泰波那契数列
2. 三步问题 - 爬楼梯变种
3. LeetCode 746 - 使用最小花费爬楼梯

---

**待完善部分**：
- [ ] 背包问题模型
- [ ] 线性DP模型
- [ ] 区间DP模型
- [ ] 树形DP模型
- [ ] 状态压缩DP模型
- [ ] 路径问题模型
- [ ] 更多优化技巧

---

## 💡 快速查询

### DP四步法速查

```
1. 状态表示：dp[i] 表示什么？
2. 状态转移：dp[i] = f(dp[i-1], dp[i-2], ...)
3. 初始化：dp[0] = ?, dp[1] = ?
4. 填表顺序：从左往右/从右往左
```

### 空间优化速查

```
依赖2个状态 → 3个变量（a, b, c）
依赖3个状态 → 4个变量（a, b, c, d）

滚动模板：
d = f(a, b, c);
a = b; b = c; c = d;
```

### 取模速查

```cpp
const int MOD = 1e9 + 7;

// 加法
dp[i] = ((a + b) % MOD + c) % MOD;

// 减法
dp[i] = (a - b + MOD) % MOD;

// 乘法
dp[i] = (1LL * a * b) % MOD;
```

### 虚拟节点速查 ⭐⭐⭐

#### **一维DP虚拟节点**

```cpp
// 数组大小：比数据长度多1
vector<int> dp(n + 1);

// 初始化：根据问题确定dp[0]的值
dp[0] = 1;  // 或 0，保证后续填表正确

// 循环：注意i <= n
for(int i = 2; i <= n; i++) {
    // 索引映射：访问数据时用data[i-1]
    if(data[i-1] != ...) {
        dp[i] += dp[i-1];
    }
}

// 返回：dp[n]
return dp[n];
```

**记忆口诀**：
```
1. dp(n+1) - 数组多开1
2. dp[0]=? - 技术性初始化
3. data[i-1] - 索引映射-1
4. i<=n - 循环包含n
```

---

#### **二维DP虚拟节点** NEW

```cpp
// 数组大小：行列都多开1
vector<vector<int>> dp(m+1, vector<int>(n+1));

// 初始化：根据问题确定虚拟边界
dp[1][0] = 1;  // 或 dp[0][1] = 1

// 循环：注意i <= m, j <= n
for(int i = 1; i <= m; i++) {
    for(int j = 1; j <= n; j++) {
        // ⚠️ 关键：访问原数组时用grid[i-1][j-1]
        if(grid[i-1][j-1] == 0) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
}

// 返回：dp[m][n]
return dp[m][n];
```

**记忆口诀**：
```
1. dp(m+1, n+1) - 行列都多开1
2. dp[1][0]=1 - 虚拟边界初始化
3. grid[i-1][j-1] - 二维索引都映射-1 ⚠️
4. i<=m, j<=n - 循环都包含边界
```

**常见错误** ❌：
```cpp
grid[j-1][j-1]  // ❌ 两个维度都是j
grid[i][j]      // ❌ 忘记-1
grid[i-1][j-1]  // ✅ 正确
```

---

**持续更新中...**

