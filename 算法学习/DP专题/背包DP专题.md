# 背包DP专题

## 一、背包问题分类

### 1. 01背包
- **特点**：每个物品最多选一次
- **状态转移**：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])`
- **空间优化**：一维数组，**倒序遍历**
- **典型题目**：分割等和子集、最后一块石头重量

### 2. 完全背包
- **特点**：每个物品可以选无限次
- **状态转移**：`dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])`
- **空间优化**：一维数组，**正序遍历**
- **典型题目**：零钱兑换、完全平方数

### 3. 多重背包
- **特点**：每个物品有固定的数量限制
- **状态转移**：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-k*w[i]] + k*v[i])` (0 ≤ k ≤ count[i])
- **优化方式**：二进制拆分、单调队列
- **典型题目**：多重背包基础题

---

## 二、01背包详细框架

### 1. 问题识别
- 关键词："每个物品只能用一次"、"选或不选"
- 目标：在容量限制下，求最大价值/最小重量/是否存在

### 2. 状态定义
```cpp
// 二维版本
dp[i][j] = 从前i个物品中选，容量为j时的最大价值

// 一维版本  
dp[j] = 容量为j时的最大价值
```

### 3. 转移方程
```cpp
// 二维
if (j < w[i]) dp[i][j] = dp[i-1][j];  // 容量不够，只能不选
else dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]);  // 选或不选

// 一维
for (int i = 0; i < n; ++i) {
    for (int j = W; j >= w[i]; --j) {  // 倒序！
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

### 4. 关键理解：为什么倒序？

#### 错误的正序遍历
```cpp
// 错误：会导致重复使用
for (int j = w[i]; j <= W; ++j) {
    dp[j] = max(dp[j], dp[j-w[i]] + v[i]);  // dp[j-w[i]]可能已被当前物品更新
}
```

#### 正确的倒序遍历
```cpp
// 正确：确保每个物品只用一次
for (int j = W; j >= w[i]; --j) {
    dp[j] = max(dp[j], dp[j-w[i]] + v[i]);  // dp[j-w[i]]还是上一行的值
}
```

### 5. 变种题型

#### 存在性问题（bool类型）
```cpp
// 例：能否凑成某个重量
vector<bool> dp(target + 1, false);
dp[0] = true;

for (int num : nums) {
    for (int j = target; j >= num; --j) {
        dp[j] = dp[j] || dp[j-num];
    }
}
```

#### 最小值问题
```cpp
// 例：凑成某个重量的最少物品数
vector<int> dp(amount + 1, amount + 1);
dp[0] = 0;

for (int coin : coins) {
    for (int j = amount; j >= coin; --j) {
        dp[j] = min(dp[j], dp[j-coin] + 1);
    }
}
```

---

## 三、完全背包详细框架

### 1. 问题识别
- 关键词："每个物品可以用无限次"、"物品数量无限"
- 目标：在容量限制下，求最大价值/最少物品数

### 2. 状态定义
```cpp
// 二维版本
dp[i][j] = 从前i种物品中选，容量为j时的最大价值

// 一维版本
dp[j] = 容量为j时的最大价值
```

### 3. 转移方程
```cpp
// 二维
if (j < w[i]) dp[i][j] = dp[i-1][j];
else dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]);  // 注意是dp[i][j-w[i]]

// 一维
for (int i = 0; i < n; ++i) {
    for (int j = w[i]; j <= W; ++j) {  // 正序！
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
    }
}
```

### 4. 关键理解：为什么正序？

#### 正序允许重复使用
```cpp
// 正确：允许物品被多次使用
for (int j = w[i]; j <= W; ++j) {
    dp[j] = max(dp[j], dp[j-w[i]] + v[i]);  // dp[j-w[i]]可能包含当前物品
}
```

**物理意义**：
- `dp[j-w[i]]` 如果已经包含了当前物品，再加上一个当前物品，就是用了两次
- 这正是完全背包想要的：允许无限次使用

---

## 四、二维到一维的优化原理

### 1. 依赖关系分析
```cpp
// 01背包依赖
dp[i][j] 依赖 dp[i-1][j] 和 dp[i-1][j-w[i]]

// 完全背包依赖  
dp[i][j] 依赖 dp[i-1][j] 和 dp[i][j-w[i]]
```

### 2. 优化策略
- **01背包**：只依赖上一行 → 倒序更新，避免污染
- **完全背包**：依赖当前行 → 正序更新，允许重复

### 3. 图示对比

#### 01背包的依赖网络
```
行\列  0   1   2   3   4   5
   0  ■ → ■ → ■ → ■ → ■ → ■
      ↓   ↓   ↓   ↓   ↓   ↓
   1  ■ ← ■ ← ■ ← ■ ← ■ ← ■
      ↓   ↓   ↓   ↓   ↓   ↓
   2  ■ ← ■ ← ■ ← ■ ← ■ ← ■
      
箭头：↓ 只依赖上行（倒序更新）
```

#### 完全背包的依赖网络
```
行\列  0   1   2   3   4   5
   0  ■ → ■ → ■ → ■ → ■ → ■
      ↓   ↘   ↘   ↘   ↘   ↘
   1  ■ → ■ → ■ → ■ → ■ → ■
      ↓   ↘   ↘   ↘   ↘   ↘
   2  ■ → ■ → ■ → ■ → ■ → ■
      
箭头：↓ 依赖上行，↘ 依赖当前行（正序更新）
```

---

## 五、常见题型与技巧

### 1. 分组问题
- **分割等和子集**：能否分成两个相等的子集
- **最后一块石头重量**：分成两堆，最小化差值
- **技巧**：target = sum/2，转化为01背包

### 2. 凑数问题
- **零钱兑换**：凑成金额的最少硬币数
- **组合总和**：凑成目标的组合数
- **技巧**：完全背包，注意求组合数还是排列数

### 3. 体积与价值的关系
- **体积=价值**：如分割等和子集，重量就是价值
- **体积≠价值**：传统背包问题，需要分别考虑

### 5. 初始化策略详解

#### 最大值问题
```cpp
// 至多价值（允许不装满）
vector<int> dp(W + 1, 0);  // 所有状态都可达，"什么都不装"是合法选择
dp[0] = 0;

for (int i = 0; i < n; ++i) {
    for (int j = w[i]; j <= W; ++j) {
        dp[j] = max(dp[j], dp[j-w[i]] + v[i]);  // 无条件转移
    }
}
```

#### 最小值问题
```cpp
// 凑成目标的最少物品数
vector<int> dp(amount + 1, amount + 1);  // 初始化为最大值+1
dp[0] = 0;

for (int coin : coins) {
    for (int j = coin; j <= amount; ++j) {
        dp[j] = min(dp[j], dp[j-coin] + 1);
    }
}
```

#### 恰好装满问题
```cpp
// 必须恰好装满的最大价值
vector<int> dp(W + 1, -INF);  // 初始化为负无穷，表示不可达
dp[0] = 0;  // 只有空背包可达

for (int i = 0; i < n; ++i) {
    for (int j = w[i]; j <= W; ++j) {
        if (dp[j-w[i]] != -INF) {  // 只有前驱状态可达才能转移
            dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
        }
    }
}
```

#### 存在性问题
```cpp
// 能否凑成某个重量
vector<bool> dp(target + 1, false);
dp[0] = true;  // 凑成重量0是可能的（空集）

for (int num : nums) {
    for (int j = target; j >= num; --j) {  // 01背包，倒序
        dp[j] = dp[j] || dp[j-num];
    }
}
```

### 6. dp含义的物理意义

| 问题类型 | dp[j]含义 | 初始化策略 | 转移条件 |
|----------|-----------|------------|----------|
| **至多价值** | "容量j的最大价值" | `dp[0..W] = 0` | 无条件转移 |
| **恰好装满** | "容量j恰好装满时的最大价值" | `dp[0] = 0, dp[1..W] = -∞` | 需要 `dp[j-w[i]] != -∞` |
| **最少物品数** | "凑成j的最少物品数" | `dp[0] = 0, dp[1..W] = INF` | 无条件转移 |
| **存在性** | "能否凑成j" | `dp[0] = true, dp[1..W] = false` | 无条件转移 |

### 7. 关键理解点

#### 为什么恰好装满需要-∞初始化？
- **标记不可达状态**：`dp[j] = -∞` 明确表示容量j无法恰好装满
- **防止错误转移**：`-∞ + value[i]` 还是 `-∞`，不会产生虚假的可达状态
- **语义清晰**：只有真正能恰好装满的状态才有具体数值

#### 转移条件的物理意义
```cpp
// 恰好装满的转移
if (dp[j-w[i]] != -∞) {  // 前提检查
    dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
}
```
- `dp[j-w[i]] != -∞`：确保剩余容量能够恰好装满
- 只有在前驱状态可达的基础上，才能考虑添加当前物品

#### 初始化策略的选择原则
1. **问题要求**：看题目是"至多"还是"恰好"
2. **优化目标**：是最大值、最小值，还是存在性
3. **可行性**：是否允许部分装填

---

## 六、解题模板

### 01背包模板
```cpp
int knapsack01(vector<int>& w, vector<int>& v, int W) {
    int n = w.size();
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < n; ++i) {
        for (int j = W; j >= w[i]; --j) {
            dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
        }
    }
    
    return dp[W];
}
```

### 完全背包模板
```cpp
int completeKnapsack(vector<int>& w, vector<int>& v, int W) {
    int n = w.size();
    vector<int> dp(W + 1, 0);
    
    for (int i = 0; i < n; ++i) {
        for (int j = w[i]; j <= W; ++j) {
            dp[j] = max(dp[j], dp[j-w[i]] + v[i]);
        }
    }
    
    return dp[W];
}
```

### 多重背包模板（二进制拆分）
```cpp
int multipleKnapsack(vector<int>& w, vector<int>& v, vector<int>& cnt, int W) {
    vector<int> dp(W + 1, 0);
    
    // 二进制拆分
    for (int i = 0; i < w.size(); ++i) {
        int k = 1;
        while (k <= cnt[i]) {
            int weight = k * w[i];
            int value = k * v[i];
            
            for (int j = W; j >= weight; --j) {
                dp[j] = max(dp[j], dp[j-weight] + value);
            }
            
            cnt[i] -= k;
            k *= 2;
        }
        
        // 处理剩余部分
        if (cnt[i] > 0) {
            for (int j = W; j >= cnt[i] * w[i]; --j) {
                dp[j] = max(dp[j], dp[j-cnt[i]*w[i]] + cnt[i]*v[i]);
            }
        }
    }
    
    return dp[W];
}
```

### 4. 完全背包的计数问题

#### 组合数问题
```cpp
// 零钱兑换II：求组合数
vector<int> dp(amount + 1, 0);
dp[0] = 1;  // 空集是一种有效组合

for (int coin : coins) {        // 外层：物品
    for (int j = coin; j <= amount; ++j) {  // 内层：容量
        dp[j] += dp[j - coin];  // 计数用加法
    }
}
```

#### 排列数问题
```cpp
// 如果要求排列数
vector<int> dp(amount + 1, 0);
dp[0] = 1;

for (int j = 1; j <= amount; ++j) {    // 外层：容量
    for (int coin : coins) {           // 内层：物品
        if (j >= coin) dp[j] += dp[j - coin];
    }
}
```

#### 整数溢出处理
```cpp
// 防溢出版本（某些平台需要）
for (int coin : coins) {
    for (int j = coin; j <= amount; ++j) {
        if (dp[j] > INT_MAX - dp[j - coin]) continue;  // 防止溢出
        dp[j] += dp[j - coin];
    }
}
```

### 5. 完全背包的遍历顺序对比

| 问题类型 | 外层循环 | 内层循环 | 遍历顺序 | 结果 |
|----------|----------|----------|----------|------|
| **最大值/最小值** | 物品 | 容量 | 正序 | 允许重复使用 |
| **组合数** | 物品 | 容量 | 正序 | 组合不重复 |
| **排列数** | 容量 | 物品 | 正序 | 排列可重复 |

---

## 七、刷题建议

1. **先掌握01背包**：理解状态定义和倒序遍历的原理
2. **再学完全背包**：理解正序遍历和重复使用的逻辑
3. **最后多重背包**：掌握二进制拆分等优化技巧
4. **多做变种题**：存在性、最小值、组合数等不同类型
5. **总结套路**：识别题型，选择合适的模板

---

## 八、今日完全背包总结

### 掌握的三种完全背包类型

#### 1. 最大值问题
```cpp
// 牛客模板题：背包至多能装多大价值
vector<int> dp(V + 1, 0);
for (int i = 0; i < n; ++i) {
    for (int j = v[i]; j <= V; ++j) {
        dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    }
}
```

#### 2. 最小值问题
```cpp
// 零钱兑换I：凑成金额的最少硬币数
vector<int> dp(amount + 1, amount + 1);
dp[0] = 0;
for (int coin : coins) {
    for (int j = coin; j <= amount; ++j) {
        dp[j] = min(dp[j], dp[j - coin] + 1);
    }
}
return dp[amount] > amount ? -1 : dp[amount];
```

#### 3. 计数问题
```cpp
// 零钱兑换II：凑成金额的组合数
vector<int> dp(amount + 1, 0);
dp[0] = 1;
for (int coin : coins) {
    for (int j = coin; j <= amount; ++j) {
        if (dp[j] > INT_MAX - dp[j - coin]) continue;  // 防溢出
        dp[j] += dp[j - coin];
    }
}
return dp[amount];
```

### 关键理解点

#### 可达性处理的本质区别
| 问题类型 | 不可达标记 | 转移操作 | 是否需要检查 | 原因 |
|----------|------------|----------|--------------|------|
| **最大值+恰好装满** | `-∞` | `max(dp[j], dp[j-coin] + value)` | **需要** | 防止 `-∞ + value` 产生虚假状态 |
| **最大值（不要求恰好）** | `0` | `max(dp[j], dp[j-coin] + value)` | **无需** | `0 + value` 不会影响最大值 |
| **最小值** | `INF` | `min(dp[j], dp[j-coin] + 1)` | **无需** | `INF + 1` 更大，`min`自动排除 |
| **计数** | `0` | `dp[j] + dp[j-coin]` | **无需** | `0 + 0 = 0`，不产生虚假计数 |

#### 遍历顺序的物理意义
- **01背包**：倒序确保每个物品只用一次
- **完全背包**：正序允许物品重复使用
- **组合数**：外层物品，内层容量 → 确保组合不重复
- **排列数**：外层容量，内层物品 → 允许排列重复

### 实战技巧
1. **识别问题类型**：最大值、最小值、还是计数？
2. **确定可达性要求**：是否需要"恰好装满"？
3. **选择初始化策略**：根据问题类型选择合适的初始化
4. **注意整数溢出**：某些平台对溢出检查严格
5. **理解遍历顺序**：组合数vs排列数的区别在于遍历顺序
