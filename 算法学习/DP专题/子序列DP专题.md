# 子序列DP专题

> **专题范围**：可跳跃子序列相关的动态规划问题

**最后更新**：2025年11月14日

---

## 📋 专题目录

1. [专题概述](#1-专题概述)
2. [核心思想与模板](#2-核心思想与模板)
3. [模型分类](#3-模型分类)
4. [已解决题目](#4-已解决题目)
5. [学习建议](#5-学习建议)

---

## 1. 专题概述

### 1.1 什么是子序列DP？

**子序列**：可以跳跃的序列片段，如 `[1,2,3,4]` 中的 `[1,3]`、`[2,4]`

**子序列DP特点**：
```
1. 允许跳过元素，但必须保持相对顺序
2. 状态通常是：dp[i] = 以 nums[i] 结尾的某种最优值
3. 转移方式：枚举所有可能的前驱 j < i
4. 时间复杂度：通常 O(n²)，可能有哈希优化到 O(n)
```

### 1.2 与子数组DP的区别

| 特性 | 子数组DP | 子序列DP |
|------|----------|----------|
| 连续性 | 必须连续 | 可以跳跃 |
| 状态含义 | 以i结尾的连续片段 | 以i结尾的子序列 |
| 转移方式 | 延续 vs 重新开始 | 枚举所有前驱 |
| 时间复杂度 | 通常O(n) | 通常O(n²) |

---

## 1.3 两个数组/字符串DP方法论（总览）

> 本节专门归纳「两个数组/两个字符串」相关的 DP 模型，方便快速定位题型。

### 1.3.1 前缀/双序列DP通用模型

**统一状态模板**：

```text
dp[i][j] = 序列1的前 i 个 vs 序列2 的前 j 个 的某种信息

索引映射：
  i ↔ seq1[i-1]
  j ↔ seq2[j-1]
维度：0..m, 0..n（带空前缀）
```

常见三类：

- **最优值型（长度/代价）**：
  - 代表题：
    - 1143 最长公共子序列（LCS）
    - 不相交的线（等价于 LCS）
    - 两个字符串的最小 ASCII 删除和（本质也是在两个串上做"删字符"的最优值DP）
  - 典型思路：
    - 字符相等：`dp[i][j]` 从 `dp[i-1][j-1]` 转移，多出来的贡献是“匹配一次”。
    - 字符不等：`dp[i][j]` 在 `dp[i-1][j]`、`dp[i][j-1]` 中取 `max` 或 `min`。

- **计数型（方案数）**：
  - 代表题：
    - 115 不同的子序列
  - 典型思路：
    - 字符相等时有两种选择：
      - 用当前字符：来自 `dp[i-1][j-1]`
      - 不用当前字符：来自 `dp[i-1][j]`
    - 所以：`dp[i][j] = dp[i-1][j-1] + dp[i-1][j]`
    - 字符不等：`dp[i][j] = dp[i-1][j]`。

- **存在性型（是否可达）**：
  - 代表题：
    - 某些"能否通过操作变成相同"的可达性问题
  - 典型思路：
    - 状态为 `bool`，转移使用逻辑或 `||`，表示多条路径中只要有一条可达即可。

> 实战口诀：看到两个字符串/数组，先问自己——我要的是"最长/最少"、"有多少种"还是"能不能"？
> 对应地，`dp` 里存 **max/min / sum / bool**，状态定义自然就出来了。

### 1.3.2 匹配型DP（通配符/正则/交错）

这类题的模式串和文本串通常语义不对等：一边是"模式"，一边是"文本"。

**统一状态模板**：

```text
dp[i][j] = 模式串 p 的前 j 个字符 能否匹配 文本串 s 的前 i 个字符
```

1. **通配符匹配（?, *）**
   - 规则：
     - `?` 匹配任意单个字符。
     - `*` 匹配任意长度（含 0 个）字符。
   - 初始化：
     - `dp[0][0] = true`
     - `dp[i>0][0] = false`
     - `dp[0][j]`：只有当前缀全是 `*` 时为 true：`dp[0][j] = dp[0][j-1]` if `p[j-1]=='*'`。
   - 转移：
     - 普通字符 / `?`：
       - 若 `p[j-1] == s[i-1]` 或 `p[j-1]=='?'` → `dp[i][j] = dp[i-1][j-1]`。
     - `*`：
       - 匹配空串：`dp[i][j-1]`
       - 匹配至少一个字符：`dp[i-1][j]`
       - 综合：`dp[i][j] = dp[i][j-1] || dp[i-1][j]`。

2. **正则表达式匹配（., *）**
   - 规则：
     - `.` 匹配任意单个字符。
     - `*` 匹配**前一个字符**的任意次重复（含 0 次）。
   - 典型做法：
     - 同样用 `dp[i][j] = p[0..j-1]` 是否匹配 `s[0..i-1]`。
     - 对 `p[j-1]=='*'` 时，重点讨论"用几次前一个字符"：
       - `dp[i][j] = dp[i][j-2]`  // `*` 当 0 次，用掉前一个模式字符和 `*`
       - 如果 `p[j-2]` 能与 `s[i-1]` 匹配：
         - `dp[i][j] |= dp[i-1][j]`  // `*` 多匹配一个当前字符

   - 与通配符匹配的关键差异：
     - `*` 的对象不同：
       - 通配符：`*` 是**独立通配符**，自己就能代表任意串；
       - 正则：`*` 是**操作符**，只作用在前一个字符 `x` 上，表示 `x` 的重复。
     - 转移写法不同：
       - 通配符：`dp[i][j] = dp[i][j-1] || dp[i-1][j]`（看 `j-1` 和 `j`）。
       - 正则：`dp[i][j] = dp[i][j-2]`（用 0 次）+ 条件下的 `dp[i-1][j]`（用 ≥1 次，要看 `j-2`）。
     - 空串匹配：
       - 通配符：前缀全为 `*` 即可匹配空串。
       - 正则：必须是一串 `x*` 的组合（`a*b*c*`）才能逐对跳过。

   - 统一推导套路（匹配型 DP）：
     - 第一步：固定 `dp[i][j] = 模式前缀 vs 文本前缀`。
     - 第二步：按最后一个模式字符分类：普通字符 / `?` / `.` / `*`。
     - 第三步：遇到能"重复/可选"的符号（如 `*`），一律问自己：
       - 分支1：**不用这个模块**（0 次） → 从状态上"删掉模块"；
       - 分支2：**用这个模块**（≥1 次） → 吃掉一个字符，模式位置决定是否停在原处；
       - 最终用 `||` 把两种可行性合并：`dp[i][j] = 分支1 || 分支2`。

3. **交错字符串**
   - 状态：`dp[i][j] = s1前i个 和 s2前j个 能否交错组成 s3前 i+j 个`。
   - 依赖：`dp[i-1][j]` 和 `dp[i][j-1]` 根据 s3 的下一个字符是来自 s1 还是 s2 来转移。
   - 初始化：
     - `dp[0][0] = true`。
     - 第一行：只用 `s2`，需要 `s2[0..j-1]` 和 `s3[0..j-1]` 逐个匹配：`dp[0][j] = dp[0][j-1] && s2[j-1] == s3[j-1]`。
     - 第一列：只用 `s1`，需要 `s1[0..i-1]` 和 `s3[0..i-1]` 逐个匹配：`dp[i][0] = dp[i-1][0] && s1[i-1] == s3[i-1]`。
   - 转移：
     ```text
     dp[i][j] = (s1[i-1] == s3[i+j-1] && dp[i-1][j]) 
             || (s2[j-1] == s3[i+j-1] && dp[i][j-1])
     ```
   - 关键理解：
     - 本质是「两个源串 → 一个目标串」的前缀匹配 DP。
     - 每一步决策：目标字符来自哪个源串。
   4. **最小 ASCII 删除和**
   - 状态：`dp[i][j] = 让 s1前i个 和 s2前j个 相等的最小删除代价`。
   - 初始化：
     - `dp[0][0] = 0`。
     - 第一列：`s2` 为空，只能删 `s1`：`dp[i][0] = dp[i-1][0] + s1[i-1]`。
     - 第一行：`s1` 为空，只能删 `s2`：`dp[0][j] = dp[0][j-1] + s2[j-1]`。
   - 转移：
     - 相等：`dp[i][j] = dp[i-1][j-1]`。
     - 不等：`dp[i][j] = min(dp[i-1][j] + s1[i-1], dp[i][j-1] + s2[j-1])`。
   - 关键理解：
     - 本质是「带权重的 LCS」变种，保留公共部分，删除其余部分。
     - 也可以先求「公共子序列的最大 ASCII 和」，答案 = 总和 - 2 * 公共部分的 ASCII 和。

> 匹配型 DP 的特点：
> - `dp` 多为布尔值；
> - 一边是"模式"，一边是"文本"；
> - 核心在于对特殊符号（`*`, `?`, `.`, 重复等）做**完备的分类讨论**。

---

## 2. 核心思想与模板

### 2.1 基础模板（单序列）

```cpp
// 状态定义：dp[i] = 以nums[i]结尾的某种最优值
vector<int> dp(n, 1);  // 初始化：每个元素自身

for(int i = 0; i < n; i++) {
    for(int j = 0; j < i; j++) {
        if(满足约束条件(j, i)) {
            dp[i] = max(dp[i], dp[j] + 1);
        }
    }
}

// 答案：遍历所有结尾位置
return *max_element(dp.begin(), dp.end());
```

### 2.2 双序列模板

```cpp
// 状态定义：dp[i][j] = seq1前i个 vs seq2前j个 的某种度量
vector<vector<int>> dp(m+1, vector<int>(n+1, 0));

for(int i = 1; i <= m; i++) {
    for(int j = 1; j <= n; j++) {
        if(seq1[i-1] == seq2[j-1]) {
            dp[i][j] = dp[i-1][j-1] + 1;  // 匹配
        } else {
            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);  // 跳过一个
        }
    }
}
```

### 2.3 哈希优化模板

```cpp
// 当前驱可以通过计算直接确定时
unordered_map<int, int> hash;  // value -> dp_value

for(int i = 0; i < n; i++) {
    int target = 计算前驱值(nums[i]);
    if(hash.count(target)) {
        dp[i] = hash[target] + 1;
    } else {
        dp[i] = 1;
    }
    hash[nums[i]] = dp[i];
}
```

---

## 3. 模型分类

### 3.1 基础子序列DP（LIS系列）

**典型问题**：最长递增子序列（LIS）

**状态**：`dp[i] = 以nums[i]结尾的最长递增子序列长度`

**转移**：
```cpp
for(int j = 0; j < i; j++) {
    if(nums[j] < nums[i]) {
        dp[i] = max(dp[i], dp[j] + 1);
    }
}
```

**已解决题目**：
- ✅ LeetCode 300 - 最长递增子序列 ⭐⭐⭐
- ✅ LeetCode 376 - 摆动序列 ⭐⭐⭐
- ✅ LeetCode 673 - 最长递增子序列的个数 ⭐⭐⭐

---

### 3.2 约束子序列DP

**典型问题**：最长数对链

**关键洞察**：约束条件从简单比较变成复杂关系，但DP框架不变

**状态**：`dp[i] = 以pairs[i]结尾的最长数对链长度`

**转移**：
```cpp
for(int j = 0; j < i; j++) {
    if(pairs[j][1] < pairs[i][0]) {  // 复杂约束
        dp[i] = max(dp[i], dp[j] + 1);
    }
}
```

**解题方法论**：
1. **预处理排序**：保证索引顺序=逻辑顺序
2. **抽象约束条件**：把具体约束抽象成判断函数
3. **套用LIS模板**：状态设计和转移完全一致

**已解决题目**：
- ✅ LeetCode 646 - 最长数对链 ⭐⭐⭐

---

### 3.3 双序列DP

**典型问题**：最长公共子序列（LCS）

**状态**：`dp[i][j] = text1前i个字符 vs text2前j个字符的LCS长度`

**转移**：
```cpp
if(text1[i-1] == text2[j-1]) {
    dp[i][j] = dp[i-1][j-1] + 1;  // 匹配
} else {
    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);  // 跳过一个
}
```

**关键理解**：
- **前缀DP**：`dp[i][j]` 表示"前i个"vs"前j个"的整体信息
- **索引映射**：`dp[i][j]` 对应 `seq1[i-1]` 和 `seq2[j-1]`
- **初始化**：处理空序列的情况

**已解决题目**：
- ✅ LeetCode 1143 - 最长公共子序列 ⭐⭐⭐

---

### 3.4 计数类子序列DP

**典型问题**：不同的子序列

**关键变化**：从求"最优值"变成求"方案数"，操作从max变成累加

**状态**：`dp[i][j] = s前i个字符中，t前j个字符出现的方案数`

**转移**：
```cpp
if(s[i-1] == t[j-1]) {
    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];  // 用+不用
} else {
    dp[i][j] = dp[i-1][j];  // 只能不用
}
```

**注意事项**：
- **溢出处理**：方案数可能很大，需要用大数类型或取模
- **初始化**：空目标有1种方法，空源有0种方法

**已解决题目**：
- ✅ LeetCode 115 - 不同的子序列 ⭐⭐⭐

---

### 3.5 双序列DP小结：LCS / 不相交的线 / 不同的子序列

**统一视角**：

```text
dp[i][j] = 序列1的前 i 个元素 vs 序列2 的前 j 个元素 的某种信息

索引映射：
  i ↔ seq1[i-1]
  j ↔ seq2[j-1]
维度：0..m, 0..n（带空前缀）
```

1. **LCS（1143 / 本专题 41 题）**
   - 目标：求「最长公共子序列长度」。
   - 状态：`dp[i][j]` = LCS 长度。
   - 转移：
     - 相等：`dp[i][j] = dp[i-1][j-1] + 1`
     - 不等：`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`

2. **不相交的线（本专题 42 题，对应 LCS 变形）**
   - 题意：两数组连线且不能相交。
   - 关键等价：**不相交 ⇔ 索引相对顺序一致 ⇔ 公共子序列**。
   - 模型：完全套用 LCS，只是把 string 换成 `vector<int>`。

3. **不同的子序列（115 / 本专题 43 题）**
   - 目标：统计「方案数」而不是「最长长度」。
   - 状态：`dp[i][j]` = `s` 前 i 个中，形成 `t` 前 j 个的方案数。
   - 初始化：
     - `dp[i][0] = 1`（空串只有 1 种形成方式：不选）
     - `dp[0][j>0] = 0`（空源无法形成非空目标）
   - 转移：
     - 相等：`dp[i][j] = dp[i-1][j] + dp[i-1][j-1]`（用或不用当前字符）。
     - 不等：`dp[i][j] = dp[i-1][j]`。

**规律总结：双序列DP三种常见类型**

- **最优值型**（LCS / 不相交的线）：
  - `dp` 里存「长度/代价」，转移使用 `max` / `min`。
- **计数型**（不同的子序列）：
  - `dp` 里存「方案数」，转移使用加法 `+`。
- **存在性型**（是否可达）：
  - `dp` 里存布尔值，转移通常是逻辑或 `||`。

> 做题时先判断：我要的是“最长/最少”，“有多少种”，还是“能不能”？
> 再决定 `dp` 里放的是 **max / sum / bool**，模型就自然了。

---

### 3.6 尾部组合型子序列DP

**典型问题**：最长斐波那契子序列长度

**关键洞察**：约束依赖"最后两个元素"，单个尾部状态信息不足

**状态**：`dp[i][j] = 以arr[i], arr[j]为最后两个元素的最长斐波那契子序列长度`

**转移**：
```cpp
// 寻找前驱k：arr[k] + arr[i] = arr[j]
if(存在这样的k) {
    dp[i][j] = dp[k][i] + 1;  // 从(k,i)转移到(i,j)
} else {
    dp[i][j] = 2;  // 只有两个元素的序列
}
```

**与前缀DP的区别**：
- **前缀型**：`dp[i][j]` = "前i/前j"的整体信息 → 转移出现`i-1,j-1`
- **尾部型**：`dp[i][j]` = "以(i,j)为尾巴"的链信息 → 转移是`(k,i)→(i,j)`

**哈希优化**：
```cpp
// 通过数值直接计算前驱：prev = arr[j] - arr[i]
// 用哈希表O(1)定位：k = index[prev]
```

**已解决题目**：
- ✅ LeetCode 873 - 最长斐波那契子序列长度 ⭐⭐⭐

---

### 3.7 哈希表优化子序列DP

**典型问题**：最长定差子序列

**优化原理**：
```
暴力：枚举前驱 O(n) + DP O(n²) = O(n²)
优化：直接计算前驱 + 哈希查找 O(1) = O(n)
```

**适用条件**：
- 约束条件是等式关系
- 前驱数值可以通过当前数值直接计算
- 最多只有一个前驱满足条件

**模板**：
```cpp
unordered_map<int, int> hash;  // value -> 最优解
for(int i = 0; i < n; i++) {
    int prev = 计算前驱值(arr[i]);
    if(hash.count(prev)) {
        dp[i] = hash[prev] + 1;
    } else {
        dp[i] = 1;
    }
    hash[arr[i]] = dp[i];
}
```

**已解决题目**：
- ✅ LeetCode 1218 - 最长定差子序列 ⭐⭐⭐

---

## 4. 已解决题目

### 按难度分类

**⭐⭐ 中等**：
1. LeetCode 300 - 最长递增子序列
2. LeetCode 376 - 摆动序列

**⭐⭐⭐ 困难**：
1. LeetCode 646 - 最长数对链（约束子序列DP）
2. LeetCode 1143 - 最长公共子序列（双序列DP）
3. LeetCode 1218 - 最长定差子序列（哈希表优化）
4. LeetCode 115 - 不同的子序列（计数类DP）
5. LeetCode 673 - 最长递增子序列个数（LIS计数）
6. LeetCode 873 - 最长斐波那契子序列长度（尾部组合型）

### 按学习阶段分类

**Day42 - 基础**：
- LeetCode 300, 376, 673（LIS系列）

**Day43 - 进阶**：
- LeetCode 646（约束子序列DP）
- LeetCode 1143（双序列DP）
- LeetCode 1218（哈希表优化）
- LeetCode 115（计数类DP）

**Day44 - 收尾**：
- LeetCode 873（尾部组合型）

---

## 5. 学习建议

### 5.1 学习路径

1. **LIS基础**：LeetCode 300 → 理解"以i结尾"的核心思想
2. **LIS变种**：LeetCode 376, 673 → 掌握状态变化和计数
3. **约束子序列**：LeetCode 646 → 理解复杂约束的抽象
4. **双序列**：LeetCode 1143 → 掌握二维DP和前缀思维
5. **计数类**：LeetCode 115 → 理解从最优值到计数的转换
6. **哈希优化**：LeetCode 1218 → 掌握O(n²)到O(n)的优化
7. **尾部组合**：LeetCode 873 → 理解多元素依赖的状态设计

### 5.2 关键理解点

**状态设计**：
- 单序列：`dp[i]` = 以i结尾 
- 双序列：`dp[i][j]` = 前i vs 前j
- 尾部组合：`dp[i][j]` = 以(i,j)为尾巴

**转移方程**：
- 最优值：max/min操作
- 计数：累加操作
- 存在性：逻辑或操作

**优化技巧**：
- 空间优化：滚动数组
- 时间优化：哈希表加速前驱查找
- 预处理：排序保证逻辑顺序

### 5.3 常见陷阱

1. **索引对应**：二维DP中`dp[i][j]`与原数组的对应关系
2. **初始化**：空序列的处理
3. **答案位置**：不一定是`dp[n-1]`，可能需要遍历
4. **溢出处理**：计数问题的大数处理
5. **约束理解**：复杂约束条件的正确抽象

---

**返回总览**：[动态规划方法论-总览.md](./动态规划方法论-总览.md)
