# 动态规划方法论 - 总览

> **目标**：建立系统的动态规划思维模型，掌握DP解题套路

**更新日期**：2025年11月14日  
**当前版本**：v2.0 - 模块化重构版

---

## 📋 文档结构

### 核心方法论（本文档）
1. [动态规划的本质理解](#1-动态规划的本质理解)
2. [DP四步解题法](#2-dp四步解题法)
3. [DP通用优化技巧](#3-dp通用优化技巧)
4. [DP常见错误与避坑](#4-dp常见错误与避坑)
5. [学习路线与总结](#5-学习路线与总结)

### 专题突破系列
- 📁 [子数组DP专题](./子数组DP专题.md) - 连续子数组/子区间相关
- 📁 [子序列DP专题](./子序列DP专题.md) - 可跳跃子序列相关
- 📁 [路径DP专题](./路径DP专题.md) - 网格路径、三角形、解码方法等
- 📁 [打家劫舍DP专题](./打家劫舍DP专题.md) - "选或不选"类问题
- 📁 [股票DP专题](./股票DP专题.md) - 多状态DP、复杂约束处理
- 📁 [回文串DP专题](./回文串DP专题.md) - 区间回文判断+分割优化
- 📁 [背包DP专题](./背包DP专题.md) - 0/1背包、完全背包等（待建）

---

## 1. 动态规划的本质理解

### 1.1 什么是动态规划？

```
动态规划 = 递归优化 = 避免重复计算

核心思想：
1. 把大问题拆解成小问题
2. 小问题的解可以推导大问题的解
3. 存储中间结果，避免重复计算
```

### 1.2 DP三要素

```
1. 最优子结构
   - 大问题的最优解包含小问题的最优解
   
2. 重叠子问题
   - 同一个子问题被重复计算多次
   
3. 无后效性
   - 当前状态只依赖前面的状态，不依赖后面的状态
```

### 1.3 DP vs 递归

**递归（自顶向下）**：
```cpp
int fib(int n) {
    if(n <= 1) return n;
    return fib(n-1) + fib(n-2);  // 重复计算！
}
// 时间复杂度：O(2^n)
```

**动态规划（自底向上）**：
```cpp
int fib(int n) {
    if(n <= 1) return n;
    vector<int> dp(n+1);
    dp[0] = 0, dp[1] = 1;
    for(int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    return dp[n];
}
// 时间复杂度：O(n)
```

---

## 2. DP四步解题法

### Step 1: 状态定义
```
确定用什么变量表示子问题
常见模式：
- dp[i] = 以 i 结尾/考虑前 i 个的某种最优值
- dp[i][j] = 二维状态，通常涉及两个序列或两个维度
```

### Step 2: 状态转移方程
```
找出状态间的递推关系
思考：当前状态如何从之前的状态得出
常见模式：
- dp[i] = max/min(dp[j] + ...) for j < i
- dp[i] = dp[i-1] + ... 或 dp[i] = max(dp[i-1], ...)
```

### Step 3: 初始化
```
确定边界条件和初值
常见需要考虑：
- dp[0] 的含义和取值
- 空数组、单元素数组的处理
```

### Step 4: 计算顺序
```
确保计算当前状态时，所依赖的状态已经计算过
常见顺序：
- 一维：从前往后
- 二维：逐行逐列，或按对角线
```

---

## 3. DP通用优化技巧

### 3.1 空间优化：滚动变量
```cpp
// 原始：O(n) 空间
vector<int> dp(n);

// 优化：O(1) 空间（当dp[i]只依赖dp[i-1]时）
int prev = 初始值;
int curr;
for(int i = 1; i < n; i++) {
    curr = f(prev);
    prev = curr;
}
```

### 3.2 哈希表优化
```cpp
// 用哈希表快速定位前驱状态
unordered_map<int, int> valueToIndex;
// O(1) 查找代替 O(n) 枚举
```

### 3.3 取模运算
```cpp
const int MOD = 1e9 + 7;
dp[i] = (dp[i-1] + dp[i-2]) % MOD;
```

### 3.4 虚拟节点技巧
```cpp
// 处理边界：数组多开1位
vector<int> dp(n+1);
dp[0] = 初始值;  // 虚拟的"第0个"
for(int i = 1; i <= n; i++) {
    // 访问原数组用 arr[i-1]
}
```

### 3.5 区间DP索引对应关系

**关键区别：要不要"空状态"？**

| 模型类型 | 状态定义 | dp维度 | 索引映射 | 典型题目 |
|----------|----------|--------|----------|----------|
| **区间DP** | `dp[i][j] = s[i..j] 的信息` | `0..n-1, 0..n-1` | `dp[i][j]` ↔ `s[i..j]` | 647回文子串, 5最长回文子串, 1745/132分割 |
| **前缀DP** | `dp[i][j] = 前 i vs 前 j 的信息` | `0..m, 0..n` | `dp[i][j]` ↔ `s1[i-1], s2[j-1]` | 1143 LCS, 115不同子序列 |
| **网格+虚拟** | `dp[i][j]` 有虚拟外圈 | `0..m, 0..n` | `dp[i][j]` ↔ `grid[i-1][j-1]` | 62/63/64不同路径 |

**判断规则**：
- 状态里出现"**前 i 个**" → 需要 i=0 的空状态 → 访问原数组时用 `i-1`
- 状态里直接写"**区间 [i, j]**" → 不需要空状态 → 直接对应，无偏移
- 看到 **dp 维度比原数组大 1** → 几乎一定有虚拟节点 → 用 `i-1, j-1`

**回文串DP扩展**：
- **基础模型**：`isPal[i][j] = s[i..j]` 是否回文（区间DP）
- **分割模型**：`dp[i] = s[0..i]` 的最少分割次数（前缀DP）
- **混合应用**：预处理用区间DP，求解用前缀DP

---

## 4. DP常见错误与避坑

### 4.1 状态定义不清
```
❌ dp[i] 含义模糊
✅ dp[i] = 以 nums[i] 结尾的最长递增子序列长度
```

### 4.2 转移方程错误
```
❌ 遗漏状态转移的某些情况
✅ 考虑完整：选择当前元素 vs 不选择
```

### 4.3 初始化问题
```
❌ 边界条件处理不当
✅ 仔细考虑 dp[0]、空数组等特殊情况
```

### 4.4 计算顺序错误
```
❌ 使用未计算的状态
✅ 确保依赖状态已计算
```

---

## 5. 学习路线与总结

### 5.1 推荐学习路径

1. **基础DP**：爬楼梯、斐波那契数列
2. **线性DP**：最大子数组和、最长递增子序列
3. **专题突破**：
   - [子数组DP专题](./子数组DP专题.md) - 连续性问题
   - [子序列DP专题](./子序列DP专题.md) - 可跳跃问题
4. **进阶DP**：背包、路径、区间DP

### 5.2 核心思维模式

**状态设计三问**：
1. 用什么变量描述子问题？
2. 这个状态包含足够的信息吗？
3. 状态转移是否自然？

**转移方程三问**：
1. 当前状态依赖哪些历史状态？
2. 是选择最优（max/min）还是累加（sum）？
3. 边界情况如何处理？

---

## 📚 专题文档导航

| 专题 | 文档 | 核心内容 | 难度 |
|------|------|----------|------|
| 子数组DP | [子数组DP专题.md](./子数组DP专题.md) | 连续子数组最优值/计数 | ⭐⭐ |
| 子序列DP | [子序列DP专题.md](./子序列DP专题.md) | 可跳跃子序列，LIS等 | ⭐⭐⭐ |
| 路径DP | [路径DP专题.md](./路径DP专题.md) | 网格路径，虚拟节点技巧 | ⭐⭐ |
| 打家劫舍DP | [打家劫舍DP专题.md](./打家劫舍DP专题.md) | "选或不选"，双状态DP | ⭐⭐ |
| 股票DP | [股票DP专题.md](./股票DP专题.md) | 多状态DP，复杂约束 | ⭐⭐⭐ |
| 回文串DP | [回文串DP专题.md](./回文串DP专题.md) | 区间回文判断+分割优化 | ⭐⭐⭐ |
| 背包DP | [背包DP专题.md](./背包DP专题.md) | 0/1背包，完全背包 | ⭐⭐⭐ |

**使用建议**：
- 新手：按学习路径顺序
- 复习：直接跳转对应专题
- 面试：重点关注⭐⭐⭐专题

---

**持续更新中...** 🚀
